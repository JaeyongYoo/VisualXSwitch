!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACT_VALIDATION_OK	lib/dp_act.hh	46;"	d
ARP_ETH_HEADER_LEN	lib/packets.hh	268;"	d
ARP_HRD_ETHERNET	lib/packets.hh	263;"	d
ARP_OP_REPLY	lib/packets.hh	266;"	d
ARP_OP_REQUEST	lib/packets.hh	265;"	d
ARP_PRO_IP	lib/packets.hh	264;"	d
ARRAY_SIZE	lib/util.hh	71;"	d
BASE_TIMER_INTERVAL	datapath.hh	211;"	d
BUFFER_SIZE	lib/socket-util.cc	192;"	d	file:
BUILDNR	include/config.h	55;"	d
BUILD_ASSERT	lib/util.hh	57;"	d
BUILD_ASSERT_DECL	lib/util.hh	61;"	d
CHAIN_H	lib/chain.hh	35;"	d
CHAIN_MAX_TABLES	lib/chain.hh	56;"	d
CLICK_DATAPATH_H	datapath.hh	2;"	d
CLICK_PORT_NUM_TAP	datapath.hh	76;"	d
CLICK_PORT_START_NUM_ITF	datapath.hh	77;"	d
CLIENT	lib/vconn-ssl.cc	/^    CLIENT,$/;"	e	enum:session_type	file:
COMPILER_H	lib/compiler.hh	35;"	d
CONTAINER_OF	lib/util.hh	90;"	d
CRC32_H	lib/of_crc32.hh	35;"	d
CRC32_TABLE_BITS	lib/of_crc32.hh	45;"	d
CRC32_TABLE_SIZE	lib/of_crc32.hh	46;"	d
CSUM_H	lib/csum.hh	35;"	d
CTRL_ATTR_FAMILY_ID	lib/netlink-protocol.hh	/^        CTRL_ATTR_FAMILY_ID,$/;"	e	enum:__anon8
CTRL_ATTR_FAMILY_NAME	lib/netlink-protocol.hh	/^        CTRL_ATTR_FAMILY_NAME,$/;"	e	enum:__anon8
CTRL_ATTR_HDRSIZE	lib/netlink-protocol.hh	/^        CTRL_ATTR_HDRSIZE,$/;"	e	enum:__anon8
CTRL_ATTR_MAX	lib/netlink-protocol.hh	148;"	d
CTRL_ATTR_MAXATTR	lib/netlink-protocol.hh	/^        CTRL_ATTR_MAXATTR,$/;"	e	enum:__anon8
CTRL_ATTR_OPS	lib/netlink-protocol.hh	/^        CTRL_ATTR_OPS,$/;"	e	enum:__anon8
CTRL_ATTR_OP_FLAGS	lib/netlink-protocol.hh	/^        CTRL_ATTR_OP_FLAGS,$/;"	e	enum:__anon9
CTRL_ATTR_OP_ID	lib/netlink-protocol.hh	/^        CTRL_ATTR_OP_ID,$/;"	e	enum:__anon9
CTRL_ATTR_OP_MAX	lib/netlink-protocol.hh	157;"	d
CTRL_ATTR_OP_UNSPEC	lib/netlink-protocol.hh	/^        CTRL_ATTR_OP_UNSPEC,$/;"	e	enum:__anon9
CTRL_ATTR_UNSPEC	lib/netlink-protocol.hh	/^        CTRL_ATTR_UNSPEC,$/;"	e	enum:__anon8
CTRL_ATTR_VERSION	lib/netlink-protocol.hh	/^        CTRL_ATTR_VERSION,$/;"	e	enum:__anon8
CTRL_CMD_DELFAMILY	lib/netlink-protocol.hh	/^        CTRL_CMD_DELFAMILY,$/;"	e	enum:__anon7
CTRL_CMD_DELOPS	lib/netlink-protocol.hh	/^        CTRL_CMD_DELOPS,$/;"	e	enum:__anon7
CTRL_CMD_GETFAMILY	lib/netlink-protocol.hh	/^        CTRL_CMD_GETFAMILY,$/;"	e	enum:__anon7
CTRL_CMD_GETOPS	lib/netlink-protocol.hh	/^        CTRL_CMD_GETOPS,$/;"	e	enum:__anon7
CTRL_CMD_MAX	lib/netlink-protocol.hh	135;"	d
CTRL_CMD_NEWFAMILY	lib/netlink-protocol.hh	/^        CTRL_CMD_NEWFAMILY,$/;"	e	enum:__anon7
CTRL_CMD_NEWOPS	lib/netlink-protocol.hh	/^        CTRL_CMD_NEWOPS,$/;"	e	enum:__anon7
CTRL_CMD_UNSPEC	lib/netlink-protocol.hh	/^        CTRL_CMD_UNSPEC,$/;"	e	enum:__anon7
Class	lib/vconn-provider.hh	/^    struct pvconn_class *Class;$/;"	m	struct:pvconn	typeref:struct:pvconn::pvconn_class
Class	lib/vconn-provider.hh	/^    struct vconn_class *Class;$/;"	m	struct:vconn	typeref:struct:vconn::vconn_class
DEBUG_TRACE_FUNCTION_CALL	include/config.h	25;"	d
DEBUG_TRACE_FUNCTION_CALL	include/config.h	43;"	d
DEBUG_TRACE_FUNCTION_END	include/config.h	26;"	d
DEBUG_TRACE_FUNCTION_END	include/config.h	44;"	d
DESC_STR_LEN	include/openflow/openflow.hh	773;"	d
DHPARAMS_H	lib/dhparams.hh	2;"	d
DPIF_H	lib/dpif.hh	36;"	d
DP_ACT_H	lib/dp_act.hh	35;"	d
DP_GENL_A_DP_IDX	include/openflow/openflow-netlink.hh	/^	DP_GENL_A_DP_IDX,	 \/* Datapath device index. *\/$/;"	e	enum:__anon3
DP_GENL_A_DP_NAME	include/openflow/openflow-netlink.hh	/^	DP_GENL_A_DP_NAME,	 \/* Datapath device name. *\/$/;"	e	enum:__anon3
DP_GENL_A_MAX	include/openflow/openflow-netlink.hh	/^	DP_GENL_A_MAX = __DP_GENL_A_MAX - 1$/;"	e	enum:__anon3
DP_GENL_A_MC_GROUP	include/openflow/openflow-netlink.hh	/^	DP_GENL_A_MC_GROUP,	 \/* Generic netlink multicast group. *\/$/;"	e	enum:__anon3
DP_GENL_A_OPENFLOW	include/openflow/openflow-netlink.hh	/^	DP_GENL_A_OPENFLOW,  \/* OpenFlow packet. *\/$/;"	e	enum:__anon3
DP_GENL_A_PORTNAME	include/openflow/openflow-netlink.hh	/^	DP_GENL_A_PORTNAME,	 \/* Device name for datapath port. *\/$/;"	e	enum:__anon3
DP_GENL_A_UNSPEC	include/openflow/openflow-netlink.hh	/^	DP_GENL_A_UNSPEC,$/;"	e	enum:__anon3
DP_GENL_C_ADD_DP	include/openflow/openflow-netlink.hh	/^	DP_GENL_C_ADD_DP,	 \/* Create datapath. *\/$/;"	e	enum:dp_genl_command
DP_GENL_C_ADD_PORT	include/openflow/openflow-netlink.hh	/^	DP_GENL_C_ADD_PORT,	 \/* Add port to datapath. *\/$/;"	e	enum:dp_genl_command
DP_GENL_C_DEL_DP	include/openflow/openflow-netlink.hh	/^	DP_GENL_C_DEL_DP,	 \/* Destroy datapath. *\/$/;"	e	enum:dp_genl_command
DP_GENL_C_DEL_PORT	include/openflow/openflow-netlink.hh	/^	DP_GENL_C_DEL_PORT,	 \/* Remove port from datapath. *\/$/;"	e	enum:dp_genl_command
DP_GENL_C_MAX	include/openflow/openflow-netlink.hh	/^	DP_GENL_C_MAX = __DP_GENL_C_MAX - 1$/;"	e	enum:dp_genl_command
DP_GENL_C_OPENFLOW	include/openflow/openflow-netlink.hh	/^	DP_GENL_C_OPENFLOW,  \/* Encapsulated OpenFlow protocol. *\/$/;"	e	enum:dp_genl_command
DP_GENL_C_QUERY_DP	include/openflow/openflow-netlink.hh	/^	DP_GENL_C_QUERY_DP,	 \/* Get multicast group for datapath. *\/$/;"	e	enum:dp_genl_command
DP_GENL_C_UNSPEC	include/openflow/openflow-netlink.hh	/^	DP_GENL_C_UNSPEC,$/;"	e	enum:dp_genl_command
DP_GENL_FAMILY_NAME	include/openflow/openflow-netlink.hh	39;"	d
DP_MAX	include/openflow/openflow-netlink.hh	69;"	d
DP_MAX_PORTS	datapath.hh	174;"	d
DS_EMPTY_INITIALIZER	lib/dynamic-string.hh	53;"	d
DYNAMIC_STRING_H	lib/dynamic-string.hh	35;"	d
Datapath	datapath.cc	/^Datapath::Datapath(): base_timer(this)$/;"	f	class:Datapath
Datapath	datapath.hh	/^class Datapath : public Element { public:$/;"	c
DatapathPacketBuffer	datapath.cc	/^DatapathPacketBuffer::DatapathPacketBuffer()$/;"	f	class:DatapathPacketBuffer
DatapathPacketBuffer	datapath.hh	/^class DatapathPacketBuffer {$/;"	c
Delete	lib/ofpstat.hh	/^		uint64_t Delete;$/;"	m	struct:ofpstat::__anon6
Delete	lib/table.hh	/^    int (*Delete)(class Datapath *dp, struct sw_table *table, $/;"	m	struct:sw_table
EMERG_TABLE_ID_FOR_STATS	datapath.cc	211;"	d	file:
ERROR_CODE	lib/ofp-print.cc	890;"	d	file:
ERROR_TYPE	lib/ofp-print.cc	889;"	d	file:
ETHERTYPE_LLDP	datapath.hh	94;"	d
ETH_ADDR_ARGS	lib/packets.hh	109;"	d
ETH_ADDR_FMT	lib/packets.hh	107;"	d
ETH_ADDR_LEN	lib/packets.hh	45;"	d
ETH_HEADER_LEN	lib/packets.hh	116;"	d
ETH_PAYLOAD_MAX	lib/packets.hh	118;"	d
ETH_PAYLOAD_MIN	lib/packets.hh	117;"	d
ETH_TOTAL_MAX	lib/packets.hh	120;"	d
ETH_TOTAL_MIN	lib/packets.hh	119;"	d
ETH_TYPE_ARP	lib/packets.hh	113;"	d
ETH_TYPE_IP	lib/packets.hh	112;"	d
ETH_TYPE_VLAN	lib/packets.hh	114;"	d
ETH_VLAN_TOTAL_MAX	lib/packets.hh	121;"	d
FATAL_SIGNAL_H	lib/fatal-signal.hh	35;"	d
FLOW_H	lib/flow.hh	34;"	d
FOR_EACH_ENABLED_PORT	lib/stp.cc	151;"	d	file:
GENL_HDRLEN	lib/netlink-protocol.hh	107;"	d
GENL_ID_CTRL	lib/netlink-protocol.hh	122;"	d
GENL_MAX_ID	lib/netlink-protocol.hh	120;"	d
GENL_MIN_ID	lib/netlink-protocol.hh	119;"	d
HASH_H	lib/hash.hh	34;"	d
HAVE_IF_PACKET	include/config.h	58;"	d
HAVE_INTTYPES_H	include/config.h	61;"	d
HAVE_MALLOC_HOOKS	include/config.h	68;"	d
HAVE_MEMORY_H	include/config.h	71;"	d
HAVE_NETLINK	include/config.h	74;"	d
HAVE_STDINT_H	include/config.h	80;"	d
HAVE_STDLIB_H	include/config.h	83;"	d
HAVE_STRINGS_H	include/config.h	86;"	d
HAVE_STRING_H	include/config.h	89;"	d
HAVE_STRSIGNAL	include/config.h	95;"	d
HAVE_SYS_STAT_H	include/config.h	98;"	d
HAVE_SYS_TYPES_H	include/config.h	101;"	d
HAVE_UNISTD_H	include/config.h	104;"	d
ICMP_HEADER_LEN	lib/packets.hh	223;"	d
INC_IFP_STAT	lib/ofpstat.cc	41;"	d	file:
IP_ADDR_LEN	lib/packets.hh	206;"	d
IP_ARGS	lib/packets.hh	184;"	d
IP_DONT_FRAGMENT	lib/packets.hh	200;"	d
IP_FMT	lib/packets.hh	183;"	d
IP_FRAG_OFF_MASK	lib/packets.hh	202;"	d
IP_HEADER_LEN	lib/packets.hh	208;"	d
IP_IHL	lib/packets.hh	191;"	d
IP_IHL_VER	lib/packets.hh	192;"	d
IP_IS_FRAGMENT	lib/packets.hh	203;"	d
IP_MORE_FRAGMENTS	lib/packets.hh	201;"	d
IP_TYPE_ICMP	lib/packets.hh	194;"	d
IP_TYPE_TCP	lib/packets.hh	195;"	d
IP_TYPE_UDP	lib/packets.hh	196;"	d
IP_VER	lib/packets.hh	190;"	d
IP_VERSION	lib/packets.hh	198;"	d
IS_POW2	lib/util.hh	74;"	d
JD	include/config.h	27;"	d
JD	include/config.h	45;"	d
JD_DEBUG	include/config.h	17;"	d
JD_DEBUG_PARSE_CONTROL_PACKET	include/config.h	18;"	d
LEAK_CHECKER_H	lib/leak-checker.hh	35;"	d
LEAK_CHECKER_LONG_OPTIONS	lib/leak-checker.hh	47;"	d
LEAK_CHECKER_OPTION_ENUMS	lib/leak-checker.hh	44;"	d
LEAK_CHECKER_OPTION_HANDLERS	lib/leak-checker.hh	50;"	d
LIST_FOR_EACH	lib/list.hh	74;"	d
LIST_FOR_EACH_REVERSE	lib/list.hh	78;"	d
LIST_FOR_EACH_SAFE	lib/list.hh	82;"	d
LIST_H	lib/list.hh	34;"	d
LIST_INITIALIZER	lib/list.hh	50;"	d
LLC_CNTL_SNAP	lib/packets.hh	131;"	d
LLC_DSAP_SNAP	lib/packets.hh	129;"	d
LLC_HEADER_LEN	lib/packets.hh	133;"	d
LLC_SNAP_HEADER_LEN	lib/packets.hh	150;"	d
LLC_SSAP_SNAP	lib/packets.hh	130;"	d
MALLOC_LIKE	lib/compiler.hh	42;"	d
MAX	lib/util.hh	81;"	d
MAX_FLOW_STATS_BYTES	datapath.cc	210;"	d	file:
MAX_HOOKS	lib/fatal-signal.cc	58;"	d	file:
MAX_MONITORS	lib/rconn.cc	136;"	d	file:
MAX_PROCESSES	lib/netlink.cc	975;"	d	file:
MAX_SOCKETS	lib/netlink.cc	972;"	d	file:
MESSAGE_AGE_INCREMENT	lib/stp.cc	166;"	d	file:
MIN	lib/util.hh	77;"	d
NETDEV_MAX_QUEUES	datapath.hh	116;"	d
NETLINK_ADD_MEMBERSHIP	lib/netlink-protocol.hh	96;"	d
NETLINK_ADD_MEMBERSHIP	lib/netlink.cc	173;"	d	file:
NETLINK_DROP_MEMBERSHIP	lib/netlink-protocol.hh	97;"	d
NETLINK_GENERIC	lib/netlink-protocol.hh	47;"	d
NETLINK_H	lib/netlink.hh	38;"	d
NETLINK_PKTINFO	lib/netlink-protocol.hh	98;"	d
NETLINK_PROTOCOL_H	lib/netlink-protocol.hh	35;"	d
NICIRA_OUI_STR	include/openflow/nicira-ext.hh	12;"	d
NLA_ALIGN	lib/netlink-protocol.hh	116;"	d
NLA_ALIGNTO	lib/netlink-protocol.hh	115;"	d
NLA_HDRLEN	lib/netlink-protocol.hh	117;"	d
NLMSG_ALIGN	lib/netlink-protocol.hh	86;"	d
NLMSG_ALIGNTO	lib/netlink-protocol.hh	85;"	d
NLMSG_DONE	lib/netlink-protocol.hh	71;"	d
NLMSG_ERROR	lib/netlink-protocol.hh	70;"	d
NLMSG_HDRLEN	lib/netlink-protocol.hh	87;"	d
NLMSG_MIN_TYPE	lib/netlink-protocol.hh	74;"	d
NLMSG_NOOP	lib/netlink-protocol.hh	69;"	d
NLMSG_OVERRUN	lib/netlink-protocol.hh	72;"	d
NLM_F_ACK	lib/netlink-protocol.hh	60;"	d
NLM_F_ATOMIC	lib/netlink-protocol.hh	65;"	d
NLM_F_DUMP	lib/netlink-protocol.hh	66;"	d
NLM_F_ECHO	lib/netlink-protocol.hh	61;"	d
NLM_F_MATCH	lib/netlink-protocol.hh	64;"	d
NLM_F_MULTI	lib/netlink-protocol.hh	59;"	d
NLM_F_REQUEST	lib/netlink-protocol.hh	58;"	d
NLM_F_ROOT	lib/netlink-protocol.hh	63;"	d
NL_ATTR_GET_AS	lib/netlink.cc	704;"	d	file:
NL_A_FLAG	lib/netlink.hh	/^    NL_A_FLAG,$/;"	e	enum:nl_attr_type
NL_A_NESTED	lib/netlink.hh	/^    NL_A_NESTED,$/;"	e	enum:nl_attr_type
NL_A_NO_ATTR	lib/netlink.hh	/^    NL_A_NO_ATTR = 0,$/;"	e	enum:nl_attr_type
NL_A_STRING	lib/netlink.hh	/^    NL_A_STRING,$/;"	e	enum:nl_attr_type
NL_A_U16	lib/netlink.hh	/^    NL_A_U16,$/;"	e	enum:nl_attr_type
NL_A_U32	lib/netlink.hh	/^    NL_A_U32,$/;"	e	enum:nl_attr_type
NL_A_U64	lib/netlink.hh	/^    NL_A_U64,$/;"	e	enum:nl_attr_type
NL_A_U8	lib/netlink.hh	/^    NL_A_U8,$/;"	e	enum:nl_attr_type
NL_A_UNSPEC	lib/netlink.hh	/^    NL_A_UNSPEC,$/;"	e	enum:nl_attr_type
NOT_IMPLEMENTED	lib/util.hh	85;"	d
NOT_REACHED	lib/util.hh	84;"	d
NOT_TESTED	lib/util.hh	86;"	d
NO_RETURN	lib/compiler.hh	37;"	d
NXAST_SNAT	include/openflow/nicira-ext.hh	/^    NXAST_SNAT                      \/* Source-NAT *\/$/;"	e	enum:nx_action_subtype
NXFER_DELETE	include/openflow/nicira-ext.hh	/^    NXFER_DELETE,               \/* Flow was removed by delete command. *\/$/;"	e	enum:nx_flow_end_reason
NXFER_EJECT	include/openflow/nicira-ext.hh	/^    NXFER_EJECT                 \/* Flow was ejected. *\/$/;"	e	enum:nx_flow_end_reason
NXFER_HARD_TIMEOUT	include/openflow/nicira-ext.hh	/^    NXFER_HARD_TIMEOUT,         \/* Time exceeded hard_timeout. *\/$/;"	e	enum:nx_flow_end_reason
NXFER_IDLE_TIMEOUT	include/openflow/nicira-ext.hh	/^    NXFER_IDLE_TIMEOUT,         \/* Flow idle time exceeded idle_timeout. *\/$/;"	e	enum:nx_flow_end_reason
NXSC_ADD	include/openflow/nicira-ext.hh	/^    NXSC_ADD,$/;"	e	enum:nx_snat_command
NXSC_DELETE	include/openflow/nicira-ext.hh	/^    NXSC_DELETE$/;"	e	enum:nx_snat_command
NXT_ACT_GET_CONFIG	include/openflow/nicira-ext.hh	/^    NXT_ACT_GET_CONFIG,$/;"	e	enum:nicira_type
NXT_ACT_SET_CONFIG	include/openflow/nicira-ext.hh	/^    NXT_ACT_SET_CONFIG,$/;"	e	enum:nicira_type
NXT_COMMAND_REPLY	include/openflow/nicira-ext.hh	/^    NXT_COMMAND_REPLY,$/;"	e	enum:nicira_type
NXT_COMMAND_REQUEST	include/openflow/nicira-ext.hh	/^    NXT_COMMAND_REQUEST,$/;"	e	enum:nicira_type
NXT_FLOW_END	include/openflow/nicira-ext.hh	/^    NXT_FLOW_END$/;"	e	enum:nicira_type
NXT_FLOW_END_CONFIG	include/openflow/nicira-ext.hh	/^    NXT_FLOW_END_CONFIG,$/;"	e	enum:nicira_type
NXT_STATUS_COREDUMP	include/openflow/nicira-ext.hh	/^    NXT_STATUS_COREDUMP = 1 << 28, \/* Exited with core dump. *\/$/;"	e	enum:__anon2
NXT_STATUS_ERROR	include/openflow/nicira-ext.hh	/^    NXT_STATUS_ERROR = 1 << 27,    \/* Command could not be executed. *\/$/;"	e	enum:__anon2
NXT_STATUS_EXITED	include/openflow/nicira-ext.hh	/^    NXT_STATUS_EXITED = 1 << 31,   \/* Exited normally. *\/$/;"	e	enum:__anon2
NXT_STATUS_EXITSTATUS	include/openflow/nicira-ext.hh	/^    NXT_STATUS_EXITSTATUS = 0xff,  \/* Exit code mask if NXT_STATUS_EXITED. *\/$/;"	e	enum:__anon2
NXT_STATUS_REPLY	include/openflow/nicira-ext.hh	/^    NXT_STATUS_REPLY,$/;"	e	enum:nicira_type
NXT_STATUS_REQUEST	include/openflow/nicira-ext.hh	/^    NXT_STATUS_REQUEST,$/;"	e	enum:nicira_type
NXT_STATUS_SIGNALED	include/openflow/nicira-ext.hh	/^    NXT_STATUS_SIGNALED = 1 << 30, \/* Exited due to signal. *\/$/;"	e	enum:__anon2
NXT_STATUS_STARTED	include/openflow/nicira-ext.hh	/^    NXT_STATUS_STARTED = 1 << 26,  \/* Command was started. *\/$/;"	e	enum:__anon2
NXT_STATUS_TERMSIG	include/openflow/nicira-ext.hh	/^    NXT_STATUS_TERMSIG = 0xff,     \/* Signal number if NXT_STATUS_SIGNALED. *\/$/;"	e	enum:__anon2
NXT_STATUS_UNKNOWN	include/openflow/nicira-ext.hh	/^    NXT_STATUS_UNKNOWN = 1 << 29,  \/* Exited for unknown reason. *\/$/;"	e	enum:__anon2
NX_VENDOR_ID	include/openflow/nicira-ext.hh	18;"	d
N_ERROR_TYPES	lib/ofp-print.cc	918;"	d	file:
N_NL_ATTR_TYPES	lib/netlink.hh	/^    N_NL_ATTR_TYPES$/;"	e	enum:nl_attr_type
N_PKT_BUFFERS	datapath.hh	85;"	d
OFPAT_ENQUEUE	include/openflow/openflow.hh	/^    OFPAT_ENQUEUE,          \/* Output to queue.  *\/$/;"	e	enum:ofp_action_type
OFPAT_OUTPUT	include/openflow/openflow.hh	/^    OFPAT_OUTPUT,           \/* Output to switch port. *\/$/;"	e	enum:ofp_action_type
OFPAT_SET_DL_DST	include/openflow/openflow.hh	/^    OFPAT_SET_DL_DST,       \/* Ethernet destination address. *\/$/;"	e	enum:ofp_action_type
OFPAT_SET_DL_SRC	include/openflow/openflow.hh	/^    OFPAT_SET_DL_SRC,       \/* Ethernet source address. *\/$/;"	e	enum:ofp_action_type
OFPAT_SET_NW_DST	include/openflow/openflow.hh	/^    OFPAT_SET_NW_DST,       \/* IP destination address. *\/$/;"	e	enum:ofp_action_type
OFPAT_SET_NW_SRC	include/openflow/openflow.hh	/^    OFPAT_SET_NW_SRC,       \/* IP source address. *\/$/;"	e	enum:ofp_action_type
OFPAT_SET_NW_TOS	include/openflow/openflow.hh	/^    OFPAT_SET_NW_TOS,       \/* IP ToS (DSCP field, 6 bits). *\/$/;"	e	enum:ofp_action_type
OFPAT_SET_TP_DST	include/openflow/openflow.hh	/^    OFPAT_SET_TP_DST,       \/* TCP\/UDP destination port. *\/$/;"	e	enum:ofp_action_type
OFPAT_SET_TP_SRC	include/openflow/openflow.hh	/^    OFPAT_SET_TP_SRC,       \/* TCP\/UDP source port. *\/$/;"	e	enum:ofp_action_type
OFPAT_SET_VLAN_PCP	include/openflow/openflow.hh	/^    OFPAT_SET_VLAN_PCP,     \/* Set the 802.1q priority. *\/$/;"	e	enum:ofp_action_type
OFPAT_SET_VLAN_VID	include/openflow/openflow.hh	/^    OFPAT_SET_VLAN_VID,     \/* Set the 802.1q VLAN id. *\/$/;"	e	enum:ofp_action_type
OFPAT_STRIP_VLAN	include/openflow/openflow.hh	/^    OFPAT_STRIP_VLAN,       \/* Strip the 802.1q header. *\/$/;"	e	enum:ofp_action_type
OFPAT_VENDOR	include/openflow/openflow.hh	/^    OFPAT_VENDOR = 0xffff$/;"	e	enum:ofp_action_type
OFPBAC_BAD_ARGUMENT	include/openflow/openflow.hh	/^    OFPBAC_BAD_ARGUMENT,       \/* Bad action argument. *\/$/;"	e	enum:ofp_bad_action_code
OFPBAC_BAD_LEN	include/openflow/openflow.hh	/^    OFPBAC_BAD_LEN,            \/* Length problem in actions. *\/$/;"	e	enum:ofp_bad_action_code
OFPBAC_BAD_OUT_PORT	include/openflow/openflow.hh	/^    OFPBAC_BAD_OUT_PORT,       \/* Problem validating output action. *\/$/;"	e	enum:ofp_bad_action_code
OFPBAC_BAD_QUEUE	include/openflow/openflow.hh	/^    OFPBAC_BAD_QUEUE           \/* Problem validating output queue. *\/$/;"	e	enum:ofp_bad_action_code
OFPBAC_BAD_TYPE	include/openflow/openflow.hh	/^    OFPBAC_BAD_TYPE,           \/* Unknown action type. *\/$/;"	e	enum:ofp_bad_action_code
OFPBAC_BAD_VENDOR	include/openflow/openflow.hh	/^    OFPBAC_BAD_VENDOR,         \/* Unknown vendor id specified. *\/$/;"	e	enum:ofp_bad_action_code
OFPBAC_BAD_VENDOR_TYPE	include/openflow/openflow.hh	/^    OFPBAC_BAD_VENDOR_TYPE,    \/* Unknown action type for vendor id. *\/$/;"	e	enum:ofp_bad_action_code
OFPBAC_EPERM	include/openflow/openflow.hh	/^    OFPBAC_EPERM,              \/* Permissions error. *\/$/;"	e	enum:ofp_bad_action_code
OFPBAC_TOO_MANY	include/openflow/openflow.hh	/^    OFPBAC_TOO_MANY,           \/* Can't handle this many actions. *\/$/;"	e	enum:ofp_bad_action_code
OFPBRC_BAD_LEN	include/openflow/openflow.hh	/^    OFPBRC_BAD_LEN,             \/* Wrong request length for type. *\/$/;"	e	enum:ofp_bad_request_code
OFPBRC_BAD_STAT	include/openflow/openflow.hh	/^    OFPBRC_BAD_STAT,            \/* ofp_stats_request.type not supported. *\/$/;"	e	enum:ofp_bad_request_code
OFPBRC_BAD_SUBTYPE	include/openflow/openflow.hh	/^    OFPBRC_BAD_SUBTYPE,         \/* Vendor subtype not supported. *\/$/;"	e	enum:ofp_bad_request_code
OFPBRC_BAD_TYPE	include/openflow/openflow.hh	/^    OFPBRC_BAD_TYPE,            \/* ofp_header.type not supported. *\/$/;"	e	enum:ofp_bad_request_code
OFPBRC_BAD_VENDOR	include/openflow/openflow.hh	/^    OFPBRC_BAD_VENDOR,          \/* Vendor not supported (in ofp_vendor_header$/;"	e	enum:ofp_bad_request_code
OFPBRC_BAD_VERSION	include/openflow/openflow.hh	/^    OFPBRC_BAD_VERSION,         \/* ofp_header.version not supported. *\/$/;"	e	enum:ofp_bad_request_code
OFPBRC_BUFFER_EMPTY	include/openflow/openflow.hh	/^    OFPBRC_BUFFER_EMPTY,        \/* Specified buffer has already been used. *\/$/;"	e	enum:ofp_bad_request_code
OFPBRC_BUFFER_UNKNOWN	include/openflow/openflow.hh	/^    OFPBRC_BUFFER_UNKNOWN       \/* Specified buffer does not exist. *\/$/;"	e	enum:ofp_bad_request_code
OFPBRC_EPERM	include/openflow/openflow.hh	/^    OFPBRC_EPERM,               \/* Permissions error. *\/$/;"	e	enum:ofp_bad_request_code
OFPBUF_H	lib/ofpbuf.hh	35;"	d
OFPC_ARP_MATCH_IP	include/openflow/openflow.hh	/^    OFPC_ARP_MATCH_IP   = 1 << 7   \/* Match IP addresses in ARP pkts. *\/$/;"	e	enum:ofp_capabilities
OFPC_FLOW_STATS	include/openflow/openflow.hh	/^    OFPC_FLOW_STATS     = 1 << 0,  \/* Flow statistics. *\/$/;"	e	enum:ofp_capabilities
OFPC_FRAG_DROP	include/openflow/openflow.hh	/^    OFPC_FRAG_DROP     = 1,  \/* Drop fragments. *\/$/;"	e	enum:ofp_config_flags
OFPC_FRAG_MASK	include/openflow/openflow.hh	/^    OFPC_FRAG_MASK     = 3$/;"	e	enum:ofp_config_flags
OFPC_FRAG_NORMAL	include/openflow/openflow.hh	/^    OFPC_FRAG_NORMAL   = 0,  \/* No special handling for fragments. *\/$/;"	e	enum:ofp_config_flags
OFPC_FRAG_REASM	include/openflow/openflow.hh	/^    OFPC_FRAG_REASM    = 2,  \/* Reassemble (only if OFPC_IP_REASM set). *\/$/;"	e	enum:ofp_config_flags
OFPC_IP_REASM	include/openflow/openflow.hh	/^    OFPC_IP_REASM       = 1 << 5,  \/* Can reassemble IP fragments. *\/$/;"	e	enum:ofp_capabilities
OFPC_PORT_STATS	include/openflow/openflow.hh	/^    OFPC_PORT_STATS     = 1 << 2,  \/* Port statistics. *\/$/;"	e	enum:ofp_capabilities
OFPC_QUEUE_STATS	include/openflow/openflow.hh	/^    OFPC_QUEUE_STATS    = 1 << 6,  \/* Queue statistics. *\/$/;"	e	enum:ofp_capabilities
OFPC_RESERVED	include/openflow/openflow.hh	/^    OFPC_RESERVED       = 1 << 4,  \/* Reserved, must be zero. *\/$/;"	e	enum:ofp_capabilities
OFPC_STP	include/openflow/openflow.hh	/^    OFPC_STP            = 1 << 3,  \/* 802.1d spanning tree. *\/$/;"	e	enum:ofp_capabilities
OFPC_TABLE_STATS	include/openflow/openflow.hh	/^    OFPC_TABLE_STATS    = 1 << 1,  \/* Table statistics. *\/$/;"	e	enum:ofp_capabilities
OFPET_BAD_ACTION	include/openflow/openflow.hh	/^    OFPET_BAD_ACTION,           \/* Error in action description. *\/$/;"	e	enum:ofp_error_type
OFPET_BAD_REQUEST	include/openflow/openflow.hh	/^    OFPET_BAD_REQUEST,          \/* Request was not understood. *\/$/;"	e	enum:ofp_error_type
OFPET_FLOW_MOD_FAILED	include/openflow/openflow.hh	/^    OFPET_FLOW_MOD_FAILED,      \/* Problem modifying flow entry. *\/$/;"	e	enum:ofp_error_type
OFPET_HELLO_FAILED	include/openflow/openflow.hh	/^    OFPET_HELLO_FAILED,         \/* Hello protocol failed. *\/$/;"	e	enum:ofp_error_type
OFPET_PORT_MOD_FAILED	include/openflow/openflow.hh	/^    OFPET_PORT_MOD_FAILED,      \/* Port mod request failed. *\/$/;"	e	enum:ofp_error_type
OFPET_QUEUE_OP_FAILED	include/openflow/openflow.hh	/^    OFPET_QUEUE_OP_FAILED       \/* Queue operation failed. *\/$/;"	e	enum:ofp_error_type
OFPE_BWSHAPER	RConn.hh	53;"	d
OFPE_DATAPATH	RConn.hh	52;"	d
OFPE_RCONN	RConn.hh	51;"	d
OFPFC_ADD	include/openflow/openflow.hh	/^    OFPFC_ADD,              \/* New flow. *\/$/;"	e	enum:ofp_flow_mod_command
OFPFC_DELETE	include/openflow/openflow.hh	/^    OFPFC_DELETE,           \/* Delete all matching flows. *\/$/;"	e	enum:ofp_flow_mod_command
OFPFC_DELETE_STRICT	include/openflow/openflow.hh	/^    OFPFC_DELETE_STRICT    \/* Strictly match wildcards and priority. *\/$/;"	e	enum:ofp_flow_mod_command
OFPFC_MODIFY	include/openflow/openflow.hh	/^    OFPFC_MODIFY,           \/* Modify all matching flows. *\/$/;"	e	enum:ofp_flow_mod_command
OFPFC_MODIFY_STRICT	include/openflow/openflow.hh	/^    OFPFC_MODIFY_STRICT,    \/* Modify entry strictly matching wildcards *\/$/;"	e	enum:ofp_flow_mod_command
OFPFF_CHECK_OVERLAP	include/openflow/openflow.hh	/^    OFPFF_CHECK_OVERLAP = 1 << 1,  \/* Check for overlapping entries first. *\/$/;"	e	enum:ofp_flow_mod_flags
OFPFF_EMERG	include/openflow/openflow.hh	/^    OFPFF_EMERG         = 1 << 2   \/* Remark this is for emergency. *\/$/;"	e	enum:ofp_flow_mod_flags
OFPFF_SEND_FLOW_REM	include/openflow/openflow.hh	/^    OFPFF_SEND_FLOW_REM = 1 << 0,  \/* Send flow removed message when flow$/;"	e	enum:ofp_flow_mod_flags
OFPFMFC_ALL_TABLES_FULL	include/openflow/openflow.hh	/^    OFPFMFC_ALL_TABLES_FULL,    \/* Flow not added because of full tables. *\/$/;"	e	enum:ofp_flow_mod_failed_code
OFPFMFC_BAD_COMMAND	include/openflow/openflow.hh	/^    OFPFMFC_BAD_COMMAND,        \/* Unknown command. *\/$/;"	e	enum:ofp_flow_mod_failed_code
OFPFMFC_BAD_EMERG_TIMEOUT	include/openflow/openflow.hh	/^    OFPFMFC_BAD_EMERG_TIMEOUT,  \/* Flow not added because of non-zero idle\/hard$/;"	e	enum:ofp_flow_mod_failed_code
OFPFMFC_EPERM	include/openflow/openflow.hh	/^    OFPFMFC_EPERM,              \/* Permissions error. *\/$/;"	e	enum:ofp_flow_mod_failed_code
OFPFMFC_OVERLAP	include/openflow/openflow.hh	/^    OFPFMFC_OVERLAP,            \/* Attempted to add overlapping flow with$/;"	e	enum:ofp_flow_mod_failed_code
OFPFMFC_UNSUPPORTED	include/openflow/openflow.hh	/^    OFPFMFC_UNSUPPORTED         \/* Unsupported action list - cannot process in$/;"	e	enum:ofp_flow_mod_failed_code
OFPFW_ALL	include/openflow/openflow.hh	/^    OFPFW_ALL = ((1 << 22) - 1)$/;"	e	enum:ofp_flow_wildcards
OFPFW_DL_DST	include/openflow/openflow.hh	/^    OFPFW_DL_DST   = 1 << 3,  \/* Ethernet destination address. *\/$/;"	e	enum:ofp_flow_wildcards
OFPFW_DL_SRC	include/openflow/openflow.hh	/^    OFPFW_DL_SRC   = 1 << 2,  \/* Ethernet source address. *\/$/;"	e	enum:ofp_flow_wildcards
OFPFW_DL_TYPE	include/openflow/openflow.hh	/^    OFPFW_DL_TYPE  = 1 << 4,  \/* Ethernet frame type. *\/$/;"	e	enum:ofp_flow_wildcards
OFPFW_DL_VLAN	include/openflow/openflow.hh	/^    OFPFW_DL_VLAN  = 1 << 1,  \/* VLAN id. *\/$/;"	e	enum:ofp_flow_wildcards
OFPFW_DL_VLAN_PCP	include/openflow/openflow.hh	/^    OFPFW_DL_VLAN_PCP = 1 << 20,  \/* VLAN priority. *\/$/;"	e	enum:ofp_flow_wildcards
OFPFW_ICMP_CODE	include/openflow/openflow.hh	518;"	d
OFPFW_ICMP_TYPE	include/openflow/openflow.hh	517;"	d
OFPFW_IN_PORT	include/openflow/openflow.hh	/^    OFPFW_IN_PORT  = 1 << 0,  \/* Switch input port. *\/$/;"	e	enum:ofp_flow_wildcards
OFPFW_NW	lib/switch-flow.cc	140;"	d	file:
OFPFW_NW_DST_ALL	include/openflow/openflow.hh	/^    OFPFW_NW_DST_ALL = 32 << OFPFW_NW_DST_SHIFT,$/;"	e	enum:ofp_flow_wildcards
OFPFW_NW_DST_BITS	include/openflow/openflow.hh	/^    OFPFW_NW_DST_BITS = 6,$/;"	e	enum:ofp_flow_wildcards
OFPFW_NW_DST_MASK	include/openflow/openflow.hh	/^    OFPFW_NW_DST_MASK = ((1 << OFPFW_NW_DST_BITS) - 1) << OFPFW_NW_DST_SHIFT,$/;"	e	enum:ofp_flow_wildcards
OFPFW_NW_DST_SHIFT	include/openflow/openflow.hh	/^    OFPFW_NW_DST_SHIFT = 14,$/;"	e	enum:ofp_flow_wildcards
OFPFW_NW_PROTO	include/openflow/openflow.hh	/^    OFPFW_NW_PROTO = 1 << 5,  \/* IP protocol. *\/$/;"	e	enum:ofp_flow_wildcards
OFPFW_NW_SRC_ALL	include/openflow/openflow.hh	/^    OFPFW_NW_SRC_ALL = 32 << OFPFW_NW_SRC_SHIFT,$/;"	e	enum:ofp_flow_wildcards
OFPFW_NW_SRC_BITS	include/openflow/openflow.hh	/^    OFPFW_NW_SRC_BITS = 6,$/;"	e	enum:ofp_flow_wildcards
OFPFW_NW_SRC_MASK	include/openflow/openflow.hh	/^    OFPFW_NW_SRC_MASK = ((1 << OFPFW_NW_SRC_BITS) - 1) << OFPFW_NW_SRC_SHIFT,$/;"	e	enum:ofp_flow_wildcards
OFPFW_NW_SRC_SHIFT	include/openflow/openflow.hh	/^    OFPFW_NW_SRC_SHIFT = 8,$/;"	e	enum:ofp_flow_wildcards
OFPFW_NW_TOS	include/openflow/openflow.hh	/^    OFPFW_NW_TOS = 1 << 21,  \/* IP ToS (DSCP field, 6 bits). *\/$/;"	e	enum:ofp_flow_wildcards
OFPFW_TP	lib/switch-flow.cc	139;"	d	file:
OFPFW_TP_DST	include/openflow/openflow.hh	/^    OFPFW_TP_DST   = 1 << 7,  \/* TCP\/UDP destination port. *\/$/;"	e	enum:ofp_flow_wildcards
OFPFW_TP_SRC	include/openflow/openflow.hh	/^    OFPFW_TP_SRC   = 1 << 6,  \/* TCP\/UDP source port. *\/$/;"	e	enum:ofp_flow_wildcards
OFPHFC_EPERM	include/openflow/openflow.hh	/^    OFPHFC_EPERM                \/* Permissions error. *\/$/;"	e	enum:ofp_hello_failed_code
OFPHFC_INCOMPATIBLE	include/openflow/openflow.hh	/^    OFPHFC_INCOMPATIBLE,        \/* No compatible version. *\/$/;"	e	enum:ofp_hello_failed_code
OFPPC_NO_FLOOD	include/openflow/openflow.hh	/^    OFPPC_NO_FLOOD     = 1 << 4,  \/* Do not include this port when flooding. *\/$/;"	e	enum:ofp_port_config
OFPPC_NO_FWD	include/openflow/openflow.hh	/^    OFPPC_NO_FWD       = 1 << 5,  \/* Drop packets forwarded to port. *\/$/;"	e	enum:ofp_port_config
OFPPC_NO_PACKET_IN	include/openflow/openflow.hh	/^    OFPPC_NO_PACKET_IN = 1 << 6   \/* Do not send packet-in msgs for port. *\/$/;"	e	enum:ofp_port_config
OFPPC_NO_RECV	include/openflow/openflow.hh	/^    OFPPC_NO_RECV      = 1 << 2,  \/* Drop all packets except 802.1D spanning$/;"	e	enum:ofp_port_config
OFPPC_NO_RECV_STP	include/openflow/openflow.hh	/^    OFPPC_NO_RECV_STP  = 1 << 3,  \/* Drop received 802.1D STP packets. *\/$/;"	e	enum:ofp_port_config
OFPPC_NO_STP	include/openflow/openflow.hh	/^    OFPPC_NO_STP       = 1 << 1,  \/* Disable 802.1D spanning tree on port. *\/$/;"	e	enum:ofp_port_config
OFPPC_PORT_DOWN	include/openflow/openflow.hh	/^    OFPPC_PORT_DOWN    = 1 << 0,  \/* Port is administratively down. *\/$/;"	e	enum:ofp_port_config
OFPPF_100MB_FD	include/openflow/openflow.hh	/^    OFPPF_100MB_FD   = 1 << 3,  \/* 100 Mb full-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_100MB_HD	include/openflow/openflow.hh	/^    OFPPF_100MB_HD   = 1 << 2,  \/* 100 Mb half-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_10GB_FD	include/openflow/openflow.hh	/^    OFPPF_10GB_FD    = 1 << 6,  \/* 10 Gb full-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_10MB_FD	include/openflow/openflow.hh	/^    OFPPF_10MB_FD    = 1 << 1,  \/* 10 Mb full-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_10MB_HD	include/openflow/openflow.hh	/^    OFPPF_10MB_HD    = 1 << 0,  \/* 10 Mb half-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_1GB_FD	include/openflow/openflow.hh	/^    OFPPF_1GB_FD     = 1 << 5,  \/* 1 Gb full-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_1GB_HD	include/openflow/openflow.hh	/^    OFPPF_1GB_HD     = 1 << 4,  \/* 1 Gb half-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_AUTONEG	include/openflow/openflow.hh	/^    OFPPF_AUTONEG    = 1 << 9,  \/* Auto-negotiation. *\/$/;"	e	enum:ofp_port_features
OFPPF_COPPER	include/openflow/openflow.hh	/^    OFPPF_COPPER     = 1 << 7,  \/* Copper medium. *\/$/;"	e	enum:ofp_port_features
OFPPF_FIBER	include/openflow/openflow.hh	/^    OFPPF_FIBER      = 1 << 8,  \/* Fiber medium. *\/$/;"	e	enum:ofp_port_features
OFPPF_PAUSE	include/openflow/openflow.hh	/^    OFPPF_PAUSE      = 1 << 10, \/* Pause. *\/$/;"	e	enum:ofp_port_features
OFPPF_PAUSE_ASYM	include/openflow/openflow.hh	/^    OFPPF_PAUSE_ASYM = 1 << 11  \/* Asymmetric pause. *\/$/;"	e	enum:ofp_port_features
OFPPMFC_BAD_HW_ADDR	include/openflow/openflow.hh	/^    OFPPMFC_BAD_HW_ADDR,         \/* Specified hardware address is wrong. *\/$/;"	e	enum:ofp_port_mod_failed_code
OFPPMFC_BAD_PORT	include/openflow/openflow.hh	/^    OFPPMFC_BAD_PORT,            \/* Specified port does not exist. *\/$/;"	e	enum:ofp_port_mod_failed_code
OFPPR_ADD	include/openflow/openflow.hh	/^    OFPPR_ADD,              \/* The port was added. *\/$/;"	e	enum:ofp_port_reason
OFPPR_DELETE	include/openflow/openflow.hh	/^    OFPPR_DELETE,           \/* The port was removed. *\/$/;"	e	enum:ofp_port_reason
OFPPR_MODIFY	include/openflow/openflow.hh	/^    OFPPR_MODIFY            \/* Some attribute of the port has changed. *\/$/;"	e	enum:ofp_port_reason
OFPPS_LINK_DOWN	include/openflow/openflow.hh	/^    OFPPS_LINK_DOWN   = 1 << 0, \/* No physical link present. *\/$/;"	e	enum:ofp_port_state
OFPPS_STP_BLOCK	include/openflow/openflow.hh	/^    OFPPS_STP_BLOCK   = 3 << 8, \/* Not part of spanning tree. *\/$/;"	e	enum:ofp_port_state
OFPPS_STP_FORWARD	include/openflow/openflow.hh	/^    OFPPS_STP_FORWARD = 2 << 8, \/* Learning and relaying frames. *\/$/;"	e	enum:ofp_port_state
OFPPS_STP_LEARN	include/openflow/openflow.hh	/^    OFPPS_STP_LEARN   = 1 << 8, \/* Learning but not relaying frames. *\/$/;"	e	enum:ofp_port_state
OFPPS_STP_LISTEN	include/openflow/openflow.hh	/^    OFPPS_STP_LISTEN  = 0 << 8, \/* Not learning or relaying frames. *\/$/;"	e	enum:ofp_port_state
OFPPS_STP_MASK	include/openflow/openflow.hh	/^    OFPPS_STP_MASK    = 3 << 8  \/* Bit mask for OFPPS_STP_* values. *\/$/;"	e	enum:ofp_port_state
OFPP_ALL	include/openflow/openflow.hh	/^    OFPP_ALL        = 0xfffc,  \/* All physical ports except input port. *\/$/;"	e	enum:ofp_port
OFPP_CONTROLLER	include/openflow/openflow.hh	/^    OFPP_CONTROLLER = 0xfffd,  \/* Send to controller. *\/$/;"	e	enum:ofp_port
OFPP_FLOOD	include/openflow/openflow.hh	/^    OFPP_FLOOD      = 0xfffb,  \/* All physical ports except input port and$/;"	e	enum:ofp_port
OFPP_IN_PORT	include/openflow/openflow.hh	/^    OFPP_IN_PORT    = 0xfff8,  \/* Send the packet out the input port.  This$/;"	e	enum:ofp_port
OFPP_LOCAL	include/openflow/openflow.hh	/^    OFPP_LOCAL      = 0xfffe,  \/* Local openflow "port". *\/$/;"	e	enum:ofp_port
OFPP_MAX	include/openflow/openflow.hh	/^    OFPP_MAX = 0xff00,$/;"	e	enum:ofp_port
OFPP_NONE	include/openflow/openflow.hh	/^    OFPP_NONE       = 0xffff   \/* Not associated with a physical port. *\/$/;"	e	enum:ofp_port
OFPP_NORMAL	include/openflow/openflow.hh	/^    OFPP_NORMAL     = 0xfffa,  \/* Process with normal L2\/L3 switching. *\/$/;"	e	enum:ofp_port
OFPP_TABLE	include/openflow/openflow.hh	/^    OFPP_TABLE      = 0xfff9,  \/* Perform actions in flow table.$/;"	e	enum:ofp_port
OFPQOFC_BAD_PORT	include/openflow/openflow.hh	/^    OFPQOFC_BAD_PORT,           \/* Invalid port (or port does not exist). *\/$/;"	e	enum:ofp_queue_op_failed_code
OFPQOFC_BAD_QUEUE	include/openflow/openflow.hh	/^    OFPQOFC_BAD_QUEUE,          \/* Queue does not exist. *\/$/;"	e	enum:ofp_queue_op_failed_code
OFPQOFC_EPERM	include/openflow/openflow.hh	/^    OFPQOFC_EPERM               \/* Permissions error. *\/$/;"	e	enum:ofp_queue_op_failed_code
OFPQT_MIN_RATE	include/openflow/openflow.hh	/^    OFPQT_MIN_RATE,       \/* Minimum datarate guaranteed. *\/$/;"	e	enum:ofp_queue_properties
OFPQT_NONE	include/openflow/openflow.hh	/^    OFPQT_NONE = 0,       \/* No property defined for queue (default). *\/$/;"	e	enum:ofp_queue_properties
OFPQ_ALL	include/openflow/openflow.hh	903;"	d
OFPQ_MIN_RATE_UNCFG	include/openflow/openflow.hh	906;"	d
OFPRR_DELETE	include/openflow/openflow.hh	/^    OFPRR_DELETE                \/* Evicted by a DELETE flow mod. *\/$/;"	e	enum:ofp_flow_removed_reason
OFPRR_HARD_TIMEOUT	include/openflow/openflow.hh	/^    OFPRR_HARD_TIMEOUT,         \/* Time exceeded hard_timeout. *\/$/;"	e	enum:ofp_flow_removed_reason
OFPRR_IDLE_TIMEOUT	include/openflow/openflow.hh	/^    OFPRR_IDLE_TIMEOUT,         \/* Flow idle time exceeded idle_timeout. *\/$/;"	e	enum:ofp_flow_removed_reason
OFPR_ACTION	include/openflow/openflow.hh	/^    OFPR_ACTION             \/* Action explicitly output to controller. *\/$/;"	e	enum:ofp_packet_in_reason
OFPR_NO_MATCH	include/openflow/openflow.hh	/^    OFPR_NO_MATCH,          \/* No matching flow. *\/$/;"	e	enum:ofp_packet_in_reason
OFPSF_REPLY_MORE	include/openflow/openflow.hh	/^    OFPSF_REPLY_MORE  = 1 << 0  \/* More replies to follow. *\/$/;"	e	enum:ofp_stats_reply_flags
OFPSTAT_H_	lib/ofpstat.hh	34;"	d
OFPST_AGGREGATE	include/openflow/openflow.hh	/^    OFPST_AGGREGATE,$/;"	e	enum:ofp_stats_types
OFPST_DESC	include/openflow/openflow.hh	/^    OFPST_DESC,$/;"	e	enum:ofp_stats_types
OFPST_FLOW	include/openflow/openflow.hh	/^    OFPST_FLOW,$/;"	e	enum:ofp_stats_types
OFPST_PORT	include/openflow/openflow.hh	/^    OFPST_PORT,$/;"	e	enum:ofp_stats_types
OFPST_QUEUE	include/openflow/openflow.hh	/^    OFPST_QUEUE,$/;"	e	enum:ofp_stats_types
OFPST_TABLE	include/openflow/openflow.hh	/^    OFPST_TABLE,$/;"	e	enum:ofp_stats_types
OFPST_VENDOR	include/openflow/openflow.hh	/^    OFPST_VENDOR = 0xffff$/;"	e	enum:ofp_stats_types
OFPT_BARRIER_REPLY	include/openflow/openflow.hh	/^    OFPT_BARRIER_REPLY,       \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_BARRIER_REQUEST	include/openflow/openflow.hh	/^    OFPT_BARRIER_REQUEST,     \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_ECHO_REPLY	include/openflow/openflow.hh	/^    OFPT_ECHO_REPLY,          \/* Symmetric message *\/$/;"	e	enum:ofp_type
OFPT_ECHO_REQUEST	include/openflow/openflow.hh	/^    OFPT_ECHO_REQUEST,        \/* Symmetric message *\/$/;"	e	enum:ofp_type
OFPT_ERROR	include/openflow/openflow.hh	/^    OFPT_ERROR,               \/* Symmetric message *\/$/;"	e	enum:ofp_type
OFPT_FEATURES_REPLY	include/openflow/openflow.hh	/^    OFPT_FEATURES_REPLY,      \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_FEATURES_REQUEST	include/openflow/openflow.hh	/^    OFPT_FEATURES_REQUEST,    \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_FLOW_MOD	include/openflow/openflow.hh	/^    OFPT_FLOW_MOD,            \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_FLOW_REMOVED	include/openflow/openflow.hh	/^    OFPT_FLOW_REMOVED,        \/* Async message *\/$/;"	e	enum:ofp_type
OFPT_GET_CONFIG_REPLY	include/openflow/openflow.hh	/^    OFPT_GET_CONFIG_REPLY,    \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_GET_CONFIG_REQUEST	include/openflow/openflow.hh	/^    OFPT_GET_CONFIG_REQUEST,  \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_HELLO	include/openflow/openflow.hh	/^    OFPT_HELLO,               \/* Symmetric message *\/$/;"	e	enum:ofp_type
OFPT_PACKET_IN	include/openflow/openflow.hh	/^    OFPT_PACKET_IN,           \/* Async message *\/$/;"	e	enum:ofp_type
OFPT_PACKET_OUT	include/openflow/openflow.hh	/^    OFPT_PACKET_OUT,          \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_PORT_MOD	include/openflow/openflow.hh	/^    OFPT_PORT_MOD,            \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_PORT_STATUS	include/openflow/openflow.hh	/^    OFPT_PORT_STATUS,         \/* Async message *\/$/;"	e	enum:ofp_type
OFPT_QUEUE_GET_CONFIG_REPLY	include/openflow/openflow.hh	/^    OFPT_QUEUE_GET_CONFIG_REPLY,    \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_QUEUE_GET_CONFIG_REQUEST	include/openflow/openflow.hh	/^    OFPT_QUEUE_GET_CONFIG_REQUEST,  \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_RATE_SHAPE	include/openflow/openflow.hh	/^    OFPT_RATE_SHAPE$/;"	e	enum:ofp_type
OFPT_SET_CONFIG	include/openflow/openflow.hh	/^    OFPT_SET_CONFIG,          \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_STATS_REPLY	include/openflow/openflow.hh	/^    OFPT_STATS_REPLY,         \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_STATS_REQUEST	include/openflow/openflow.hh	/^    OFPT_STATS_REQUEST,       \/* Controller\/switch message *\/$/;"	e	enum:ofp_type
OFPT_VENDOR	include/openflow/openflow.hh	/^    OFPT_VENDOR,              \/* Symmetric message *\/$/;"	e	enum:ofp_type
OFP_ASSERT	include/openflow/openflow.hh	51;"	d
OFP_ASSERT	include/openflow/openflow.hh	54;"	d
OFP_ASSERT	include/openflow/openflow.hh	58;"	d
OFP_DEFAULT_MISS_SEND_LEN	include/openflow/openflow.hh	165;"	d
OFP_DEFAULT_PRIORITY	include/openflow/openflow.hh	567;"	d
OFP_DL_TYPE_ETH2_CUTOFF	include/openflow/openflow.hh	524;"	d
OFP_DL_TYPE_NOT_ETH_TYPE	include/openflow/openflow.hh	529;"	d
OFP_ETH_ALEN	include/openflow/openflow.hh	82;"	d
OFP_EXT_COUNT	include/openflow/openflow-ext.hh	/^    OFP_EXT_COUNT$/;"	e	enum:ofp_extension_commands
OFP_EXT_QUEUE_DELETE	include/openflow/openflow-ext.hh	/^    OFP_EXT_QUEUE_DELETE,  \/* Remove a queue *\/$/;"	e	enum:ofp_extension_commands
OFP_EXT_QUEUE_MODIFY	include/openflow/openflow-ext.hh	/^    OFP_EXT_QUEUE_MODIFY,  \/* Add and\/or modify *\/$/;"	e	enum:ofp_extension_commands
OFP_EXT_SET_DESC	include/openflow/openflow-ext.hh	/^    OFP_EXT_SET_DESC,      \/* Set ofp_desc_stat->dp_desc *\/$/;"	e	enum:ofp_extension_commands
OFP_FLOW_PERMANENT	include/openflow/openflow.hh	564;"	d
OFP_MAX_PORT_NAME_LEN	include/openflow/openflow.hh	77;"	d
OFP_MAX_TABLE_NAME_LEN	include/openflow/openflow.hh	76;"	d
OFP_PACKED	include/openflow/openflow.hh	62;"	d
OFP_PACKED	include/openflow/openflow.hh	64;"	d
OFP_PRINT_H	lib/ofp-print.hh	37;"	d
OFP_SSL_PORT	include/openflow/openflow.hh	80;"	d
OFP_SUPPORTED_ACTIONS	datapath.cc	717;"	d	file:
OFP_SUPPORTED_CAPABILITIES	datapath.cc	710;"	d	file:
OFP_TCP_PORT	include/openflow/openflow.hh	79;"	d
OFP_VERSION	include/openflow/openflow.hh	74;"	d
OFP_VLAN_NONE	include/openflow/openflow.hh	384;"	d
OFP_VLAN_NONE	include/openflow/openflow.hh	534;"	d
OFQ_ERR_BW_UNAVAIL	include/openflow/openflow-ext.hh	/^    OFQ_ERR_BW_UNAVAIL,         \/* Bandwidth unavailable *\/$/;"	e	enum:openflow_queue_error_code
OFQ_ERR_COUNT	include/openflow/openflow-ext.hh	/^    OFQ_ERR_COUNT               \/* Last please *\/$/;"	e	enum:openflow_queue_error_code
OFQ_ERR_DISCIPLINE	include/openflow/openflow-ext.hh	/^    OFQ_ERR_DISCIPLINE,         \/* Discipline not supported *\/$/;"	e	enum:openflow_queue_error_code
OFQ_ERR_FAIL	include/openflow/openflow-ext.hh	/^    OFQ_ERR_FAIL,               \/* Unspecified failure *\/$/;"	e	enum:openflow_queue_error_code
OFQ_ERR_NONE	include/openflow/openflow-ext.hh	/^    OFQ_ERR_NONE,               \/* Success *\/$/;"	e	enum:openflow_queue_error_code
OFQ_ERR_NOT_FOUND	include/openflow/openflow-ext.hh	/^    OFQ_ERR_NOT_FOUND,          \/* Queue not found *\/$/;"	e	enum:openflow_queue_error_code
OFQ_ERR_QUEUE_UNAVAIL	include/openflow/openflow-ext.hh	/^    OFQ_ERR_QUEUE_UNAVAIL,      \/* Queue unavailable *\/$/;"	e	enum:openflow_queue_error_code
OF_EXT_MSG_H	lib/of_ext_msg.hh	35;"	d
OPENFLOW_NICIRA_EXT_H	include/openflow/nicira-ext.hh	7;"	d
OPENFLOW_OPENFLOW_EXT_H	include/openflow/openflow-ext.hh	7;"	d
OPENFLOW_OPENFLOW_H	include/openflow/openflow.hh	37;"	d
OPENFLOW_OPENFLOW_NETLINK_H	include/openflow/openflow-netlink.hh	35;"	d
OPENFLOW_PRIVATE_EXT_H_	include/openflow/private-ext.hh	34;"	d
OPENFLOW_QUEUE_ERROR_STRINGS_DEF	include/openflow/openflow-ext.hh	74;"	d
OPENFLOW_VENDOR_ID	include/openflow/openflow-ext.hh	20;"	d
OVERWRITE_SECS	datapath.hh	189;"	d
OfTime	lib/timeval.hh	/^class OfTime {$/;"	c
Of_Crc32	lib/of_crc32.hh	/^class Of_Crc32 {$/;"	c
Of_Csum	lib/csum.hh	/^class Of_Csum {$/;"	c
Of_DpAct	lib/dp_act.hh	/^class Of_DpAct {$/;"	c
Of_Hash	lib/hash.hh	/^class Of_Hash {$/;"	c
Of_LeakChecker	lib/leak-checker.hh	/^class Of_LeakChecker {$/;"	c
Of_OfExtMsg	lib/of_ext_msg.hh	/^class Of_OfExtMsg {$/;"	c
Of_OfpPrint	lib/ofp-print.hh	/^class Of_OfpPrint {$/;"	c
Of_Ofpbuf	lib/ofpbuf.hh	/^class Of_Ofpbuf {$/;"	c
Of_Ofpstat	lib/ofpstat.hh	/^class Of_Ofpstat$/;"	c
Of_Openflow	include/openflow/openflow.hh	/^class Of_Openflow{$/;"	c
Of_Pcap	lib/pcap.hh	/^class Of_Pcap {$/;"	c
Of_PollLoop	lib/poll-loop.hh	/^class Of_PollLoop {$/;"	c
Of_PrivateMsg	lib/private-msg.hh	/^class Of_PrivateMsg {$/;"	c
Of_Queue	lib/queue.hh	/^class Of_Queue {$/;"	c
Of_Random	lib/random.hh	/^class Of_Random{$/;"	c
Of_SwitchFlow	lib/switch-flow.hh	/^class Of_SwitchFlow {$/;"	c
Of_TableHash	lib/table.hh	/^class Of_TableHash {$/;"	c
Of_TableLinear	lib/table.hh	/^class Of_TableLinear {$/;"	c
PACKAGE	include/config.h	110;"	d
PACKAGE_BUGREPORT	include/config.h	113;"	d
PACKAGE_NAME	include/config.h	116;"	d
PACKAGE_STRING	include/config.h	119;"	d
PACKAGE_TARNAME	include/config.h	122;"	d
PACKAGE_VERSION	include/config.h	125;"	d
PACKED	lib/compiler.hh	39;"	d
PACKED	lib/pcap.cc	/^} PACKED;$/;"	v	typeref:struct:pcap_hdr
PACKED	lib/pcap.cc	/^} PACKED;$/;"	v	typeref:struct:pcaprec_hdr
PACKETS_H	lib/packets.hh	34;"	d
PCAP_H	lib/pcap.hh	35;"	d
PKT_BUFFER_BITS	datapath.hh	84;"	d
PKT_BUFFER_MASK	datapath.hh	86;"	d
PKT_COOKIE_BITS	datapath.hh	88;"	d
POLL_LOOP_H	lib/poll-loop.hh	50;"	d
PRINTF_FORMAT	lib/compiler.hh	40;"	d
PRINT_OFP	include/config.h	28;"	d
PRINT_OFP	include/config.h	46;"	d
PRINT_OFP_HEADER	include/config.h	36;"	d
PRINT_OFP_HEADER	include/config.h	47;"	d
PRIVATEOPT_EMERG_FLOW_PROTECTION	include/openflow/private-ext.hh	53;"	d
PRIVATEOPT_EMERG_FLOW_RESTORATION	include/openflow/private-ext.hh	54;"	d
PRIVATEOPT_PROTOCOL_STATS_REPLY	include/openflow/private-ext.hh	52;"	d
PRIVATEOPT_PROTOCOL_STATS_REQUEST	include/openflow/private-ext.hh	51;"	d
PRIVATE_MSG_H_	lib/private-msg.hh	34;"	d
PRIVATE_VENDOR_ID	include/openflow/private-ext.hh	50;"	d
PROCESS_BITS	lib/netlink.cc	974;"	d	file:
PROCESS_MASK	lib/netlink.cc	976;"	d	file:
Private	lib/ofpbuf.hh	/^    void *Private;              \/* Private pointer for use by owner. *\/$/;"	m	struct:ofpbuf
Private	lib/table.hh	/^    unsigned long Private[4];$/;"	m	struct:sw_table_position
QUEUE_H	lib/queue.hh	35;"	d
RANDOM_H	lib/random.hh	35;"	d
RCONN_H	lib/rconn.hh	35;"	d
RCONN_HH	RConn.hh	2;"	d
RCONN_REPORT_TIMER_CLOCK	RConn.hh	56;"	d
RCONN_SEND_TIMER_CLOCK	RConn.hh	55;"	d
RCONN_SYNCHRONIZED_QUEUE_HH	SynchronizedPacketQueue.hh	3;"	d
RConn	RConn.cc	/^RConn::RConn() : send_timer(this), report_timer(this)$/;"	f	class:RConn
RConn	RConn.hh	/^class RConn : public Element { public:$/;"	c
RConn_report_stat_counter	RConn.cc	/^static int RConn_report_stat_counter = 0;$/;"	v	file:
REPLY	lib/ofp-print.cc	/^    REPLY$/;"	e	enum:stats_direction	file:
REQUEST	lib/ofp-print.cc	/^    REQUEST,$/;"	e	enum:stats_direction	file:
ROUND_DOWN	lib/util.hh	73;"	d
ROUND_UP	lib/util.hh	72;"	d
SAT_MATH_H	lib/sat-math.hh	35;"	d
SERIAL_NUM_LEN	include/openflow/openflow.hh	774;"	d
SERVER	lib/vconn-ssl.cc	/^    SERVER$/;"	e	enum:session_type	file:
SIZE_MAX	include/config.h	4;"	d
SNAP_HEADER_LEN	lib/packets.hh	143;"	d
SNAP_ORG_ETHERNET	lib/packets.hh	141;"	d
SOCKET_BITS	lib/netlink.cc	971;"	d	file:
SOCKET_UTIL_H	lib/socket-util.hh	35;"	d
SOL_NETLINK	lib/netlink.cc	59;"	d	file:
STATE	lib/rconn.cc	450;"	d	file:
STATE	lib/rconn.cc	452;"	d	file:
STATE	lib/rconn.cc	64;"	d	file:
STATE	lib/rconn.cc	66;"	d	file:
STATE	lib/rconn.cc	73;"	d	file:
STATE	lib/rconn.cc	75;"	d	file:
STATE	lib/rconn.cc	882;"	d	file:
STATE	lib/rconn.cc	884;"	d	file:
STATES	lib/rconn.cc	/^    STATES$/;"	e	enum:state	file:
STATES	lib/rconn.cc	57;"	d	file:
STATE_SSL_CONNECTING	lib/vconn-ssl.cc	/^    STATE_SSL_CONNECTING$/;"	e	enum:ssl_state	file:
STATE_TCP_CONNECTING	lib/vconn-ssl.cc	/^    STATE_TCP_CONNECTING,$/;"	e	enum:ssl_state	file:
STDC_HEADERS	include/config.h	128;"	d
STP_BLOCKING	lib/stp.hh	/^    STP_BLOCKING = 1 << 4        \/* 8.4.1: Initial boot state. *\/$/;"	e	enum:stp_state
STP_CONFIG_TOPOLOGY_CHANGE	lib/stp.cc	/^    STP_CONFIG_TOPOLOGY_CHANGE = 0x01$/;"	e	enum:stp_config_bpdu_flags	file:
STP_CONFIG_TOPOLOGY_CHANGE_ACK	lib/stp.cc	/^    STP_CONFIG_TOPOLOGY_CHANGE_ACK = 0x80,$/;"	e	enum:stp_config_bpdu_flags	file:
STP_DEFAULT_BRIDGE_PRIORITY	lib/stp.hh	56;"	d
STP_DEFAULT_PORT_PRIORITY	lib/stp.hh	57;"	d
STP_DISABLED	lib/stp.hh	/^    STP_DISABLED = 1 << 0,       \/* 8.4.5: Disabled by management. *\/$/;"	e	enum:stp_state
STP_FORWARDING	lib/stp.hh	/^    STP_FORWARDING = 1 << 3,     \/* 8.4.4: Learning and relaying frames. *\/$/;"	e	enum:stp_state
STP_H	lib/stp.hh	35;"	d
STP_LEARNING	lib/stp.hh	/^    STP_LEARNING = 1 << 2,       \/* 8.4.3: Learning but not relaying frames. *\/$/;"	e	enum:stp_state
STP_LISTENING	lib/stp.hh	/^    STP_LISTENING = 1 << 1,      \/* 8.4.2: Not learning or relaying frames. *\/$/;"	e	enum:stp_state
STP_LLC_CNTL	lib/stp.hh	53;"	d
STP_LLC_DSAP	lib/stp.hh	52;"	d
STP_LLC_SSAP	lib/stp.hh	51;"	d
STP_MAX_PORTS	lib/stp.hh	64;"	d
STP_PROTOCOL_ID	lib/stp.cc	54;"	d	file:
STP_PROTOCOL_VERSION	lib/stp.cc	55;"	d	file:
STP_TYPE_CONFIG	lib/stp.cc	56;"	d	file:
STP_TYPE_TCN	lib/stp.cc	57;"	d	file:
STRFTIME_FORMAT	lib/compiler.hh	41;"	d
SVEC_EMPTY_INITIALIZER	lib/svec.hh	47;"	d
SVEC_H	lib/svec.hh	35;"	d
SWITCH_FLOW_H	lib/switch-flow.hh	35;"	d
SynchronizedPacketQueue	SynchronizedPacketQueue.hh	/^struct SynchronizedPacketQueue {$/;"	s
TABLE_H	lib/table.hh	38;"	d
TABLE_HASH_MAX_FLOWS	lib/chain.hh	51;"	d
TABLE_LINEAR_MAX_FLOWS	lib/chain.hh	50;"	d
TABLE_MAC_MAX_FLOWS	lib/chain.hh	52;"	d
TABLE_MAC_NUM_BUCKETS	lib/chain.hh	53;"	d
TCP_ACK	lib/packets.hh	244;"	d
TCP_FIN	lib/packets.hh	240;"	d
TCP_FLAGS	lib/packets.hh	247;"	d
TCP_HEADER_LEN	lib/packets.hh	250;"	d
TCP_OFFSET	lib/packets.hh	248;"	d
TCP_PSH	lib/packets.hh	243;"	d
TCP_RST	lib/packets.hh	242;"	d
TCP_SYN	lib/packets.hh	241;"	d
TCP_URG	lib/packets.hh	245;"	d
THIS_MODULE	datapath.cc	83;"	d	file:
THIS_MODULE	lib/chain.cc	42;"	d	file:
THIS_MODULE	lib/dpif.cc	56;"	d	file:
THIS_MODULE	lib/flow.cc	45;"	d	file:
THIS_MODULE	lib/leak-checker.cc	38;"	d	file:
THIS_MODULE	lib/netlink.cc	55;"	d	file:
THIS_MODULE	lib/of_ext_msg.cc	41;"	d	file:
THIS_MODULE	lib/pcap.cc	43;"	d	file:
THIS_MODULE	lib/poll-loop.cc	45;"	d	file:
THIS_MODULE	lib/rconn.cc	50;"	d	file:
THIS_MODULE	lib/socket-util.cc	55;"	d	file:
THIS_MODULE	lib/stp.cc	48;"	d	file:
THIS_MODULE	lib/svec.cc	43;"	d	file:
THIS_MODULE	lib/switch-flow.cc	46;"	d	file:
THIS_MODULE	lib/vconn-netlink.cc	57;"	d	file:
THIS_MODULE	lib/vconn-ssl.cc	62;"	d	file:
THIS_MODULE	lib/vconn-stream.cc	53;"	d	file:
THIS_MODULE	lib/vconn-tcp.cc	52;"	d	file:
THIS_MODULE	lib/vconn-unix.cc	56;"	d	file:
THIS_MODULE	lib/vconn.cc	52;"	d	file:
THIS_MODULE	lib/vlog-socket.cc	58;"	d	file:
THIS_MODULE	lib/vlog.cc	51;"	d	file:
TIMEVAL_H	lib/timeval.hh	35;"	d
TIME_MAX	lib/timeval.hh	57;"	d
TIME_MIN	lib/timeval.hh	58;"	d
TIME_UPDATE_INTERVAL	lib/timeval.hh	64;"	d
TXQ_LIMIT	RConn.hh	68;"	d
TYPE_IS_INTEGER	lib/type-props.hh	40;"	d
TYPE_IS_SIGNED	lib/type-props.hh	41;"	d
TYPE_MAXIMUM	lib/type-props.hh	46;"	d
TYPE_MINIMUM	lib/type-props.hh	43;"	d
TYPE_PROPS_H	lib/type-props.hh	35;"	d
TYPE_VALUE_BITS	lib/type-props.hh	42;"	d
UDP_HEADER_LEN	lib/packets.hh	231;"	d
UINT16_MAX	include/config.h	5;"	d
UINT32_MAX	include/config.h	6;"	d
UINT64_C	include/config.h	10;"	d
UINT64_C	include/config.h	12;"	d
UNUSED	lib/compiler.hh	38;"	d
UNUSED	lib/packets.hh	/^static const uint8_t eth_addr_broadcast[ETH_ADDR_LEN] UNUSED$/;"	v
UTIL_H	lib/util.hh	35;"	d
VCONN_H	lib/vconn.hh	35;"	d
VCONN_PROVIDER_H	lib/vconn-provider.hh	35;"	d
VCONN_SSL_H	lib/vconn-ssl.hh	34;"	d
VCONN_SSL_LONG_OPTIONS	lib/vconn-ssl.hh	46;"	d
VCONN_SSL_OPTION_HANDLERS	lib/vconn-ssl.hh	51;"	d
VCONN_STREAM_H	lib/vconn-stream.hh	35;"	d
VCS_CONNECTED	lib/vconn.cc	/^    VCS_CONNECTED,              \/* Connection established. *\/$/;"	e	enum:vconn_state	file:
VCS_CONNECTING	lib/vconn.cc	/^    VCS_CONNECTING,             \/* Underlying vconn is not connected. *\/$/;"	e	enum:vconn_state	file:
VCS_DISCONNECTED	lib/vconn.cc	/^    VCS_DISCONNECTED            \/* Connection failed or connection closed. *\/$/;"	e	enum:vconn_state	file:
VCS_RECV_HELLO	lib/vconn.cc	/^    VCS_RECV_HELLO,             \/* Waiting to receive OFPT_HELLO message. *\/$/;"	e	enum:vconn_state	file:
VCS_SEND_ERROR	lib/vconn.cc	/^    VCS_SEND_ERROR,             \/* Sending OFPT_ERROR message. *\/$/;"	e	enum:vconn_state	file:
VCS_SEND_HELLO	lib/vconn.cc	/^    VCS_SEND_HELLO,             \/* Waiting to send OFPT_HELLO message. *\/$/;"	e	enum:vconn_state	file:
VERSION	include/config.h	153;"	d
VLAN_ETH_HEADER_LEN	lib/packets.hh	169;"	d
VLAN_HEADER_LEN	lib/packets.hh	162;"	d
VLAN_PCP_BITMASK	lib/packets.hh	160;"	d
VLAN_PCP_MASK	lib/packets.hh	158;"	d
VLAN_PCP_SHIFT	lib/packets.hh	159;"	d
VLAN_VID_MASK	lib/packets.hh	157;"	d
VLF_ANY_FACILITY	lib/vlog.hh	/^    VLF_ANY_FACILITY = -1$/;"	e	enum:vlog_facility
VLF_N_FACILITIES	lib/vlog.hh	/^    VLF_N_FACILITIES,$/;"	e	enum:vlog_facility
VLL_N_LEVELS	lib/vlog.hh	/^    VLL_N_LEVELS$/;"	e	enum:vlog_level
VLM_ANY_MODULE	lib/vlog.hh	/^    VLM_ANY_MODULE = -1$/;"	e	enum:vlog_module
VLM_N_MODULES	lib/vlog.hh	/^    VLM_N_MODULES,$/;"	e	enum:vlog_module
VLOG	lib/vlog.hh	192;"	d
VLOG_DBG	lib/vlog.hh	155;"	d
VLOG_DBG_RL	lib/vlog.hh	175;"	d
VLOG_EMER	lib/vlog.hh	151;"	d
VLOG_ERR	lib/vlog.hh	152;"	d
VLOG_ERR_RL	lib/vlog.hh	172;"	d
VLOG_FACILITIES	lib/vlog.hh	/^    VLOG_FACILITIES$/;"	e	enum:vlog_facility
VLOG_FACILITIES	lib/vlog.hh	63;"	d
VLOG_FACILITY	lib/vlog.cc	83;"	d	file:
VLOG_FACILITY	lib/vlog.cc	85;"	d	file:
VLOG_FACILITY	lib/vlog.hh	68;"	d
VLOG_FACILITY	lib/vlog.hh	70;"	d
VLOG_H	lib/vlog.hh	35;"	d
VLOG_INFO	lib/vlog.hh	154;"	d
VLOG_INFO_RL	lib/vlog.hh	174;"	d
VLOG_IS_DBG_ENABLED	lib/vlog.hh	164;"	d
VLOG_IS_EMER_ENABLED	lib/vlog.hh	160;"	d
VLOG_IS_ERR_ENABLED	lib/vlog.hh	161;"	d
VLOG_IS_INFO_ENABLED	lib/vlog.hh	163;"	d
VLOG_IS_WARN_ENABLED	lib/vlog.hh	162;"	d
VLOG_LEVEL	lib/vlog.cc	57;"	d	file:
VLOG_LEVEL	lib/vlog.cc	59;"	d	file:
VLOG_LEVEL	lib/vlog.cc	64;"	d	file:
VLOG_LEVEL	lib/vlog.cc	66;"	d	file:
VLOG_LEVEL	lib/vlog.hh	53;"	d
VLOG_LEVEL	lib/vlog.hh	55;"	d
VLOG_LEVELS	lib/vlog.hh	/^    VLOG_LEVELS$/;"	e	enum:vlog_level
VLOG_LEVELS	lib/vlog.hh	46;"	d
VLOG_LONG_OPTIONS	lib/vlog.hh	179;"	d
VLOG_MODULE	lib/vlog.cc	71;"	d	file:
VLOG_MODULE	lib/vlog.cc	73;"	d	file:
VLOG_MODULE	lib/vlog.hh	80;"	d
VLOG_MSG_TOKENS	lib/vlog.hh	105;"	d
VLOG_OPTION_ENUMS	lib/vlog.hh	178;"	d
VLOG_OPTION_HANDLERS	lib/vlog.hh	182;"	d
VLOG_RATE_LIMIT_INIT	lib/vlog.hh	109;"	d
VLOG_RL	lib/vlog.hh	198;"	d
VLOG_SOCKET_H	lib/vlog-socket.hh	35;"	d
VLOG_WARN	lib/vlog.hh	153;"	d
VLOG_WARN_RL	lib/vlog.hh	173;"	d
WAIT_CONNECT	lib/vconn.hh	/^    WAIT_CONNECT,$/;"	e	enum:vconn_wait_type
WAIT_RECV	lib/vconn.hh	/^    WAIT_RECV,$/;"	e	enum:vconn_wait_type
WAIT_SEND	lib/vconn.hh	/^    WAIT_SEND$/;"	e	enum:vconn_wait_type
XTOXLL_H	lib/xtoxll.hh	34;"	d
_ALL_SOURCE	include/config.h	132;"	d
_FILE_OFFSET_BITS	include/config.h	156;"	d
_GNU_SOURCE	include/config.h	136;"	d
_POSIX_PTHREAD_SEMANTICS	include/config.h	140;"	d
_TANDEM_SOURCE	include/config.h	144;"	d
__CTRL_ATTR_MAX	lib/netlink-protocol.hh	/^        __CTRL_ATTR_MAX,$/;"	e	enum:__anon8
__CTRL_ATTR_OP_MAX	lib/netlink-protocol.hh	/^        __CTRL_ATTR_OP_MAX,$/;"	e	enum:__anon9
__CTRL_CMD_MAX	lib/netlink-protocol.hh	/^        __CTRL_CMD_MAX,$/;"	e	enum:__anon7
__DP_GENL_A_MAX	include/openflow/openflow-netlink.hh	/^	__DP_GENL_A_MAX,$/;"	e	enum:__anon3
__DP_GENL_C_MAX	include/openflow/openflow-netlink.hh	/^	__DP_GENL_C_MAX,$/;"	e	enum:dp_genl_command
__EXTENSIONS__	include/config.h	148;"	d
_buffer_idx	datapath.hh	/^	uint32_t _buffer_idx;$/;"	m	class:DatapathPacketBuffer
_buffers	datapath.hh	/^	struct dp_packet_buffer _buffers[N_PKT_BUFFERS];$/;"	m	class:DatapathPacketBuffer	typeref:struct:DatapathPacketBuffer::dp_packet_buffer
_chain	datapath.hh	/^	struct sw_chain *_chain;  \/* Forwarding rules. *\/$/;"	m	class:Datapath	typeref:struct:Datapath::sw_chain
_datapath	RConn.hh	/^	Datapath *_datapath;$/;"	m	class:RConn
_dp	datapath.hh	/^	struct datapath *_dp;$/;"	m	class:Datapath	typeref:struct:Datapath::datapath
_dp_desc	datapath.hh	/^	char _dp_desc[DESC_STR_LEN];$/;"	m	class:Datapath
_dpid	datapath.hh	/^	uint64_t _dpid;$/;"	m	class:Datapath
_flags	datapath.hh	/^	uint16_t _flags;$/;"	m	class:Datapath
_h	SynchronizedPacketQueue.hh	/^	int	_h;$/;"	m	struct:SynchronizedPacketQueue
_have_port_devname	datapath.hh	/^	bool _have_port_devname[DP_MAX_PORTS];$/;"	m	class:Datapath
_have_port_macaddr	datapath.hh	/^	bool _have_port_macaddr[DP_MAX_PORTS];$/;"	m	class:Datapath
_hw_desc	datapath.hh	/^	char _hw_desc[DESC_STR_LEN];$/;"	m	class:Datapath
_id	datapath.hh	/^	uint64_t  _id;$/;"	m	class:Datapath
_local_port	datapath.hh	/^	struct click_port *_local_port;$/;"	m	class:Datapath	typeref:struct:Datapath::click_port
_mfr_desc	datapath.hh	/^	char _mfr_desc[DESC_STR_LEN];$/;"	m	class:Datapath
_miss_send_len	datapath.hh	/^	uint16_t _miss_send_len;$/;"	m	class:Datapath
_num_queues	datapath.hh	/^	uint16_t _num_queues;$/;"	m	class:Datapath
_port_devname	datapath.hh	/^	String _port_devname[DP_MAX_PORTS];$/;"	m	class:Datapath
_port_list	datapath.hh	/^	struct list _port_list; \/* All ports, including local_port. *\/$/;"	m	class:Datapath	typeref:struct:Datapath::list
_port_macaddr	datapath.hh	/^	EtherAddress _port_macaddr[DP_MAX_PORTS];$/;"	m	class:Datapath
_ports	datapath.hh	/^	struct click_port _ports[DP_MAX_PORTS];$/;"	m	class:Datapath	typeref:struct:Datapath::click_port
_pvconn	RConn.hh	/^	struct pvconn *_pvconn;$/;"	m	class:RConn	typeref:struct:RConn::pvconn
_pvconn_name	RConn.hh	/^	char _pvconn_name[100];$/;"	m	class:RConn
_rconn	datapath.hh	/^	RConn *_rconn;$/;"	m	class:Datapath
_serial_num	datapath.hh	/^	char _serial_num[SERIAL_NUM_LEN];$/;"	m	class:Datapath
_size	SynchronizedPacketQueue.hh	/^	int	_size;$/;"	m	struct:SynchronizedPacketQueue
_storage	SynchronizedPacketQueue.hh	/^	struct buf_rconn *_storage;$/;"	m	struct:SynchronizedPacketQueue	typeref:struct:SynchronizedPacketQueue::buf_rconn
_str_local_port	datapath.hh	/^	char _str_local_port[100];$/;"	m	class:Datapath
_str_port_list	datapath.hh	/^	char _str_port_list[100];$/;"	m	class:Datapath
_sw_desc	datapath.hh	/^	char _sw_desc[DESC_STR_LEN];$/;"	m	class:Datapath
_t	SynchronizedPacketQueue.hh	/^	int	_t;$/;"	m	struct:SynchronizedPacketQueue
accept	lib/vconn-provider.hh	/^    int (*accept)(struct pvconn *pvconn, struct vconn **new_vconnp);$/;"	m	struct:pvconn_class
accept_cb	lib/vconn-stream.cc	/^    int (*accept_cb)(int fd, const struct sockaddr *, size_t sa_len,$/;"	m	struct:pstream_pvconn	file:
actions	include/openflow/openflow.hh	/^    struct ofp_action_header actions[0]; \/* Actions. *\/$/;"	m	struct:ofp_flow_stats	typeref:struct:ofp_flow_stats::ofp_action_header
actions	include/openflow/openflow.hh	/^    struct ofp_action_header actions[0]; \/* Actions. *\/$/;"	m	struct:ofp_packet_out	typeref:struct:ofp_packet_out::ofp_action_header
actions	include/openflow/openflow.hh	/^    struct ofp_action_header actions[0]; \/* The action length is inferred$/;"	m	struct:ofp_flow_mod	typeref:struct:ofp_flow_mod::ofp_action_header
actions	include/openflow/openflow.hh	/^    uint32_t actions;       \/* Bitmap of supported "ofp_action_type"s. *\/$/;"	m	struct:ofp_switch_features
actions	lib/switch-flow.hh	/^    struct ofp_action_header actions[0];$/;"	m	struct:sw_flow_actions	typeref:struct:sw_flow_actions::ofp_action_header
actions_len	include/openflow/openflow.hh	/^    uint16_t actions_len;         \/* Size of action array in bytes. *\/$/;"	m	struct:ofp_packet_out
actions_len	lib/switch-flow.hh	/^    size_t actions_len;$/;"	m	struct:sw_flow_actions
active	lib/stp.cc	/^    bool active;                 \/* Timer in use? *\/$/;"	m	struct:stp_timer	file:
active_count	include/openflow/openflow.hh	/^    uint32_t active_count;   \/* Number of active entries. *\/$/;"	m	struct:ofp_table_stats
add	lib/ofpstat.hh	/^		uint64_t add;$/;"	m	struct:ofpstat::__anon6
add_flow	datapath.cc	/^int Datapath::add_flow(struct rconn_remote *rconn_sender, uint32_t xid UNUSED, const struct ofp_flow_mod *ofm)$/;"	f	class:Datapath
add_handlers	RConn.cc	/^void RConn::add_handlers()$/;"	f	class:RConn
add_handlers	datapath.cc	/^void Datapath::add_handlers()$/;"	f	class:Datapath
add_pvconn	RConn.cc	/^void RConn::add_pvconn(struct pvconn *pvconn)$/;"	f	class:RConn
add_table	lib/chain.cc	/^static int add_table(struct sw_chain *chain, struct sw_table *table, int emerg)$/;"	f	file:
advertise	include/openflow/openflow.hh	/^    uint32_t advertise;     \/* Bitmap of "ofp_port_features"s.  Zero all$/;"	m	struct:ofp_port_mod
advertised	datapath.hh	/^	uint32_t advertised;$/;"	m	struct:click_port
advertised	include/openflow/openflow.hh	/^    uint32_t advertised;    \/* Features being advertised by the port. *\/$/;"	m	struct:ofp_phy_port
aggregate_stats_done	datapath.cc	/^static void aggregate_stats_done(void *state)$/;"	f	file:
aggregate_stats_dump	datapath.cc	/^static int aggregate_stats_dump(class Datapath *dp, void *state, struct ofpbuf *buffer)$/;"	f	file:
aggregate_stats_dump_callback	datapath.cc	/^static int aggregate_stats_dump_callback(struct sw_flow *flow, void *Private)$/;"	f	file:
aggregate_stats_init	datapath.cc	/^static int aggregate_stats_init(const void *body, int body_len UNUSED, void **state)$/;"	f	file:
aggregate_stats_state	datapath.cc	/^struct aggregate_stats_state {$/;"	s	file:
alloc_pid	lib/netlink.cc	/^alloc_pid(uint32_t *pid)$/;"	f	file:
alloc_xid	lib/vconn.cc	/^alloc_xid(void)$/;"	f	file:
allocated	lib/dynamic-string.hh	/^    size_t allocated;   \/* Bytes allocated, not including null terminator. *\/$/;"	m	struct:ds
allocated	lib/ofpbuf.hh	/^    size_t allocated;           \/* Number of bytes allocated. *\/$/;"	m	struct:ofpbuf
allocated	lib/svec.hh	/^    size_t allocated;$/;"	m	struct:svec
ar_hln	lib/packets.hh	/^    uint8_t ar_hln;            \/* Hardware address length. *\/$/;"	m	struct:arp_eth_header
ar_hrd	lib/packets.hh	/^    uint16_t ar_hrd;           \/* Hardware type. *\/$/;"	m	struct:arp_eth_header
ar_op	lib/packets.hh	/^    uint16_t ar_op;            \/* Opcode. *\/$/;"	m	struct:arp_eth_header
ar_pln	lib/packets.hh	/^    uint8_t ar_pln;            \/* Protocol address length. *\/$/;"	m	struct:arp_eth_header
ar_pro	lib/packets.hh	/^    uint16_t ar_pro;           \/* Protocol type. *\/$/;"	m	struct:arp_eth_header
ar_sha	lib/packets.hh	/^    uint8_t ar_sha[ETH_ADDR_LEN]; \/* Sender hardware address. *\/$/;"	m	struct:arp_eth_header
ar_spa	lib/packets.hh	/^    uint32_t ar_spa;           \/* Sender protocol address. *\/$/;"	m	struct:arp_eth_header
ar_tha	lib/packets.hh	/^    uint8_t ar_tha[ETH_ADDR_LEN]; \/* Target hardware address. *\/$/;"	m	struct:arp_eth_header
ar_tpa	lib/packets.hh	/^    uint32_t ar_tpa;           \/* Target protocol address. *\/$/;"	m	struct:arp_eth_header
arp_eth_header	lib/packets.hh	/^struct arp_eth_header {$/;"	s
atexit_handler	lib/fatal-signal.cc	/^atexit_handler(void)$/;"	f	file:
attr_len_range	lib/netlink.cc	/^static size_t attr_len_range[N_NL_ATTR_TYPES+1][2];\/* = {$/;"	v	file:
aux	lib/fatal-signal.cc	/^    void *aux;$/;"	m	struct:hook	file:
aux	lib/poll-loop.cc	/^    void *aux;                  \/* Argument to callback function. *\/$/;"	m	struct:poll_waiter	file:
aux	lib/stp.cc	/^    void *aux;$/;"	m	struct:stp	file:
avail_sockets	lib/netlink.cc	/^static uint32_t avail_sockets[ROUND_UP(MAX_SOCKETS, 32)];$/;"	v	file:
ba_bad_argument	lib/ofpstat.hh	/^		uint64_t ba_bad_argument;$/;"	m	struct:ofpstat::__anon5
ba_bad_len	lib/ofpstat.hh	/^		uint64_t ba_bad_len;$/;"	m	struct:ofpstat::__anon5
ba_bad_out_port	lib/ofpstat.hh	/^		uint64_t ba_bad_out_port;$/;"	m	struct:ofpstat::__anon5
ba_bad_type	lib/ofpstat.hh	/^		uint64_t ba_bad_type;$/;"	m	struct:ofpstat::__anon5
ba_bad_vendor	lib/ofpstat.hh	/^		uint64_t ba_bad_vendor;$/;"	m	struct:ofpstat::__anon5
ba_bad_vendor_type	lib/ofpstat.hh	/^		uint64_t ba_bad_vendor_type;$/;"	m	struct:ofpstat::__anon5
ba_eperm	lib/ofpstat.hh	/^		uint64_t ba_eperm;$/;"	m	struct:ofpstat::__anon5
backoff	lib/rconn.cc	/^    int backoff;$/;"	m	struct:rconn	file:
backoff_deadline	lib/rconn.cc	/^    time_t backoff_deadline;$/;"	m	struct:rconn	file:
backtrace	lib/poll-loop.cc	/^    struct backtrace *backtrace; \/* Optionally, event that created waiter. *\/$/;"	m	struct:poll_waiter	typeref:struct:poll_waiter::backtrace	file:
bad_action	lib/ofpstat.hh	/^		uint64_t bad_action;$/;"	m	struct:ofpstat::__anon4
bad_request	lib/ofpstat.hh	/^		uint64_t bad_request;$/;"	m	struct:ofpstat::__anon4
base	lib/ofpbuf.hh	/^    void *base;                 \/* First byte of area malloc()'d area. *\/$/;"	m	struct:ofpbuf
base_timer	datapath.hh	/^	Timer base_timer;$/;"	m	class:Datapath
bind_path	lib/vlog-socket.cc	/^    char *bind_path;$/;"	m	struct:vlog_client	file:
block_level	lib/fatal-signal.cc	/^static int block_level = 0;$/;"	v	file:
block_sigalrm	lib/timeval.cc	/^block_sigalrm(sigset_t *oldsigs)$/;"	f	file:
body	include/openflow/openflow-ext.hh	/^    uint8_t body[0];            \/* Body of ofp_queue objects for op. *\/$/;"	m	struct:openflow_queue_command_header
body	include/openflow/openflow.hh	/^    uint8_t body[0];            \/* Body of the reply. *\/$/;"	m	struct:ofp_stats_reply
body	include/openflow/openflow.hh	/^    uint8_t body[0];            \/* Body of the request. *\/$/;"	m	struct:ofp_stats_request
boot_time	lib/vlog.cc	/^static long long int boot_time;$/;"	v	file:
bootstrap_ca_cert	lib/vconn-ssl.cc	/^static bool bootstrap_ca_cert;$/;"	v	file:
bpdu_type	lib/stp.cc	/^    uint8_t bpdu_type;          \/* One of STP_TYPE_*. *\/$/;"	m	struct:stp_bpdu_header	file:
br_bad_stat	lib/ofpstat.hh	/^		uint64_t br_bad_stat;$/;"	m	struct:ofpstat::__anon5
br_bad_type	lib/ofpstat.hh	/^		uint64_t br_bad_type;$/;"	m	struct:ofpstat::__anon5
br_bad_vendor	lib/ofpstat.hh	/^		uint64_t br_bad_vendor;$/;"	m	struct:ofpstat::__anon5
br_bad_version	lib/ofpstat.hh	/^		uint64_t br_bad_version;$/;"	m	struct:ofpstat::__anon5
br_eperm	lib/ofpstat.hh	/^		uint64_t br_eperm;$/;"	m	struct:ofpstat::__anon5
bridge_forward_delay	lib/stp.cc	/^    int bridge_forward_delay;       \/* 8.5.3.10: forward_delay as root. *\/$/;"	m	struct:stp	file:
bridge_hello_time	lib/stp.cc	/^    int bridge_hello_time;          \/* 8.5.3.9: hello_time as root. *\/$/;"	m	struct:stp	file:
bridge_id	lib/stp.cc	/^    stp_identifier bridge_id;       \/* 8.5.3.7: This bridge. *\/$/;"	m	struct:stp	file:
bridge_id	lib/stp.cc	/^    uint64_t bridge_id;            \/* 8.5.1.3: ID of transmitting bridge. *\/$/;"	m	struct:stp_config_bpdu	file:
bridge_max_age	lib/stp.cc	/^    int bridge_max_age;             \/* 8.5.3.8: max_age when we're root. *\/$/;"	m	struct:stp	file:
bucket_mask	lib/table-hash.cc	/^	unsigned int bucket_mask; \/* Number of buckets minus 1. *\/$/;"	m	struct:sw_table_hash	file:
buckets	lib/table-hash.cc	/^	struct sw_flow **buckets;$/;"	m	struct:sw_table_hash	typeref:struct:sw_table_hash::sw_flow	file:
buf_rconn	SynchronizedPacketQueue.hh	/^struct buf_rconn {$/;"	s
buffer	datapath.cc	/^	struct ofpbuf *buffer;$/;"	m	struct:flow_stats_state	typeref:struct:flow_stats_state::ofpbuf	file:
buffer	datapath.hh	/^	struct ofpbuf *buffer;$/;"	m	struct:dp_packet_buffer	typeref:struct:dp_packet_buffer::ofpbuf
buffer_control_packet	RConn.cc	/^void RConn::buffer_control_packet( int ofpe_type UNUSED, void *msg, int length, struct rconn_remote *sender, uint32_t xid )$/;"	f	class:RConn
buffer_id	include/openflow/openflow.hh	/^    uint32_t buffer_id;           \/* Buffered packet to apply to (or -1).$/;"	m	struct:ofp_flow_mod
buffer_id	include/openflow/openflow.hh	/^    uint32_t buffer_id;           \/* ID assigned by datapath (-1 if none). *\/$/;"	m	struct:ofp_packet_out
buffer_id	include/openflow/openflow.hh	/^    uint32_t buffer_id;     \/* ID assigned by datapath. *\/$/;"	m	struct:ofp_packet_in
burst	lib/vlog.hh	/^    unsigned int burst;         \/* Max cumulative tokens credit. *\/$/;"	m	struct:vlog_rate_limit
byte_count	include/openflow/nicira-ext.hh	/^    uint64_t byte_count;$/;"	m	struct:nx_flow_end
byte_count	include/openflow/openflow.hh	/^    uint64_t byte_count;      \/* Number of bytes in flow. *\/$/;"	m	struct:ofp_flow_stats
byte_count	include/openflow/openflow.hh	/^    uint64_t byte_count;      \/* Number of bytes in flows. *\/$/;"	m	struct:ofp_aggregate_stats_reply
byte_count	include/openflow/openflow.hh	/^    uint64_t byte_count;$/;"	m	struct:ofp_flow_removed
byte_count	lib/switch-flow.hh	/^    uint64_t byte_count;        \/* Number of bytes seen. *\/$/;"	m	struct:sw_flow
ca_cert_file	lib/vconn-ssl.cc	/^static char *ca_cert_file;$/;"	v	file:
call_hooks	lib/fatal-signal.cc	/^call_hooks(int sig_nr)$/;"	f	file:
call_sigprocmask	lib/fatal-signal.cc	/^call_sigprocmask(int how, sigset_t* new_set, sigset_t* old_set)$/;"	f	file:
can_live_reconfigure	RConn.hh	/^	bool can_live_reconfigure() const		{ return true; }$/;"	f	class:RConn
capabilities	include/openflow/openflow.hh	/^    uint32_t capabilities;  \/* Bitmap of support "ofp_capabilities". *\/$/;"	m	struct:ofp_switch_features
cb_aux	RConn.hh	/^        void *cb_aux;$/;"	m	struct:rconn_remote
cb_done	RConn.hh	/^        void (*cb_done)(void *aux);$/;"	m	struct:rconn_remote
cb_dump	RConn.hh	/^        int (*cb_dump)(class RConn *, void *aux);$/;"	m	struct:rconn_remote
chain_create	lib/chain.cc	/^struct sw_chain *chain_create(class Datapath *dp)$/;"	f
chain_delete	lib/chain.cc	/^int chain_delete(struct sw_chain *chain, const struct sw_flow_key *key,$/;"	f
chain_destroy	lib/chain.cc	/^void chain_destroy(struct sw_chain *chain)$/;"	f
chain_has_conflict	lib/chain.cc	/^int chain_has_conflict(struct sw_chain *chain, const struct sw_flow_key *key,$/;"	f
chain_insert	lib/chain.cc	/^int chain_insert(struct sw_chain *chain, struct sw_flow *flow, int emerg)$/;"	f
chain_lookup	lib/chain.cc	/^struct sw_flow * chain_lookup(struct sw_chain *chain, const struct sw_flow_key *key, int emerg)$/;"	f
chain_modify	lib/chain.cc	/^int chain_modify(struct sw_chain *chain, const struct sw_flow_key *key,$/;"	f
chain_timeout	lib/chain.cc	/^void chain_timeout(struct sw_chain *chain, struct list *deleted)$/;"	f
change_detection_enabled	lib/stp.cc	/^    bool change_detection_enabled;  \/* 8.5.5.10: Detect topology changes? *\/$/;"	m	struct:stp_port	file:
check_connection_completion	lib/socket-util.cc	/^check_connection_completion(int fd) $/;"	f
check_message_type	lib/vconn.cc	/^check_message_type(uint8_t got_type, uint8_t want_type) $/;"	f	file:
check_ofp_message	lib/vconn.cc	/^check_ofp_message(const struct ofp_header *msg, uint8_t type, size_t size)$/;"	f
check_ofp_message_array	lib/vconn.cc	/^check_ofp_message_array(const struct ofp_header *msg, uint8_t type,$/;"	f
check_queue	lib/queue.cc	/^check_queue(struct ofp_queue *q UNUSED)$/;"	f	file:
check_vconn_classes	lib/vconn.cc	/^check_vconn_classes(void)$/;"	f	file:
clamp	lib/stp.cc	/^clamp(int x, int min, int max)$/;"	f	file:
class_id	datapath.hh	/^	uint16_t class_id; \/* internal mapping from OF queue_id to tc class_id *\/$/;"	m	struct:sw_queue
class_name	RConn.hh	/^	const char *class_name() const		{ return "RConn"; }$/;"	f	class:RConn
class_name	datapath.hh	/^	const char *class_name() const		{ return "Datapath"; }$/;"	f	class:Datapath
cleanup	RConn.cc	/^void RConn::cleanup(CleanupStage stage UNUSED)$/;"	f	class:RConn
cleanup	datapath.cc	/^void Datapath::cleanup(CleanupStage stage UNUSED)$/;"	f	class:Datapath
click_port	datapath.hh	/^struct click_port {$/;"	s
click_port_num	datapath.hh	/^	int click_port_num;$/;"	m	struct:click_port
close	lib/vconn-provider.hh	/^    void (*close)(struct pvconn *pvconn);$/;"	m	struct:pvconn_class
close	lib/vconn-provider.hh	/^    void (*close)(struct vconn *vconn);$/;"	m	struct:vconn_class
cmd	lib/netlink-protocol.hh	/^    uint8_t cmd;$/;"	m	struct:genlmsghdr
code	include/openflow/openflow.hh	/^    uint16_t code;$/;"	m	struct:ofp_error_msg
code	lib/ofp-print.cc	/^    int code;$/;"	m	struct:error_type	file:
collisions	include/openflow/openflow.hh	/^    uint64_t collisions;     \/* Number of collisions. *\/$/;"	m	struct:ofp_port_stats
command	include/openflow/nicira-ext.hh	/^    uint8_t command;        \/* One of NXSC_*. *\/$/;"	m	struct:nx_snat_config
command	include/openflow/openflow.hh	/^    uint16_t command;             \/* One of OFPFC_*. *\/$/;"	m	struct:ofp_flow_mod
compare_ports	lib/ofp-print.cc	/^compare_ports(const void *a_, const void *b_)$/;"	f	file:
compare_strings	lib/svec.cc	/^compare_strings(const void *a_, const void *b_)$/;"	f	file:
config	datapath.hh	/^	uint32_t config;            \/* Some subset of OFPPC_* flags. *\/$/;"	m	struct:click_port
config	include/openflow/openflow.hh	/^    uint32_t config;        \/* Bitmap of OFPPC_* flags. *\/$/;"	m	struct:ofp_phy_port
config	include/openflow/openflow.hh	/^    uint32_t config;        \/* Bitmap of OFPPC_* flags. *\/$/;"	m	struct:ofp_port_mod
config_pending	lib/stp.cc	/^    bool config_pending;            \/* 8.5.5.9: Send BPDU when hold expires? *\/$/;"	m	struct:stp_port	file:
configure	RConn.cc	/^int RConn::configure(Vector<String> &, ErrorHandler *)$/;"	f	class:RConn
configure	datapath.cc	/^int Datapath::configure(Vector<String> &conf, ErrorHandler* errh)$/;"	f	class:Datapath
connect	lib/vconn-provider.hh	/^    int (*connect)(struct vconn *vconn);$/;"	m	struct:vconn_class
connect_error	lib/vconn-ssl.cc	/^    int connect_error;$/;"	m	struct:ssl_vconn	file:
connect_path	lib/vlog-socket.cc	/^    char *connect_path;$/;"	m	struct:vlog_client	file:
cookie	datapath.hh	/^	uint32_t cookie;$/;"	m	struct:dp_packet_buffer
cookie	include/openflow/nicira-ext.hh	/^    uint64_t cookie;          \/* Opaque controller-issued identifier. *\/$/;"	m	struct:nx_flow_end
cookie	include/openflow/openflow.hh	/^    uint64_t cookie;             \/* Opaque controller-issued identifier. *\/$/;"	m	struct:ofp_flow_mod
cookie	include/openflow/openflow.hh	/^    uint64_t cookie;          \/* Opaque controller-issued identifier. *\/$/;"	m	struct:ofp_flow_removed
cookie	include/openflow/openflow.hh	/^    uint64_t cookie;          \/* Opaque controller-issued identifier. *\/$/;"	m	struct:ofp_flow_stats
cookie	lib/switch-flow.hh	/^    uint64_t cookie;            \/* Opaque controller-issued identifier. *\/$/;"	m	struct:sw_flow
copy_to_monitor	lib/rconn.cc	/^static void copy_to_monitor(struct rconn *rc, const struct ofpbuf *b)$/;"	f	file:
crc32	lib/of_crc32.hh	/^struct crc32 {$/;"	s
crc32	lib/table-hash.cc	/^	struct crc32 crc32;$/;"	m	struct:sw_table_hash	typeref:struct:sw_table_hash::crc32	file:
crc32_calculate	lib/of_crc32.cc	/^crc32_calculate(const struct crc32 *crc, const void *data_, size_t n_bytes)$/;"	f
crc32_init	lib/of_crc32.cc	/^crc32_init(struct crc32 *crc, unsigned int polynomial)$/;"	f
create_thread_nox_commun	RConn.cc	/^void RConn::create_thread_nox_commun()$/;"	f	class:RConn
created	lib/switch-flow.hh	/^    uint64_t created;           \/* When the flow was created. *\/$/;"	m	struct:sw_flow
creation_time	lib/rconn.cc	/^    time_t creation_time;$/;"	m	struct:rconn	file:
csum	lib/csum.cc	/^csum(const void *data, size_t n)$/;"	f
csum_add16	lib/csum.cc	/^csum_add16(uint32_t partial, uint16_t New)$/;"	f
csum_add32	lib/csum.cc	/^csum_add32(uint32_t partial, uint32_t New)$/;"	f
csum_continue	lib/csum.cc	/^csum_continue(uint32_t partial, const void *data_, size_t n)$/;"	f
csum_finish	lib/csum.cc	/^csum_finish(uint32_t partial)$/;"	f
ctx	lib/vconn-ssl.cc	/^static SSL_CTX *ctx;$/;"	v	file:
curr	datapath.hh	/^	uint32_t curr;$/;"	m	struct:click_port
curr	include/openflow/openflow.hh	/^    uint32_t curr;          \/* Current features. *\/$/;"	m	struct:ofp_phy_port
d	lib/dp_act.hh	/^	int d;$/;"	m	class:Of_DpAct
d	lib/of_ext_msg.hh	/^	int d;$/;"	m	class:Of_OfExtMsg
data	include/openflow/openflow.hh	/^    uint8_t data[0];          \/* Variable-length data.  Interpreted based$/;"	m	struct:ofp_error_msg
data	include/openflow/openflow.hh	/^    uint8_t data[0];        \/* Ethernet frame, halfway through 32-bit word,$/;"	m	struct:ofp_packet_in
data	lib/ofpbuf.hh	/^    void *data;                 \/* First byte actually in use. *\/$/;"	m	struct:ofpbuf
datapath	datapath.hh	/^	class Datapath *datapath;$/;"	m	struct:click_port	typeref:class:click_port::Datapath
datapath_id	include/openflow/openflow.hh	/^    uint64_t datapath_id;   \/* Datapath unique ID.  The lower 48-bits are for$/;"	m	struct:ofp_switch_features
deadline	lib/timeval.cc	/^static time_t deadline = TIME_MIN;$/;"	v	file:
default_pattern	lib/vlog.cc	/^    bool default_pattern;       \/* Whether current pattern is the default. *\/$/;"	m	struct:facility	file:
delete_strict	lib/ofpstat.hh	/^		uint64_t delete_strict;$/;"	m	struct:ofpstat::__anon6
desc	include/openflow/openflow.hh	/^    struct ofp_phy_port desc;$/;"	m	struct:ofp_port_status	typeref:struct:ofp_port_status::ofp_phy_port
desc_stats_dump	datapath.cc	/^static int desc_stats_dump(class Datapath *dp UNUSED, void *state UNUSED,$/;"	f	file:
designated_bridge	lib/stp.cc	/^    stp_identifier designated_bridge; \/* 8.5.5.6. *\/$/;"	m	struct:stp_port	file:
designated_cost	lib/stp.cc	/^    int designated_cost;            \/* 8.5.5.5: Path cost to root on port. *\/$/;"	m	struct:stp_port	file:
designated_port	lib/stp.cc	/^    int designated_port;            \/* 8.5.5.7: Port to send config msgs on. *\/$/;"	m	struct:stp_port	file:
designated_root	lib/stp.cc	/^    stp_identifier designated_root; \/* 8.5.3.1: Bridge believed to be root. *\/$/;"	m	struct:stp	file:
designated_root	lib/stp.cc	/^    stp_identifier designated_root; \/* 8.5.5.4. *\/$/;"	m	struct:stp_port	file:
destroy	SynchronizedPacketQueue.hh	/^inline int SynchronizedPacketQueue::destroy()$/;"	f	class:SynchronizedPacketQueue
destroy	lib/table.hh	/^    void (*destroy)(struct sw_table *table);$/;"	m	struct:sw_table
devname	datapath.hh	/^	char devname[8];$/;"	m	struct:click_port
disabled	lib/fatal-signal.cc	/^static bool disabled;$/;"	v	file:
discard_buffer	datapath.cc	/^void DatapathPacketBuffer::discard_buffer(uint32_t id)$/;"	f	class:DatapathPacketBuffer
disconnect	lib/rconn.cc	/^disconnect(struct rconn *rc, int error)$/;"	f	file:
dl_addr	include/openflow/openflow.hh	/^    uint8_t dl_addr[OFP_ETH_ALEN];  \/* Ethernet address. *\/$/;"	m	struct:ofp_action_dl_addr
dl_dst	include/openflow/openflow.hh	/^    uint8_t dl_dst[OFP_ETH_ALEN]; \/* Ethernet destination address. *\/$/;"	m	struct:ofp_match
dl_dst	lib/flow.hh	/^    uint8_t dl_dst[6];          \/* Ethernet destination address. *\/$/;"	m	struct:flow
dl_src	include/openflow/openflow.hh	/^    uint8_t dl_src[OFP_ETH_ALEN]; \/* Ethernet source address. *\/$/;"	m	struct:ofp_match
dl_src	lib/flow.hh	/^    uint8_t dl_src[6];          \/* Ethernet source address. *\/$/;"	m	struct:flow
dl_type	include/openflow/openflow.hh	/^    uint16_t dl_type;          \/* Ethernet frame type. *\/$/;"	m	struct:ofp_match
dl_type	lib/flow.hh	/^    uint16_t dl_type;           \/* Ethernet frame type. *\/$/;"	m	struct:flow
dl_vlan	include/openflow/openflow.hh	/^    uint16_t dl_vlan;          \/* Input VLAN id. *\/$/;"	m	struct:ofp_match
dl_vlan	lib/flow.hh	/^    uint16_t dl_vlan;           \/* Input VLAN id. *\/$/;"	m	struct:flow
dl_vlan_pcp	include/openflow/openflow.hh	/^    uint8_t dl_vlan_pcp;       \/* Input VLAN priority. *\/$/;"	m	struct:ofp_match
dl_vlan_pcp	lib/flow.hh	/^    uint8_t dl_vlan_pcp;        \/* Input VLAN priority. *\/$/;"	m	struct:flow
do_ca_cert_bootstrap	lib/vconn-ssl.cc	/^do_ca_cert_bootstrap(struct vconn *vconn)$/;"	f	file:
do_delete	lib/table-hash.cc	/^static void do_delete(struct sw_flow **bucket)$/;"	f	file:
do_delete	lib/table-linear.cc	/^do_delete(struct sw_flow *flow) $/;"	f	file:
do_lookup_genl_family	lib/netlink.cc	/^static int do_lookup_genl_family(const char *name) $/;"	f	file:
do_output	lib/dp_act.cc	/^do_output(class Datapath *dp, struct ofpbuf *buffer, int in_port,$/;"	f	file:
do_protection	lib/private-msg.cc	/^do_protection(class Datapath *dp)$/;"	f	file:
do_recv	lib/vconn.cc	/^do_recv(struct vconn *vconn, struct ofpbuf **msgp)$/;"	f	file:
do_send	lib/vconn.cc	/^static int do_send(struct vconn *vconn, struct ofpbuf *msg)$/;"	f	file:
do_set_pattern	lib/vlog.cc	/^do_set_pattern(enum vlog_facility facility, const char *pattern) $/;"	f	file:
do_ssl_init	lib/vconn-ssl.cc	/^do_ssl_init(void)$/;"	f	file:
do_tx_work	lib/rconn.cc	/^static void do_tx_work(struct rconn *rc)$/;"	f	file:
do_unlink_files	lib/fatal-signal.cc	/^do_unlink_files(void)$/;"	f	file:
done	datapath.cc	/^	bool done;$/;"	m	struct:stats_dump_cb	file:
done	datapath.cc	/^	void (*done)(void *state);$/;"	m	struct:stats_type	file:
dp	lib/chain.hh	/^    class Datapath *dp;$/;"	m	struct:sw_chain	typeref:class:sw_chain::Datapath
dp	lib/private-msg.cc	/^	class Datapath *dp;$/;"	m	struct:emerg_flow_context	typeref:class:emerg_flow_context::Datapath	file:
dp	lib/vconn-netlink.cc	/^    struct dpif dp;$/;"	m	struct:netlink_vconn	typeref:struct:netlink_vconn::dpif	file:
dp_add_local_port	datapath.cc	/^int Datapath::dp_add_local_port(const char *devname, uint16_t num_queues)$/;"	f	class:Datapath
dp_add_port	datapath.cc	/^int Datapath::dp_add_port(const char *devname, const uint8_t *macaddr, uint16_t num_queues, uint16_t click_port_num)$/;"	f	class:Datapath
dp_desc	include/openflow/openflow-ext.hh	/^    char dp_desc[DESC_STR_LEN];$/;"	m	struct:openflow_ext_set_dp_desc
dp_desc	include/openflow/openflow.hh	/^    char dp_desc[DESC_STR_LEN];        \/* Human readable description of datapath. *\/$/;"	m	struct:ofp_desc_stats
dp_genl_command	include/openflow/openflow-netlink.hh	/^enum dp_genl_command {$/;"	g
dp_idx	lib/vconn-netlink.cc	/^    int dp_idx;$/;"	m	struct:netlink_vconn	file:
dp_lookup_port	datapath.cc	/^struct click_port * Datapath::dp_lookup_port(uint16_t port_no)$/;"	f	class:Datapath
dp_lookup_queue	datapath.cc	/^struct sw_queue * dp_lookup_queue(struct click_port *p, uint32_t queue_id)$/;"	f
dp_output_control	datapath.cc	/^void Datapath::dp_output_control(struct ofpbuf *buffer, int in_port, size_t max_len, int reason)$/;"	f	class:Datapath
dp_output_port	datapath.cc	/^void Datapath::dp_output_port(struct ofpbuf *buffer, int in_port, int out_port, uint32_t queue_id, bool ignore_no_fwd UNUSED )$/;"	f	class:Datapath
dp_packet_buffer	datapath.hh	/^struct dp_packet_buffer {$/;"	s
dp_send_error_msg	datapath.cc	/^void Datapath::dp_send_error_msg(struct rconn_remote *rconn_sender, uint32_t xid, uint16_t type, uint16_t code, const void *data, size_t len)$/;"	f	class:Datapath
dp_send_features_reply	datapath.cc	/^void Datapath::dp_send_features_reply(struct rconn_remote *rconn_sender, uint32_t xid)$/;"	f	class:Datapath
dp_send_flow_end	datapath.cc	/^void Datapath::dp_send_flow_end(struct sw_flow *flow, enum ofp_flow_removed_reason reason)$/;"	f	class:Datapath
dp_wait	RConn.cc	/^void dp_wait(struct RConn* rconn)$/;"	f
dpif	lib/dpif.hh	/^struct dpif$/;"	s
dpif_add_dp	lib/dpif.cc	/^dpif_add_dp(struct dpif *dp, int dp_idx, const char *dp_name)$/;"	f
dpif_add_port	lib/dpif.cc	/^dpif_add_port(struct dpif *dp, int dp_idx, const char *netdev)$/;"	f
dpif_close	lib/dpif.cc	/^dpif_close(struct dpif *dp) $/;"	f
dpif_del_dp	lib/dpif.cc	/^dpif_del_dp(struct dpif *dp, int dp_idx, const char *dp_name)$/;"	f
dpif_del_port	lib/dpif.cc	/^dpif_del_port(struct dpif *dp, int dp_idx, const char *netdev)$/;"	f
dpif_get_idx	lib/dpif.cc	/^dpif_get_idx(const char *name)$/;"	f
dpif_open	lib/dpif.cc	/^dpif_open(int subscribe_dp_idx, struct dpif *dp)$/;"	f
dpif_recv_openflow	lib/dpif.cc	/^dpif_recv_openflow(struct dpif *dp, int dp_idx, struct ofpbuf **bufferp,$/;"	f
dpif_send_openflow	lib/dpif.cc	/^dpif_send_openflow(struct dpif *dp, int dp_idx, struct ofpbuf *buffer)$/;"	f
drain_fd	lib/socket-util.cc	/^drain_fd(int fd, size_t n_packets)$/;"	f
drain_rcvbuf	lib/socket-util.cc	/^drain_rcvbuf(int fd)$/;"	f
ds	lib/dynamic-string.hh	/^struct ds {$/;"	s
ds_chomp	lib/dynamic-string.cc	/^ds_chomp(struct ds *ds, int c)$/;"	f
ds_clear	lib/dynamic-string.cc	/^ds_clear(struct ds *ds) $/;"	f
ds_cstr	lib/dynamic-string.cc	/^ds_cstr(struct ds *ds)$/;"	f
ds_destroy	lib/dynamic-string.cc	/^ds_destroy(struct ds *ds)$/;"	f
ds_get_line	lib/dynamic-string.cc	/^ds_get_line(struct ds *ds, FILE *file)$/;"	f
ds_init	lib/dynamic-string.cc	/^ds_init(struct ds *ds)$/;"	f
ds_last	lib/dynamic-string.cc	/^ds_last(const struct ds *ds)$/;"	f
ds_put_buffer	lib/dynamic-string.cc	/^ds_put_buffer(struct ds *ds, const char *s, size_t n)$/;"	f
ds_put_char	lib/dynamic-string.cc	/^ds_put_char(struct ds *ds, char c)$/;"	f
ds_put_char_multiple	lib/dynamic-string.cc	/^ds_put_char_multiple(struct ds *ds, char c, size_t n)$/;"	f
ds_put_cstr	lib/dynamic-string.cc	/^ds_put_cstr(struct ds *ds, const char *s)$/;"	f
ds_put_format	lib/dynamic-string.cc	/^ds_put_format(struct ds *ds, const char *format, ...)$/;"	f
ds_put_format_valist	lib/dynamic-string.cc	/^ds_put_format_valist(struct ds *ds, const char *format, va_list args_)$/;"	f
ds_put_hex_dump	lib/dynamic-string.cc	/^ds_put_hex_dump(struct ds *ds, const void *buf_, size_t size,$/;"	f
ds_put_printable	lib/dynamic-string.cc	/^ds_put_printable(struct ds *ds, const char *s, size_t n) $/;"	f
ds_put_strftime	lib/dynamic-string.cc	/^ds_put_strftime(struct ds *ds, const char *temp, const struct tm *tm)$/;"	f
ds_put_uninit	lib/dynamic-string.cc	/^ds_put_uninit(struct ds *ds, size_t n)$/;"	f
ds_reserve	lib/dynamic-string.cc	/^ds_reserve(struct ds *ds, size_t min_length)$/;"	f
ds_truncate	lib/dynamic-string.cc	/^ds_truncate(struct ds *ds, size_t new_length)$/;"	f
dummy	include/openflow/openflow.hh	/^	int dummy;$/;"	m	class:Of_Openflow
dummy	lib/csum.hh	/^	int dummy;$/;"	m	class:Of_Csum
dummy	lib/hash.hh	/^	int dummy;$/;"	m	class:Of_Hash
dummy	lib/leak-checker.hh	/^	int dummy;$/;"	m	class:Of_LeakChecker
dummy	lib/of_crc32.hh	/^	int dummy;$/;"	m	class:Of_Crc32
dummy	lib/ofp-print.hh	/^	int dummy;$/;"	m	class:Of_OfpPrint
dummy	lib/ofpbuf.hh	/^	int dummy;$/;"	m	class:Of_Ofpbuf
dummy	lib/ofpstat.hh	/^	int dummy;$/;"	m	class:Of_Ofpstat
dummy	lib/pcap.hh	/^	int dummy;$/;"	m	class:Of_Pcap
dummy	lib/poll-loop.hh	/^	int dummy;$/;"	m	class:Of_PollLoop
dummy	lib/private-msg.hh	/^	int dummy;$/;"	m	class:Of_PrivateMsg
dummy	lib/queue.hh	/^	int dummy;$/;"	m	class:Of_Queue
dummy	lib/random.hh	/^	int dummy;$/;"	m	class:Of_Random
dummy	lib/switch-flow.hh	/^	int dummy;$/;"	m	class:Of_SwitchFlow
dummy	lib/table.hh	/^	int dummy;$/;"	m	class:Of_TableHash
dummy	lib/table.hh	/^	int dummy;$/;"	m	class:Of_TableLinear
dummy	lib/timeval.hh	/^	int dummy;$/;"	m	class:OfTime
dump	datapath.cc	/^	int (*dump)(class Datapath *dp, void *state, struct ofpbuf *buffer);$/;"	m	struct:stats_type	file:
dump_port_stats	datapath.cc	/^static void dump_port_stats(struct click_port *port, struct ofpbuf *buffer)$/;"	f	file:
dump_queue_stats	datapath.cc	/^static void dump_queue_stats(struct sw_queue *q, struct ofpbuf *buffer)$/;"	f	file:
duration_nsec	include/openflow/openflow.hh	/^    uint32_t duration_nsec;   \/* Time flow has been alive in nanoseconds beyond$/;"	m	struct:ofp_flow_stats
duration_nsec	include/openflow/openflow.hh	/^    uint32_t duration_nsec;   \/* Time flow was alive in nanoseconds beyond$/;"	m	struct:ofp_flow_removed
duration_sec	include/openflow/openflow.hh	/^    uint32_t duration_sec;    \/* Time flow has been alive in seconds. *\/$/;"	m	struct:ofp_flow_stats
duration_sec	include/openflow/openflow.hh	/^    uint32_t duration_sec;    \/* Time flow was alive in seconds. *\/$/;"	m	struct:ofp_flow_removed
elapsed_in_this_state	lib/rconn.cc	/^elapsed_in_this_state(const struct rconn *rc)$/;"	f	file:
elapsed_remainder	lib/stp.cc	/^    int elapsed_remainder;          \/* Left-over msecs from last stp_tick(). *\/$/;"	m	struct:stp	file:
emerg_flow	lib/switch-flow.hh	/^    uint8_t emerg_flow;         \/* Emergency flow indicator *\/$/;"	m	struct:sw_flow
emerg_flow_context	lib/private-msg.cc	/^struct emerg_flow_context {$/;"	s	file:
emerg_table	lib/chain.hh	/^    struct sw_table *emerg_table;$/;"	m	struct:sw_chain	typeref:struct:sw_chain::sw_table
enable	include/openflow/nicira-ext.hh	/^    uint8_t enable;           \/* Set to 1 to enable Flow End message$/;"	m	struct:nx_flow_end_config
end	lib/vconn.hh	/^    const uint8_t *pos, *end;$/;"	m	struct:flow_stats_iterator
end_time	include/openflow/nicira-ext.hh	/^    uint64_t end_time;        \/* Time flow ended in milliseconds. *\/$/;"	m	struct:nx_flow_end
error	lib/netlink-protocol.hh	/^        int error;$/;"	m	struct:nlmsgerr
error	lib/vconn-provider.hh	/^    int error;$/;"	m	struct:vconn
error_type	lib/ofp-print.cc	/^struct error_type {$/;"	s	file:
error_types	lib/ofp-print.cc	/^static const struct error_type error_types[] = {$/;"	v	typeref:struct:error_type	file:
eth_addr_equals	lib/packets.hh	/^static inline bool eth_addr_equals(const uint8_t a[ETH_ADDR_LEN],$/;"	f
eth_addr_from_uint64	lib/packets.hh	/^static inline void eth_addr_from_uint64(uint64_t x, uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_addr_is_broadcast	lib/packets.hh	/^static inline bool eth_addr_is_broadcast(const uint8_t ea[6])$/;"	f
eth_addr_is_local	lib/packets.hh	/^static inline bool eth_addr_is_local(const uint8_t ea[6]) $/;"	f
eth_addr_is_multicast	lib/packets.hh	/^static inline bool eth_addr_is_multicast(const uint8_t ea[6])$/;"	f
eth_addr_is_reserved	lib/packets.hh	/^static inline bool eth_addr_is_reserved(const uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_addr_is_zero	lib/packets.hh	/^static inline bool eth_addr_is_zero(const uint8_t ea[6]) $/;"	f
eth_addr_random	lib/packets.hh	/^static inline void eth_addr_random(uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_addr_to_uint64	lib/packets.hh	/^static inline uint64_t eth_addr_to_uint64(const uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_dst	lib/packets.hh	/^    uint8_t eth_dst[ETH_ADDR_LEN];$/;"	m	struct:eth_header
eth_header	lib/packets.hh	/^struct eth_header {$/;"	s
eth_src	lib/packets.hh	/^    uint8_t eth_src[ETH_ADDR_LEN];$/;"	m	struct:eth_header
eth_type	lib/packets.hh	/^    uint16_t eth_type;$/;"	m	struct:eth_header
events	lib/poll-loop.cc	/^    short int events;           \/* Events to wait for (POLLIN, POLLOUT). *\/$/;"	m	struct:poll_waiter	file:
execute	lib/dp_act.cc	/^    void (*execute)(struct ofpbuf *buffer,$/;"	m	struct:openflow_action	file:
execute_actions	lib/dp_act.cc	/^void execute_actions(class Datapath *dp, struct ofpbuf *buffer,$/;"	f
execute_ofpat	lib/dp_act.cc	/^execute_ofpat(struct ofpbuf *buffer, struct sw_flow_key *key, $/;"	f	file:
execute_vendor	lib/dp_act.cc	/^execute_vendor(struct ofpbuf *buffer UNUSED, const struct sw_flow_key *key UNUSED, $/;"	f	file:
facilities	lib/vlog.cc	/^static struct facility facilities[VLF_N_FACILITIES] = {$/;"	v	typeref:struct:facility	file:
facility	lib/vlog.cc	/^struct facility {$/;"	s	file:
family_policy	lib/netlink.cc	/^static struct nl_policy family_policy[CTRL_ATTR_MAX + 1]; \/* = { $/;"	v	typeref:struct:nl_policy	file:
fatal_signal_add_file_to_unlink	lib/fatal-signal.cc	/^fatal_signal_add_file_to_unlink(const char *file)$/;"	f
fatal_signal_add_hook	lib/fatal-signal.cc	/^fatal_signal_add_hook(void (*func)(void *aux), void *aux, bool run_at_exit)$/;"	f
fatal_signal_block	lib/fatal-signal.cc	/^fatal_signal_block(void)$/;"	f
fatal_signal_fork	lib/fatal-signal.cc	/^fatal_signal_fork(void)$/;"	f
fatal_signal_handler	lib/fatal-signal.cc	/^fatal_signal_handler(int sig_nr)$/;"	f
fatal_signal_remove_file_to_unlink	lib/fatal-signal.cc	/^fatal_signal_remove_file_to_unlink(const char *file)$/;"	f
fatal_signal_set	lib/fatal-signal.cc	/^static sigset_t fatal_signal_set;$/;"	v	file:
fatal_signal_unblock	lib/fatal-signal.cc	/^fatal_signal_unblock(void)$/;"	f
fatal_signals	lib/fatal-signal.cc	/^static const int fatal_signals[] = { SIGTERM, SIGINT, SIGHUP, SIGALRM };$/;"	v	file:
fd	lib/netlink.cc	/^    int fd;$/;"	m	struct:nl_sock	file:
fd	lib/poll-loop.cc	/^    int fd;                     \/* File descriptor. *\/$/;"	m	struct:poll_waiter	file:
fd	lib/vconn-ssl.cc	/^    int fd;$/;"	m	struct:pssl_pvconn	file:
fd	lib/vconn-ssl.cc	/^    int fd;$/;"	m	struct:ssl_vconn	file:
fd	lib/vconn-stream.cc	/^    int fd;$/;"	m	struct:pstream_pvconn	file:
fd	lib/vconn-stream.cc	/^    int fd;$/;"	m	struct:stream_vconn	file:
fd	lib/vlog-socket.cc	/^    int fd;$/;"	m	struct:vlog_client	file:
fd	lib/vlog-socket.cc	/^    int fd;$/;"	m	struct:vlog_server	file:
fetch_braces	lib/vlog.cc	/^fetch_braces(const char *p, const char *def, char *out, size_t out_size)$/;"	f	file:
files	lib/fatal-signal.cc	/^static char **files;$/;"	v	file:
fill_flow_stats	datapath.cc	/^static void fill_flow_stats(struct ofpbuf *buffer, struct sw_flow *flow,$/;"	f	file:
fill_port_desc	datapath.cc	/^void Datapath::fill_port_desc(struct click_port *p, struct ofp_phy_port *desc, struct ofpbuf* buffer UNUSED)$/;"	f	class:Datapath
fill_queue_desc	datapath.cc	/^static void fill_queue_desc(struct ofpbuf *buffer, struct sw_queue *q,$/;"	f	file:
final	lib/hash.cc	51;"	d	file:
find_bucket	lib/table-hash.cc	/^static struct sw_flow **find_bucket(struct sw_table *swt,$/;"	f	file:
first_changed_port	lib/stp.cc	/^    struct stp_port *first_changed_port;$/;"	m	struct:stp	typeref:struct:stp::stp_port	file:
first_dropped	lib/vlog.hh	/^    time_t first_dropped;       \/* Time first message was dropped. *\/$/;"	m	struct:vlog_rate_limit
flags	include/openflow/openflow.hh	/^    uint16_t flags;               \/* One of OFPFF_*. *\/$/;"	m	struct:ofp_flow_mod
flags	include/openflow/openflow.hh	/^    uint16_t flags;             \/* OFPC_* flags. *\/$/;"	m	struct:ofp_switch_config
flags	include/openflow/openflow.hh	/^    uint16_t flags;             \/* OFPSF_REPLY_* flags. *\/$/;"	m	struct:ofp_stats_reply
flags	include/openflow/openflow.hh	/^    uint16_t flags;             \/* OFPSF_REQ_* flags (none yet defined). *\/$/;"	m	struct:ofp_stats_request
flags	lib/stp.cc	/^    uint8_t flags;                 \/* STP_CONFIG_* flags. *\/$/;"	m	struct:stp_config_bpdu	file:
flow	lib/flow.hh	/^struct flow {$/;"	s
flow	lib/switch-flow.hh	/^    struct flow flow;           \/* Flow data (in network byte order). *\/$/;"	m	struct:sw_flow_key	typeref:struct:sw_flow_key::flow
flow_alloc	lib/switch-flow.cc	/^flow_alloc(size_t actions_len)$/;"	f
flow_compare	lib/flow.hh	/^flow_compare(const struct flow *a, const struct flow *b)$/;"	f
flow_count	include/openflow/openflow.hh	/^    uint32_t flow_count;      \/* Number of flows. *\/$/;"	m	struct:ofp_aggregate_stats_reply
flow_equal	lib/flow.hh	/^flow_equal(const struct flow *a, const struct flow *b)$/;"	f
flow_extract	lib/flow.cc	/^int flow_extract(struct ofpbuf *packet, uint16_t in_port, struct flow *flow)$/;"	f
flow_extract_match	lib/switch-flow.cc	/^flow_extract_match(struct sw_flow_key* to, const struct ofp_match* from)$/;"	f
flow_fields_match	lib/switch-flow.cc	/^flow_fields_match(const struct flow *a, const struct flow *b, uint32_t w,$/;"	f	file:
flow_fill_match	lib/flow.cc	/^void flow_fill_match(struct ofp_match *to, const struct flow *from,$/;"	f
flow_free	lib/switch-flow.cc	/^flow_free(struct sw_flow *flow)$/;"	f
flow_has_out_port	lib/switch-flow.cc	/^int flow_has_out_port(struct sw_flow *flow, uint16_t out_port)$/;"	f
flow_hash	lib/flow.hh	/^flow_hash(const struct flow *flow, uint32_t basis)$/;"	f
flow_matches_1wild	lib/switch-flow.cc	/^flow_matches_1wild(const struct sw_flow_key *a, const struct sw_flow_key *b)$/;"	f
flow_matches_2desc	lib/switch-flow.cc	/^flow_matches_2desc(const struct sw_flow_key *t, const struct sw_flow_key *d,$/;"	f
flow_matches_2wild	lib/switch-flow.cc	/^flow_matches_2wild(const struct sw_flow_key *a, const struct sw_flow_key *b)$/;"	f
flow_matches_desc	lib/switch-flow.cc	/^flow_matches_desc(const struct sw_flow_key *t, const struct sw_flow_key *d, $/;"	f
flow_mod_fail	lib/ofpstat.hh	/^		uint64_t flow_mod_fail;$/;"	m	struct:ofpstat::__anon4
flow_print	lib/flow.cc	/^void flow_print(FILE *stream, const struct flow *flow) $/;"	f
flow_replace_acts	lib/switch-flow.cc	/^void flow_replace_acts(struct sw_flow *flow, $/;"	f
flow_setup_actions	lib/switch-flow.cc	/^flow_setup_actions(struct sw_flow *                    flow,$/;"	f
flow_stats_done	datapath.cc	/^static void flow_stats_done(void *state)$/;"	f	file:
flow_stats_dump	datapath.cc	/^static int flow_stats_dump(class Datapath *dp, void *state,$/;"	f	file:
flow_stats_dump_callback	datapath.cc	/^static int flow_stats_dump_callback(struct sw_flow *flow, void *Private)$/;"	f	file:
flow_stats_first	lib/vconn.cc	/^flow_stats_first(struct flow_stats_iterator *iter,$/;"	f
flow_stats_init	datapath.cc	/^static int flow_stats_init(const void *body, int body_len UNUSED, void **state)$/;"	f	file:
flow_stats_iterator	lib/vconn.hh	/^struct flow_stats_iterator {$/;"	s
flow_stats_next	lib/vconn.cc	/^flow_stats_next(struct flow_stats_iterator *iter)$/;"	f
flow_stats_state	datapath.cc	/^struct flow_stats_state {$/;"	s	file:
flow_timeout	lib/switch-flow.cc	/^bool flow_timeout(struct sw_flow *flow)$/;"	f
flow_used	lib/switch-flow.cc	/^void flow_used(struct sw_flow *flow, struct ofpbuf *buffer)$/;"	f
flows	lib/table-linear.cc	/^    struct list flows;$/;"	m	struct:sw_table_linear	typeref:struct:sw_table_linear::list	file:
flowtable_timer	datapath.cc	/^void Datapath::flowtable_timer() $/;"	f	class:Datapath
flush_queue	lib/rconn.cc	/^flush_queue(struct rconn *rc)$/;"	f	file:
flush_working	lib/private-msg.cc	/^flush_working(class Datapath *dp)$/;"	f	file:
fmf_all_tables_full	lib/ofpstat.hh	/^		uint64_t fmf_all_tables_full;$/;"	m	struct:ofpstat::__anon5
fmf_emerg	lib/ofpstat.hh	/^		uint64_t fmf_emerg;$/;"	m	struct:ofpstat::__anon5
fmf_eperm	lib/ofpstat.hh	/^		uint64_t fmf_eperm;$/;"	m	struct:ofpstat::__anon5
fmf_overlap	lib/ofpstat.hh	/^		uint64_t fmf_overlap;$/;"	m	struct:ofpstat::__anon5
format_log_message	lib/vlog.cc	/^format_log_message(enum vlog_module module, enum vlog_level level,$/;"	f	file:
forward_delay	lib/stp.cc	/^    int forward_delay;              \/* 8.5.3.6: Delay between state changes. *\/$/;"	m	struct:stp	file:
forward_delay	lib/stp.cc	/^    uint16_t forward_delay;        \/* 8.5.1.8: State progression delay. *\/$/;"	m	struct:stp_config_bpdu	file:
forward_delay_timer	lib/stp.cc	/^    struct stp_timer forward_delay_timer; \/* 8.5.6.2: State change timer. *\/$/;"	m	struct:stp_port	typeref:struct:stp_port::stp_timer	file:
free_pid	lib/netlink.cc	/^free_pid(uint32_t pid)$/;"	f	file:
fs	datapath.hh	/^	struct func_stat fs;$/;"	m	class:Datapath	typeref:struct:Datapath::func_stat
func	lib/fatal-signal.cc	/^    void (*func)(void *aux);$/;"	m	struct:hook	file:
func_stat	datapath.hh	/^struct func_stat {$/;"	s
function	lib/poll-loop.cc	/^    poll_fd_func *function;     \/* Callback function, if any, or null. *\/$/;"	m	struct:poll_waiter	file:
fwd_control_input	datapath.cc	/^int Datapath::fwd_control_input(void *msg, int length, struct rconn_remote *rsender, uint32_t xid)$/;"	f	class:Datapath
fwd_port_input	datapath.cc	/^void Datapath::fwd_port_input(struct ofpbuf *buffer, struct click_port *p)$/;"	f	class:Datapath
g_ofpt_name	datapath.cc	/^char g_ofpt_name[100][100];$/;"	v
gen_datapath_id	datapath.cc	/^static uint64_t gen_datapath_id(void)$/;"	f	file:
genlmsghdr	lib/netlink-protocol.hh	/^struct genlmsghdr {$/;"	s
get_chain	datapath.hh	/^	struct sw_chain* get_chain() { return _chain; };$/;"	f	class:Datapath
get_dp_desc	datapath.hh	/^	char* get_dp_desc() { return _dp_desc; };$/;"	f	class:Datapath
get_id	datapath.hh	/^	uint64_t get_id() { return _id; };$/;"	f	class:Datapath
get_local_port	datapath.hh	/^	struct click_port* get_local_port() { return _local_port; };$/;"	f	class:Datapath
get_max_fds	lib/socket-util.cc	/^get_max_fds(void)$/;"	f
get_num_queues	datapath.hh	/^	uint16_t get_num_queues() { return _num_queues; };$/;"	f	class:Datapath
get_port	datapath.hh	/^	struct click_port* get_port(int i) { return i < DP_MAX_PORTS && i >= 0 ? &_ports[i] : NULL; };$/;"	f	class:Datapath
get_port_description	datapath.cc	/^void Datapath::get_port_description(struct ofp_phy_port* desc, String ifname, int fd)$/;"	f	class:Datapath
get_port_list	datapath.hh	/^	struct list* get_port_list() { return &_port_list; };$/;"	f	class:Datapath
get_rconn_stat	RConn.hh	/^	struct rconn_stat* get_rconn_stat() { return &rstat; };$/;"	f	class:RConn
get_socket_error	lib/socket-util.cc	/^get_socket_error(int fd) $/;"	f
get_unix_name_len	lib/socket-util.cc	/^get_unix_name_len(socklen_t sun_len)$/;"	f
handle_remote	RConn.cc	/^void handle_remote(class RConn *rconnElement)$/;"	f
hard_timeout	include/openflow/openflow.hh	/^    uint16_t hard_timeout;        \/* Max time before discarding (seconds). *\/$/;"	m	struct:ofp_flow_mod
hard_timeout	include/openflow/openflow.hh	/^    uint16_t hard_timeout;    \/* Number of seconds before expiration. *\/$/;"	m	struct:ofp_flow_stats
hard_timeout	lib/switch-flow.hh	/^    uint16_t hard_timeout;      \/* Hard expiration time (seconds) *\/$/;"	m	struct:sw_flow
has_ca_cert	lib/vconn-ssl.cc	/^static bool has_private_key, has_certificate, has_ca_cert;$/;"	v	file:
has_certificate	lib/vconn-ssl.cc	/^static bool has_private_key, has_certificate, has_ca_cert;$/;"	v	file:
has_conflict	lib/table.hh	/^    int (*has_conflict)(struct sw_table *table, const struct sw_flow_key *key,$/;"	m	struct:sw_table
has_private_key	lib/vconn-ssl.cc	/^static bool has_private_key, has_certificate, has_ca_cert;$/;"	v	file:
hash_bytes	lib/hash.cc	/^hash_bytes(const void *p_, size_t n, uint32_t basis)$/;"	f
hash_words	lib/hash.cc	/^hash_words(const uint32_t *p, size_t n, uint32_t basis)$/;"	f
head	lib/queue.hh	/^    struct ofpbuf *head;        \/* First queued packet, null if n == 0. *\/$/;"	m	struct:ofp_queue	typeref:struct:ofp_queue::ofpbuf
header	include/openflow/nicira-ext.hh	/^    struct nicira_header header;$/;"	m	struct:nx_act_config	typeref:struct:nx_act_config::nicira_header
header	include/openflow/nicira-ext.hh	/^    struct nicira_header header;$/;"	m	struct:nx_flow_end	typeref:struct:nx_flow_end::nicira_header
header	include/openflow/nicira-ext.hh	/^    struct nicira_header header;$/;"	m	struct:nx_flow_end_config	typeref:struct:nx_flow_end_config::nicira_header
header	include/openflow/nicira-ext.hh	/^    struct ofp_header header;$/;"	m	struct:nicira_header	typeref:struct:nicira_header::ofp_header
header	include/openflow/openflow-ext.hh	/^    struct ofp_extension_header header;$/;"	m	struct:openflow_ext_set_dp_desc	typeref:struct:openflow_ext_set_dp_desc::ofp_extension_header
header	include/openflow/openflow-ext.hh	/^    struct ofp_extension_header header;$/;"	m	struct:openflow_queue_command_header	typeref:struct:openflow_queue_command_header::ofp_extension_header
header	include/openflow/openflow-ext.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_extension_header	typeref:struct:ofp_extension_header::ofp_header
header	include/openflow/openflow.hh	/^	struct ofp_header header;$/;"	m	struct:netopen_rate_shape	typeref:struct:netopen_rate_shape::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;   \/* Type OFPT_VENDOR. *\/$/;"	m	struct:ofp_vendor_header	typeref:struct:ofp_vendor_header::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_error_msg	typeref:struct:ofp_error_msg::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_flow_mod	typeref:struct:ofp_flow_mod::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_flow_removed	typeref:struct:ofp_flow_removed::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_hello	typeref:struct:ofp_hello::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_packet_in	typeref:struct:ofp_packet_in::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_packet_out	typeref:struct:ofp_packet_out::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_port_mod	typeref:struct:ofp_port_mod::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_port_status	typeref:struct:ofp_port_status::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_queue_get_config_reply	typeref:struct:ofp_queue_get_config_reply::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_queue_get_config_request	typeref:struct:ofp_queue_get_config_request::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_stats_reply	typeref:struct:ofp_stats_reply::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_stats_request	typeref:struct:ofp_stats_request::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_switch_config	typeref:struct:ofp_switch_config::ofp_header
header	include/openflow/openflow.hh	/^    struct ofp_header header;$/;"	m	struct:ofp_switch_features	typeref:struct:ofp_switch_features::ofp_header
header	lib/stp.cc	/^    struct stp_bpdu_header header; \/* Type STP_TYPE_CONFIG. *\/$/;"	m	struct:stp_config_bpdu	typeref:struct:stp_config_bpdu::stp_bpdu_header	file:
header	lib/stp.cc	/^    struct stp_bpdu_header header; \/* Type STP_TYPE_TCN. *\/$/;"	m	struct:stp_tcn_bpdu	typeref:struct:stp_tcn_bpdu::stp_bpdu_header	file:
hello_fail	lib/ofpstat.hh	/^		uint64_t hello_fail;$/;"	m	struct:ofpstat::__anon4
hello_time	lib/stp.cc	/^    int hello_time;                 \/* 8.5.3.5: Time between sending BPDUs. *\/$/;"	m	struct:stp	file:
hello_time	lib/stp.cc	/^    uint16_t hello_time;           \/* 8.5.1.7: Time between BPDU generation. *\/$/;"	m	struct:stp_config_bpdu	file:
hello_timer	lib/stp.cc	/^    struct stp_timer hello_timer;   \/* 8.5.4.1: Hello timer. *\/$/;"	m	struct:stp	typeref:struct:stp::stp_timer	file:
hf_eperm	lib/ofpstat.hh	/^		uint64_t hf_eperm;$/;"	m	struct:ofpstat::__anon5
hf_incompat	lib/ofpstat.hh	/^		uint64_t hf_incompat;$/;"	m	struct:ofpstat::__anon5
hold_timer	lib/stp.cc	/^    struct stp_timer hold_timer;        \/* 8.5.6.3: BPDU rate limit timer. *\/$/;"	m	struct:stp_port	typeref:struct:stp_port::stp_timer	file:
hook	lib/fatal-signal.cc	/^struct hook {$/;"	s	file:
hooks	lib/fatal-signal.cc	/^static struct hook hooks[MAX_HOOKS];$/;"	v	typeref:struct:hook	file:
hostMacAddr	datapath.hh	/^	EtherAddress hostMacAddr;$/;"	m	class:Datapath
htonll	lib/xtoxll.hh	/^htonll(uint64_t n)$/;"	f
hw_addr	include/openflow/openflow.hh	/^    uint8_t hw_addr[OFP_ETH_ALEN]; \/* The hardware address is not$/;"	m	struct:ofp_port_mod
hw_addr	include/openflow/openflow.hh	/^    uint8_t hw_addr[OFP_ETH_ALEN];$/;"	m	struct:ofp_phy_port
hw_desc	include/openflow/openflow.hh	/^    char hw_desc[DESC_STR_LEN];        \/* Hardware description. *\/$/;"	m	struct:ofp_desc_stats
icmp_code	include/openflow/openflow.hh	560;"	d
icmp_code	lib/packets.hh	/^    uint8_t icmp_code;$/;"	m	struct:icmp_header
icmp_csum	lib/packets.hh	/^    uint16_t icmp_csum;$/;"	m	struct:icmp_header
icmp_header	lib/packets.hh	/^struct icmp_header {$/;"	s
icmp_type	include/openflow/openflow.hh	559;"	d
icmp_type	lib/packets.hh	/^    uint8_t icmp_type;$/;"	m	struct:icmp_header
idle_echo_xid	lib/rconn.cc	/^    uint32_t idle_echo_xid;$/;"	m	struct:rconn	file:
idle_timeout	include/openflow/nicira-ext.hh	/^    uint16_t idle_timeout;    \/* Idle time before discarding (seconds). *\/$/;"	m	struct:nx_flow_end
idle_timeout	include/openflow/openflow.hh	/^    uint16_t idle_timeout;        \/* Idle time before discarding (seconds). *\/$/;"	m	struct:ofp_flow_mod
idle_timeout	include/openflow/openflow.hh	/^    uint16_t idle_timeout;    \/* Idle timeout from original flow mod. *\/$/;"	m	struct:ofp_flow_removed
idle_timeout	include/openflow/openflow.hh	/^    uint16_t idle_timeout;    \/* Number of seconds idle before expiration. *\/$/;"	m	struct:ofp_flow_stats
idle_timeout	lib/switch-flow.hh	/^    uint16_t idle_timeout;      \/* Idle time before discarding (seconds). *\/$/;"	m	struct:sw_flow
in_port	include/openflow/openflow.hh	/^    uint16_t in_port;             \/* Packet's input port (OFPP_NONE if none). *\/$/;"	m	struct:ofp_packet_out
in_port	include/openflow/openflow.hh	/^    uint16_t in_port;          \/* Input switch port. *\/$/;"	m	struct:ofp_match
in_port	include/openflow/openflow.hh	/^    uint16_t in_port;       \/* Port on which frame was received. *\/$/;"	m	struct:ofp_packet_in
in_port	lib/flow.hh	/^    uint16_t in_port;           \/* Input switch port. *\/$/;"	m	struct:flow
inc_error_notification	lib/ofpstat.cc	/^inc_error_notification(struct ofpstat *ifps, struct ofp_header *hdr)$/;"	f	file:
inc_flow_manipulation	lib/ofpstat.cc	/^inc_flow_manipulation(struct ofpstat *ifps, struct ofp_header *hdr)$/;"	f	file:
inc_protocol_message	lib/ofpstat.cc	/^inc_protocol_message(struct ofpstat *ifps, struct ofp_header *hdr)$/;"	f	file:
incl_len	lib/pcap.cc	/^    uint32_t incl_len;       \/* number of octets of packet saved in file *\/$/;"	m	struct:pcaprec_hdr	file:
init	SynchronizedPacketQueue.hh	/^inline int SynchronizedPacketQueue::init(int size)$/;"	f	class:SynchronizedPacketQueue
init	datapath.cc	/^	int (*init)(const void *body, int body_len, void **state);$/;"	m	struct:stats_type	file:
init_attr_len_range	lib/netlink.cc	/^void init_attr_len_range()$/;"	f
init_of_actions	lib/dp_act.cc	/^void init_of_actions()$/;"	f
init_openflow_multicast_policy	lib/dpif.cc	/^void init_openflow_multicast_policy()$/;"	f
init_openflow_policy	lib/dpif.cc	/^void init_openflow_policy() $/;"	f
init_time	include/openflow/nicira-ext.hh	/^    uint64_t init_time;       \/* Time flow started in milliseconds. *\/$/;"	m	struct:nx_flow_end
inited	lib/timeval.cc	/^static bool inited;$/;"	v	file:
initialize	RConn.cc	/^int RConn::initialize(ErrorHandler*)$/;"	f	class:RConn
initialize	datapath.cc	/^int Datapath::initialize(ErrorHandler*)$/;"	f	class:Datapath
insert	lib/table.hh	/^    int (*insert)(struct sw_table *table, struct sw_flow *flow);$/;"	m	struct:sw_table
interpret_ssl_error	lib/vconn-ssl.cc	/^interpret_ssl_error(const char *function, int ret, int error,$/;"	f	file:
ip	lib/vconn-provider.hh	/^    uint32_t ip;$/;"	m	struct:vconn
ip_addr_end	include/openflow/nicira-ext.hh	/^    uint32_t ip_addr_end;$/;"	m	struct:nx_snat_config
ip_addr_start	include/openflow/nicira-ext.hh	/^    uint32_t ip_addr_start; $/;"	m	struct:nx_snat_config
ip_csum	lib/packets.hh	/^    uint16_t ip_csum;$/;"	m	struct:ip_header
ip_dst	lib/packets.hh	/^    uint32_t ip_dst;$/;"	m	struct:ip_header
ip_frag_off	lib/packets.hh	/^    uint16_t ip_frag_off;$/;"	m	struct:ip_header
ip_header	lib/packets.hh	/^struct ip_header {$/;"	s
ip_id	lib/packets.hh	/^    uint16_t ip_id;$/;"	m	struct:ip_header
ip_ihl_ver	lib/packets.hh	/^    uint8_t ip_ihl_ver;$/;"	m	struct:ip_header
ip_proto	lib/packets.hh	/^    uint8_t ip_proto;$/;"	m	struct:ip_header
ip_src	lib/packets.hh	/^    uint32_t ip_src;$/;"	m	struct:ip_header
ip_tos	include/openflow/nicira-ext.hh	/^    uint8_t ip_tos;           \/* IP TOS value. *\/$/;"	m	struct:nx_flow_end
ip_tos	lib/packets.hh	/^    uint8_t ip_tos;$/;"	m	struct:ip_header
ip_tot_len	lib/packets.hh	/^    uint16_t ip_tot_len;$/;"	m	struct:ip_header
ip_ttl	lib/packets.hh	/^    uint8_t ip_ttl;$/;"	m	struct:ip_header
is_admitted_msg	lib/rconn.cc	/^is_admitted_msg(const struct ofpbuf *b)$/;"	f	file:
is_connected_state	lib/rconn.cc	/^is_connected_state(enum state state) $/;"	f	file:
iter_flows	lib/table-linear.cc	/^    struct list iter_flows;$/;"	m	struct:sw_table_linear	typeref:struct:sw_table_linear::list	file:
iter_node	lib/switch-flow.hh	/^    struct list iter_node;$/;"	m	struct:sw_flow	typeref:struct:sw_flow::list
iterate	lib/table.hh	/^    int (*iterate)(struct sw_table *table,$/;"	m	struct:sw_table
key	lib/switch-flow.hh	/^    struct sw_flow_key key;$/;"	m	struct:sw_flow	typeref:struct:sw_flow::sw_flow_key
l2	lib/ofpbuf.hh	/^    void *l2;                   \/* Link-level header. *\/$/;"	m	struct:ofpbuf
l3	lib/ofpbuf.hh	/^    void *l3;                   \/* Network-level header. *\/$/;"	m	struct:ofpbuf
l4	lib/ofpbuf.hh	/^    void *l4;                   \/* Transport-level header. *\/$/;"	m	struct:ofpbuf
l7	lib/ofpbuf.hh	/^    void *l7;                   \/* Application data. *\/$/;"	m	struct:ofpbuf
last_admitted	lib/rconn.cc	/^    time_t last_admitted;$/;"	m	struct:rconn	file:
last_connected	lib/rconn.cc	/^    time_t last_connected;$/;"	m	struct:rconn	file:
last_fill	lib/vlog.hh	/^    time_t last_fill;           \/* Last time tokens added. *\/$/;"	m	struct:vlog_rate_limit
last_questioned	lib/rconn.cc	/^    time_t last_questioned;$/;"	m	struct:rconn	file:
last_received	lib/rconn.cc	/^    time_t last_received;$/;"	m	struct:rconn	file:
leak_checker_claim	lib/leak-checker.cc	/^leak_checker_claim(const void *p UNUSED)$/;"	f
leak_checker_set_limit	lib/leak-checker.cc	/^leak_checker_set_limit(off_t max_size UNUSED)$/;"	f
leak_checker_start	lib/leak-checker.cc	/^leak_checker_start(const char *file_name UNUSED)$/;"	f
leak_checker_usage	lib/leak-checker.cc	/^leak_checker_usage(void)$/;"	f
len	include/openflow/nicira-ext.hh	/^    uint16_t len;                   \/* Length is 8. *\/$/;"	m	struct:nx_action_header
len	include/openflow/nicira-ext.hh	/^    uint16_t len;                   \/* Length is 8. *\/$/;"	m	struct:nx_action_snat
len	include/openflow/openflow.hh	/^    uint16_t len;                   \/* Length is 16. *\/$/;"	m	struct:ofp_action_dl_addr
len	include/openflow/openflow.hh	/^    uint16_t len;                   \/* Length is 8. *\/$/;"	m	struct:ofp_action_nw_addr
len	include/openflow/openflow.hh	/^    uint16_t len;                   \/* Length is 8. *\/$/;"	m	struct:ofp_action_nw_tos
len	include/openflow/openflow.hh	/^    uint16_t len;                   \/* Length is 8. *\/$/;"	m	struct:ofp_action_output
len	include/openflow/openflow.hh	/^    uint16_t len;                   \/* Length is 8. *\/$/;"	m	struct:ofp_action_tp_port
len	include/openflow/openflow.hh	/^    uint16_t len;                   \/* Length is 8. *\/$/;"	m	struct:ofp_action_vlan_pcp
len	include/openflow/openflow.hh	/^    uint16_t len;                   \/* Length is 8. *\/$/;"	m	struct:ofp_action_vlan_vid
len	include/openflow/openflow.hh	/^    uint16_t len;                   \/* Length is a multiple of 8. *\/$/;"	m	struct:ofp_action_vendor_header
len	include/openflow/openflow.hh	/^    uint16_t len;                   \/* Length of action, including this$/;"	m	struct:ofp_action_header
len	include/openflow/openflow.hh	/^    uint16_t len;             \/* Len is 16. *\/$/;"	m	struct:ofp_action_enqueue
len	include/openflow/openflow.hh	/^    uint16_t len;          \/* Length in bytes of this queue desc. *\/$/;"	m	struct:ofp_packet_queue
len	include/openflow/openflow.hh	/^    uint16_t len;         \/* Length of property, including this header. *\/$/;"	m	struct:ofp_queue_prop_header
length	SynchronizedPacketQueue.hh	/^	inline int length() { return (_h-_t)>=0?(_h - _t) : (_h-_t+_size); };$/;"	f	struct:SynchronizedPacketQueue
length	SynchronizedPacketQueue.hh	/^	int length;$/;"	m	struct:buf_rconn
length	include/openflow/openflow.hh	/^    uint16_t length;          \/* Length of this entry. *\/$/;"	m	struct:ofp_flow_stats
length	include/openflow/openflow.hh	/^    uint16_t length;    \/* Length including this ofp_header. *\/$/;"	m	struct:ofp_header
length	lib/dynamic-string.hh	/^    size_t length;      \/* Bytes used, not including null terminator. *\/$/;"	m	struct:ds
level_names	lib/vlog.cc	/^static const char *level_names[VLL_N_LEVELS] = {$/;"	v	file:
levels	lib/vlog.cc	/^static int levels[VLM_N_MODULES][VLF_N_FACILITIES];$/;"	v	file:
lib_libopenflow_a_SOURCES	lib/automake.mk	/^lib_libopenflow_a_SOURCES = \\$/;"	m
linux_fd	datapath.hh	/^	int linux_fd;$/;"	m	struct:click_port
list	lib/list.hh	/^struct list$/;"	s
list_back	lib/list.cc	/^list_back(struct list *list)$/;"	f
list_front	lib/list.cc	/^list_front(struct list *list)$/;"	f
list_init	lib/list.cc	/^list_init(struct list *list)$/;"	f
list_insert	lib/list.cc	/^list_insert(struct list *before, struct list *elem)$/;"	f
list_is_empty	lib/list.cc	/^list_is_empty(const struct list *list)$/;"	f
list_pop_back	lib/list.cc	/^list_pop_back(struct list *list)$/;"	f
list_pop_front	lib/list.cc	/^list_pop_front(struct list *list)$/;"	f
list_push_back	lib/list.cc	/^list_push_back(struct list *list, struct list *elem)$/;"	f
list_push_front	lib/list.cc	/^list_push_front(struct list *list, struct list *elem)$/;"	f
list_remove	lib/list.cc	/^list_remove(struct list *elem)$/;"	f
list_replace	lib/list.cc	/^list_replace(struct list *element, const struct list *position)$/;"	f
list_size	lib/list.cc	/^list_size(const struct list *list)$/;"	f
list_splice	lib/list.cc	/^list_splice(struct list *before, struct list *first, struct list *last)$/;"	f
listen	lib/vconn-provider.hh	/^    int (*listen)(const char *name, char *suffix, struct pvconn **pvconnp);$/;"	m	struct:pvconn_class
listeners	RConn.hh	/^        struct pvconn **listeners;$/;"	m	class:RConn	typeref:struct:RConn::pvconn
liveness	RConn.hh	/^        bool liveness;$/;"	m	struct:rnc_param
liveness	datapath.hh	/^	bool liveness;$/;"	m	struct:onc_param
llc	lib/packets.hh	/^    struct llc_header llc;$/;"	m	struct:llc_snap_header	typeref:struct:llc_snap_header::llc_header
llc_cntl	lib/packets.hh	/^    uint8_t llc_cntl;$/;"	m	struct:llc_header
llc_dsap	lib/packets.hh	/^    uint8_t llc_dsap;$/;"	m	struct:llc_header
llc_header	lib/packets.hh	/^struct llc_header {$/;"	s
llc_snap_header	lib/packets.hh	/^struct llc_snap_header {$/;"	s
llc_ssap	lib/packets.hh	/^    uint8_t llc_ssap;$/;"	m	struct:llc_header
log_ca_cert	lib/vconn-ssl.cc	/^log_ca_cert(const char *file_name, X509 *cert)$/;"	f	file:
log_file	lib/vlog.cc	/^static FILE *log_file;$/;"	v	file:
log_file_name	lib/vlog.cc	/^static char *log_file_name;$/;"	v	file:
log_nlmsg	lib/netlink.cc	/^log_nlmsg(const char *function, int error,$/;"	f	file:
log_wakeup	lib/poll-loop.cc	/^log_wakeup(const struct backtrace *backtrace, const char *format, ...)$/;"	f
lookup	lib/table.hh	/^    struct sw_flow *(*lookup)(struct sw_table *table,$/;"	m	struct:sw_table	typeref:struct:sw_table::lookup
lookup_count	include/openflow/openflow.hh	/^    uint64_t lookup_count;   \/* Number of packets looked up in table. *\/$/;"	m	struct:ofp_table_stats
lookup_error_code	lib/ofp-print.cc	/^lookup_error_code(int type, int code)$/;"	f	file:
lookup_error_type	lib/ofp-print.cc	/^lookup_error_type(int type)$/;"	f	file:
lookup_ip	lib/socket-util.cc	/^lookup_ip(const char *host_name, struct in_addr *addr) $/;"	f
lookup_openflow_multicast_group	lib/dpif.cc	/^lookup_openflow_multicast_group(int dp_idx, int *multicast_group)$/;"	f	file:
mac_addr	include/openflow/nicira-ext.hh	/^    uint8_t mac_addr[OFP_ETH_ALEN];$/;"	m	struct:nx_snat_config
mac_timeout	include/openflow/nicira-ext.hh	/^    uint16_t mac_timeout;   \/* Time to cache MAC addresses of SNAT'd hosts$/;"	m	struct:nx_snat_config
macaddr	datapath.hh	/^	uint8_t macaddr[ETH_ADDR_LEN];$/;"	m	struct:click_port
magic_number	lib/pcap.cc	/^    uint32_t magic_number;   \/* magic number *\/$/;"	m	struct:pcap_hdr	file:
make_add_flow	lib/vconn.cc	/^make_add_flow(const struct flow *flow, uint32_t buffer_id,$/;"	f
make_add_simple_flow	lib/vconn.cc	/^make_add_simple_flow(const struct flow *flow,$/;"	f
make_barrier_reply	RConn.cc	/^static struct ofpbuf * make_barrier_reply(const struct ofp_header *req)$/;"	f	file:
make_buffered_packet_out	lib/vconn.cc	/^make_buffered_packet_out(uint32_t buffer_id,$/;"	f
make_del_flow	lib/vconn.cc	/^make_del_flow(const struct flow *flow)$/;"	f
make_echo_reply	lib/vconn.cc	/^make_echo_reply(const struct ofp_header *rq)$/;"	f
make_echo_request	lib/vconn.cc	/^make_echo_request(void)$/;"	f
make_flow_mod	lib/vconn.cc	/^make_flow_mod(uint16_t command, const struct flow *flow, size_t actions_len)$/;"	f
make_nw_mask	lib/switch-flow.cc	/^static uint32_t make_nw_mask(int n_wild_bits)$/;"	f	file:
make_openflow	lib/vconn.cc	/^make_openflow(size_t openflow_len, uint8_t type, struct ofpbuf **bufferp)$/;"	f
make_openflow_reply	RConn.cc	/^static void *make_openflow_reply(size_t openflow_len, uint8_t type,$/;"	f	file:
make_openflow_reply	datapath.cc	/^static void * make_openflow_reply(size_t openflow_len, uint8_t type,$/;"	f	file:
make_openflow_xid	lib/vconn.cc	/^make_openflow_xid(size_t openflow_len, uint8_t type, uint32_t xid,$/;"	f
make_sockaddr_un	lib/socket-util.cc	/^make_sockaddr_un(const char *name, struct sockaddr_un* un, socklen_t *un_len)$/;"	f	file:
make_unbuffered_packet_out	lib/vconn.cc	/^make_unbuffered_packet_out(const struct ofpbuf *packet,$/;"	f
make_unix_socket	lib/socket-util.cc	/^int make_unix_socket(int style, bool nonblock, bool passcred UNUSED,$/;"	f
mask	include/openflow/openflow.hh	/^    uint32_t mask;          \/* Bitmap of OFPPC_* flags to be changed. *\/$/;"	m	struct:ofp_port_mod
match	include/openflow/nicira-ext.hh	/^    struct ofp_match match;   \/* Description of fields. *\/$/;"	m	struct:nx_flow_end	typeref:struct:nx_flow_end::ofp_match
match	include/openflow/openflow.hh	/^    struct ofp_match match;      \/* Fields to match *\/$/;"	m	struct:ofp_flow_mod	typeref:struct:ofp_flow_mod::ofp_match
match	include/openflow/openflow.hh	/^    struct ofp_match match;   \/* Description of fields. *\/$/;"	m	struct:ofp_flow_removed	typeref:struct:ofp_flow_removed::ofp_match
match	include/openflow/openflow.hh	/^    struct ofp_match match;   \/* Description of fields. *\/$/;"	m	struct:ofp_flow_stats	typeref:struct:ofp_flow_stats::ofp_match
match	include/openflow/openflow.hh	/^    struct ofp_match match;   \/* Fields to match. *\/$/;"	m	struct:ofp_aggregate_stats_request	typeref:struct:ofp_aggregate_stats_request::ofp_match
match	include/openflow/openflow.hh	/^    struct ofp_match match;   \/* Fields to match. *\/$/;"	m	struct:ofp_flow_stats_request	typeref:struct:ofp_flow_stats_request::ofp_match
matched_count	include/openflow/openflow.hh	/^    uint64_t matched_count;  \/* Number of packets that hit table. *\/$/;"	m	struct:ofp_table_stats
max_age	lib/stp.cc	/^    int max_age;                    \/* 8.5.3.4: Time to drop received data. *\/$/;"	m	struct:stp	file:
max_age	lib/stp.cc	/^    uint16_t max_age;              \/* 8.5.1.6: Timeout for received data. *\/$/;"	m	struct:stp_config_bpdu	file:
max_backoff	lib/rconn.cc	/^    int max_backoff;$/;"	m	struct:rconn	file:
max_body	datapath.cc	/^	size_t min_body, max_body;$/;"	m	struct:stats_type	file:
max_entries	include/openflow/openflow.hh	/^    uint32_t max_entries;    \/* Max number of entries supported. *\/$/;"	m	struct:ofp_table_stats
max_files	lib/fatal-signal.cc	/^static size_t n_files, max_files;$/;"	v	file:
max_flows	lib/table-linear.cc	/^    unsigned int max_flows;$/;"	m	struct:sw_table_linear	file:
max_flows	lib/table.hh	/^    unsigned int max_flows;      \/* Flow capacity. *\/$/;"	m	struct:sw_table_stats
max_len	include/openflow/openflow.hh	/^    uint16_t max_len;               \/* Max length to send to controller. *\/$/;"	m	struct:ofp_action_output
max_len	lib/netlink.hh	/^    size_t min_len, max_len;$/;"	m	struct:nl_policy
max_size	SynchronizedPacketQueue.hh	/^	inline int max_size() const { return _size; };$/;"	f	struct:SynchronizedPacketQueue
max_size	lib/dp_act.cc	/^    size_t max_size;$/;"	m	struct:openflow_action	file:
message_age	lib/stp.cc	/^    uint16_t message_age;          \/* 8.5.1.5: Age of BPDU at tx time. *\/$/;"	m	struct:stp_config_bpdu	file:
message_age_timer	lib/stp.cc	/^    struct stp_timer message_age_timer; \/* 8.5.6.1: Age of received info. *\/$/;"	m	struct:stp_port	typeref:struct:stp_port::stp_timer	file:
mfr_desc	include/openflow/openflow.hh	/^    char mfr_desc[DESC_STR_LEN];       \/* Manufacturer description. *\/$/;"	m	struct:ofp_desc_stats
min_body	datapath.cc	/^	size_t min_body, max_body;$/;"	m	struct:stats_type	file:
min_len	lib/netlink.hh	/^    size_t min_len, max_len;$/;"	m	struct:nl_policy
min_rate	datapath.hh	/^	uint16_t min_rate;$/;"	m	struct:sw_queue
min_size	lib/dp_act.cc	/^    size_t min_size;$/;"	m	struct:openflow_action	file:
min_size	lib/ofp-print.cc	/^    size_t min_size;$/;"	m	struct:openflow_packet	file:
min_version	lib/vconn-provider.hh	/^    int min_version;$/;"	m	struct:vconn
min_vlog_levels	lib/vlog.cc	/^enum vlog_level min_vlog_levels[VLM_N_MODULES];$/;"	v	typeref:enum:vlog_level
miss_send_len	include/openflow/openflow.hh	/^    uint16_t miss_send_len;     \/* Max bytes of new flow that datapath should$/;"	m	struct:ofp_switch_config
mix	lib/hash.cc	41;"	d	file:
mod_flow	datapath.cc	/^int Datapath::mod_flow(struct rconn_remote *rconn_sender, uint32_t xid UNUSED, const struct ofp_flow_mod *ofm)$/;"	f	class:Datapath
modify	lib/ofpstat.hh	/^		uint64_t modify;$/;"	m	struct:ofpstat::__anon6
modify	lib/table.hh	/^    int (*modify)(struct sw_table *table, const struct sw_flow_key *key,$/;"	m	struct:sw_table
modify_strict	lib/ofpstat.hh	/^		uint64_t modify_strict;$/;"	m	struct:ofpstat::__anon6
modify_vlan_tci	lib/dp_act.cc	/^modify_vlan_tci(struct ofpbuf *buffer, struct sw_flow_key *key,$/;"	f	file:
module_names	lib/vlog.cc	/^static const char *module_names[VLM_N_MODULES] = { $/;"	v	file:
monitors	lib/rconn.cc	/^    struct vconn *monitors[8];$/;"	m	struct:rconn	typeref:struct:rconn::vconn	file:
ms_to_timer	lib/stp.cc	/^ms_to_timer(int ms)$/;"	f	file:
ms_to_timer_remainder	lib/stp.cc	/^ms_to_timer_remainder(int ms)$/;"	f	file:
msg	SynchronizedPacketQueue.hh	/^	void *msg;$/;"	m	struct:buf_rconn
msg	lib/netlink-protocol.hh	/^        struct nlmsghdr msg;$/;"	m	struct:nlmsgerr	typeref:struct:nlmsgerr::nlmsghdr
mutex	SynchronizedPacketQueue.hh	/^        sem_t mutex;$/;"	m	struct:SynchronizedPacketQueue
mutex_rconn	RConn.hh	/^	sem_t mutex_rconn;$/;"	m	class:RConn
n	lib/queue.hh	/^    int n;                      \/* Number of queued packets. *\/$/;"	m	struct:ofp_queue
n	lib/svec.hh	/^    size_t n;$/;"	m	struct:svec
n_attempted_connections	lib/rconn.cc	/^    unsigned int n_attempted_connections, n_successful_connections;$/;"	m	struct:rconn	file:
n_buffers	include/openflow/openflow.hh	/^    uint32_t n_buffers;     \/* Max packets buffered at once. *\/$/;"	m	struct:ofp_switch_features
n_dropped	lib/vlog.hh	/^    unsigned int n_dropped;     \/* Number of messages dropped. *\/$/;"	m	struct:vlog_rate_limit
n_files	lib/fatal-signal.cc	/^static size_t n_files, max_files;$/;"	v	file:
n_flows	lib/table-hash.cc	/^	unsigned int n_flows;$/;"	m	struct:sw_table_hash	file:
n_flows	lib/table-linear.cc	/^    unsigned int n_flows;$/;"	m	struct:sw_table_linear	file:
n_flows	lib/table.hh	/^    unsigned int n_flows;        \/* Number of active flows. *\/$/;"	m	struct:sw_table_stats
n_hooks	lib/fatal-signal.cc	/^static size_t n_hooks;$/;"	v	file:
n_listeners	RConn.hh	/^        size_t n_listeners;$/;"	m	class:RConn
n_lookup	lib/table.hh	/^    unsigned long int n_lookup;  \/* Number of packets looked up. *\/$/;"	m	struct:sw_table_stats
n_lookup	lib/table.hh	/^    unsigned long long n_lookup;$/;"	m	struct:sw_table
n_matched	lib/table.hh	/^    unsigned long int n_matched; \/* Number of packets that have hit. *\/$/;"	m	struct:sw_table_stats
n_matched	lib/table.hh	/^    unsigned long long n_matched;$/;"	m	struct:sw_table
n_monitors	lib/rconn.cc	/^    size_t n_monitors;$/;"	m	struct:rconn	file:
n_successful_connections	lib/rconn.cc	/^    unsigned int n_attempted_connections, n_successful_connections;$/;"	m	struct:rconn	file:
n_tables	include/openflow/openflow.hh	/^    uint8_t n_tables;       \/* Number of tables supported by datapath. *\/$/;"	m	struct:ofp_switch_features
n_tables	lib/chain.hh	/^    int n_tables;                \/* Number of working tables, not includes$/;"	m	struct:sw_chain
n_txq	RConn.hh	/^        int n_txq;                  \/* Number of packets queued for tx on rconn. *\/$/;"	m	struct:rconn_remote
n_unix_sockets	lib/vconn-unix.cc	/^static int n_unix_sockets;$/;"	v	file:
n_waiters	lib/poll-loop.cc	/^static size_t n_waiters;$/;"	v	file:
name	include/openflow/openflow.hh	/^    char name[OFP_MAX_PORT_NAME_LEN]; \/* Null-terminated *\/$/;"	m	struct:ofp_phy_port
name	include/openflow/openflow.hh	/^    char name[OFP_MAX_TABLE_NAME_LEN];$/;"	m	struct:ofp_table_stats
name	lib/ofp-print.cc	/^    const char *name;$/;"	m	struct:error_type	file:
name	lib/ofp-print.cc	/^    const char *name;$/;"	m	struct:openflow_packet	file:
name	lib/rconn.cc	/^    char *name;$/;"	m	struct:rconn	file:
name	lib/stp.cc	/^    char *name;                     \/* Human-readable name for log messages. *\/$/;"	m	struct:stp	file:
name	lib/table.hh	/^    const char *name;            \/* Human-readable name. *\/$/;"	m	struct:sw_table_stats
name	lib/vconn-provider.hh	/^    char *name;$/;"	m	struct:pvconn
name	lib/vconn-provider.hh	/^    char *name;$/;"	m	struct:vconn
name	lib/vconn-provider.hh	/^    const char *name;$/;"	m	struct:pvconn_class
name	lib/vconn-provider.hh	/^    const char *name;$/;"	m	struct:vconn_class
name	lib/vlog.cc	/^    const char *name;           \/* Name. *\/$/;"	m	struct:facility	file:
names	lib/svec.hh	/^    char **names;$/;"	m	struct:svec
netlink_close	lib/vconn-netlink.cc	/^netlink_close(struct vconn *vconn) $/;"	f	file:
netlink_open	lib/vconn-netlink.cc	/^netlink_open(const char *name, char *suffix, struct vconn **vconnp)$/;"	f	file:
netlink_recv	lib/vconn-netlink.cc	/^netlink_recv(struct vconn *vconn, struct ofpbuf **bufferp)$/;"	f	file:
netlink_send	lib/vconn-netlink.cc	/^netlink_send(struct vconn *vconn, struct ofpbuf *buffer) $/;"	f	file:
netlink_vconn	lib/vconn-netlink.cc	/^struct netlink_vconn$/;"	s	file:
netlink_vconn_cast	lib/vconn-netlink.cc	/^netlink_vconn_cast(struct vconn *vconn) $/;"	f	file:
netlink_vconn_class	lib/vconn-netlink.cc	/^struct vconn_class netlink_vconn_class = {$/;"	v	typeref:struct:vconn_class
netlink_wait	lib/vconn-netlink.cc	/^netlink_wait(struct vconn *vconn, enum vconn_wait_type wait) $/;"	f	file:
netopen_rate_shape	include/openflow/openflow.hh	/^struct netopen_rate_shape {$/;"	s
network	lib/pcap.cc	/^    uint32_t network;        \/* data link type *\/$/;"	m	struct:pcap_hdr	file:
new_port	datapath.cc	/^int Datapath::new_port(struct click_port *port, uint16_t port_no,$/;"	f	class:Datapath
new_pstream_pvconn	lib/vconn-stream.cc	/^new_pstream_pvconn(const char *name, int fd,$/;"	f
new_ssl_vconn	lib/vconn-ssl.cc	/^new_ssl_vconn(const char *name, int fd, enum session_type type,$/;"	f	file:
new_stream_vconn	lib/vconn-stream.cc	/^new_stream_vconn(const char *name, int fd, int connect_status,$/;"	f
new_tcp_vconn	lib/vconn-tcp.cc	/^new_tcp_vconn(const char *name, int fd, int connect_status,$/;"	f	file:
new_waiter	lib/poll-loop.cc	/^new_waiter(int fd, short int events)$/;"	f	file:
next	lib/list.hh	/^    struct list *next;     \/* Next list element. *\/$/;"	m	struct:list	typeref:struct:list::list
next	lib/ofpbuf.hh	/^    struct ofpbuf *next;        \/* Next in a list of ofpbufs. *\/$/;"	m	struct:ofpbuf	typeref:struct:ofpbuf::ofpbuf
next_seq	lib/netlink.cc	/^static uint32_t next_seq;$/;"	v	file:
next_serial	lib/table-linear.cc	/^    unsigned long int next_serial;$/;"	m	struct:sw_table_linear	file:
nicira_header	include/openflow/nicira-ext.hh	/^struct nicira_header {$/;"	s
nicira_type	include/openflow/nicira-ext.hh	/^enum nicira_type {$/;"	g
nl_attr_get	lib/netlink.cc	/^nl_attr_get(const struct nlattr *nla) $/;"	f
nl_attr_get_flag	lib/netlink.cc	/^nl_attr_get_flag(const struct nlattr *nla) $/;"	f
nl_attr_get_size	lib/netlink.cc	/^nl_attr_get_size(const struct nlattr *nla) $/;"	f
nl_attr_get_string	lib/netlink.cc	/^nl_attr_get_string(const struct nlattr *nla) $/;"	f
nl_attr_get_u16	lib/netlink.cc	/^nl_attr_get_u16(const struct nlattr *nla) $/;"	f
nl_attr_get_u32	lib/netlink.cc	/^nl_attr_get_u32(const struct nlattr *nla) $/;"	f
nl_attr_get_u64	lib/netlink.cc	/^nl_attr_get_u64(const struct nlattr *nla) $/;"	f
nl_attr_get_u8	lib/netlink.cc	/^nl_attr_get_u8(const struct nlattr *nla) $/;"	f
nl_attr_get_unspec	lib/netlink.cc	/^nl_attr_get_unspec(const struct nlattr *nla, size_t size) $/;"	f
nl_attr_type	lib/netlink.hh	/^enum nl_attr_type$/;"	g
nl_family	lib/netlink-protocol.hh	/^    sa_family_t nl_family;$/;"	m	struct:sockaddr_nl
nl_groups	lib/netlink-protocol.hh	/^    uint32_t nl_groups;$/;"	m	struct:sockaddr_nl
nl_lookup_genl_family	lib/netlink.cc	/^nl_lookup_genl_family(const char *name, int *number) $/;"	f
nl_msg_genlmsghdr	lib/netlink.cc	/^nl_msg_genlmsghdr(const struct ofpbuf *msg) $/;"	f
nl_msg_nlmsgerr	lib/netlink.cc	/^nl_msg_nlmsgerr(const struct ofpbuf *msg, int *errorp) $/;"	f
nl_msg_nlmsghdr	lib/netlink.cc	/^nl_msg_nlmsghdr(const struct ofpbuf *msg) $/;"	f
nl_msg_put	lib/netlink.cc	/^nl_msg_put(struct ofpbuf *msg, const void *data, size_t size) $/;"	f
nl_msg_put_flag	lib/netlink.cc	/^nl_msg_put_flag(struct ofpbuf *msg, uint16_t type) $/;"	f
nl_msg_put_genlmsghdr	lib/netlink.cc	/^nl_msg_put_genlmsghdr(struct ofpbuf *msg, struct nl_sock *sock,$/;"	f
nl_msg_put_nested	lib/netlink.cc	/^nl_msg_put_nested(struct ofpbuf *msg,$/;"	f
nl_msg_put_nlmsghdr	lib/netlink.cc	/^nl_msg_put_nlmsghdr(struct ofpbuf *msg, struct nl_sock *sock,$/;"	f
nl_msg_put_string	lib/netlink.cc	/^nl_msg_put_string(struct ofpbuf *msg, uint16_t type, const char *value)$/;"	f
nl_msg_put_u16	lib/netlink.cc	/^nl_msg_put_u16(struct ofpbuf *msg, uint16_t type, uint16_t value)$/;"	f
nl_msg_put_u32	lib/netlink.cc	/^nl_msg_put_u32(struct ofpbuf *msg, uint16_t type, uint32_t value)$/;"	f
nl_msg_put_u64	lib/netlink.cc	/^nl_msg_put_u64(struct ofpbuf *msg, uint16_t type, uint64_t value)$/;"	f
nl_msg_put_u8	lib/netlink.cc	/^nl_msg_put_u8(struct ofpbuf *msg, uint16_t type, uint8_t value) $/;"	f
nl_msg_put_uninit	lib/netlink.cc	/^nl_msg_put_uninit(struct ofpbuf *msg, size_t size) $/;"	f
nl_msg_put_unspec	lib/netlink.cc	/^nl_msg_put_unspec(struct ofpbuf *msg, uint16_t type,$/;"	f
nl_msg_put_unspec_uninit	lib/netlink.cc	/^nl_msg_put_unspec_uninit(struct ofpbuf *msg, uint16_t type, size_t size) $/;"	f
nl_msg_reserve	lib/netlink.cc	/^nl_msg_reserve(struct ofpbuf *msg, size_t size) $/;"	f
nl_pad	lib/netlink-protocol.hh	/^    unsigned short int nl_pad;$/;"	m	struct:sockaddr_nl
nl_pid	lib/netlink-protocol.hh	/^    uint32_t nl_pid;$/;"	m	struct:sockaddr_nl
nl_policy	lib/netlink.hh	/^struct nl_policy$/;"	s
nl_policy_parse	lib/netlink.cc	/^nl_policy_parse(const struct ofpbuf *msg, size_t nla_offset,$/;"	f
nl_sock	lib/netlink.cc	/^struct nl_sock$/;"	s	file:
nl_sock_create	lib/netlink.cc	/^nl_sock_create(int protocol, int multicast_group,$/;"	f
nl_sock_destroy	lib/netlink.cc	/^nl_sock_destroy(struct nl_sock *sock) $/;"	f
nl_sock_recv	lib/netlink.cc	/^nl_sock_recv(struct nl_sock *sock, struct ofpbuf **bufp, bool wait) $/;"	f
nl_sock_send	lib/netlink.cc	/^nl_sock_send(struct nl_sock *sock, const struct ofpbuf *msg, bool wait) $/;"	f
nl_sock_sendv	lib/netlink.cc	/^nl_sock_sendv(struct nl_sock *sock, const struct iovec iov[], size_t n_iov,$/;"	f
nl_sock_transact	lib/netlink.cc	/^nl_sock_transact(struct nl_sock *sock,$/;"	f
nl_sock_wait	lib/netlink.cc	/^nl_sock_wait(const struct nl_sock *sock, short int events)$/;"	f
nla_len	lib/netlink-protocol.hh	/^    uint16_t nla_len;$/;"	m	struct:nlattr
nla_type	lib/netlink-protocol.hh	/^    uint16_t nla_type;$/;"	m	struct:nlattr
nlattr	lib/netlink-protocol.hh	/^struct nlattr {$/;"	s
nlmsg_flags	lib/netlink-protocol.hh	/^    uint16_t nlmsg_flags;$/;"	m	struct:nlmsghdr
nlmsg_len	lib/netlink-protocol.hh	/^    uint32_t nlmsg_len;$/;"	m	struct:nlmsghdr
nlmsg_pid	lib/netlink-protocol.hh	/^    uint32_t nlmsg_pid;$/;"	m	struct:nlmsghdr
nlmsg_seq	lib/netlink-protocol.hh	/^    uint32_t nlmsg_seq;$/;"	m	struct:nlmsghdr
nlmsg_to_string	lib/netlink.cc	/^nlmsg_to_string(const struct ofpbuf *buffer)$/;"	f	file:
nlmsg_type	lib/netlink-protocol.hh	/^    uint16_t nlmsg_type;$/;"	m	struct:nlmsghdr
nlmsgerr	lib/netlink-protocol.hh	/^struct nlmsgerr$/;"	s
nlmsghdr	lib/netlink-protocol.hh	/^struct nlmsghdr {$/;"	s
nlmsghdr_to_string	lib/netlink.cc	/^nlmsghdr_to_string(const struct nlmsghdr *h, struct ds *ds)$/;"	f	file:
node	RConn.hh	/^        struct list node;$/;"	m	struct:rconn_remote	typeref:struct:rconn_remote::list
node	datapath.hh	/^	struct list node; \/* Element in datapath.ports. *\/$/;"	m	struct:click_port	typeref:struct:click_port::list
node	datapath.hh	/^	struct list node; \/* element in port.queues *\/$/;"	m	struct:sw_queue	typeref:struct:sw_queue::list
node	lib/poll-loop.cc	/^    struct list node;           \/* Element in global waiters list. *\/$/;"	m	struct:poll_waiter	typeref:struct:poll_waiter::list	file:
node	lib/switch-flow.hh	/^    struct list node;$/;"	m	struct:sw_flow	typeref:struct:sw_flow::list
nodist_lib_libopenflow_a_SOURCES	lib/automake.mk	/^nodist_lib_libopenflow_a_SOURCES = lib\/dhparams.c$/;"	m
now	datapath.cc	/^	uint64_t now;                  \/* Current time in milliseconds *\/$/;"	m	struct:flow_stats_state	file:
now	lib/timeval.cc	/^static struct timeval now;$/;"	v	typeref:struct:timeval	file:
ntohll	lib/xtoxll.hh	/^ntohll(uint64_t n)$/;"	f
num_queues	datapath.hh	/^	uint16_t num_queues;$/;"	m	struct:click_port
nw_addr	include/openflow/openflow.hh	/^    uint32_t nw_addr;               \/* IP address. *\/$/;"	m	struct:ofp_action_nw_addr
nw_dst	include/openflow/openflow.hh	/^    uint32_t nw_dst;           \/* IP destination address. *\/$/;"	m	struct:ofp_match
nw_dst	lib/flow.hh	/^    uint32_t nw_dst;            \/* IP destination address. *\/$/;"	m	struct:flow
nw_dst_mask	lib/switch-flow.hh	/^    uint32_t nw_dst_mask;       \/* 1-bit in each significant nw_dst bit. *\/$/;"	m	struct:sw_flow_key
nw_proto	include/openflow/openflow.hh	/^    uint8_t nw_proto;          \/* IP protocol or lower 8 bits of$/;"	m	struct:ofp_match
nw_proto	lib/flow.hh	/^    uint8_t nw_proto;           \/* IP protocol. *\/$/;"	m	struct:flow
nw_src	include/openflow/openflow.hh	/^    uint32_t nw_src;           \/* IP source address. *\/$/;"	m	struct:ofp_match
nw_src	lib/flow.hh	/^    uint32_t nw_src;            \/* IP source address. *\/$/;"	m	struct:flow
nw_src_mask	lib/switch-flow.hh	/^    uint32_t nw_src_mask;       \/* 1-bit in each significant nw_src bit. *\/$/;"	m	struct:sw_flow_key
nw_tos	include/openflow/openflow.hh	/^    uint8_t nw_tos;                 \/* IP ToS (DSCP field, 6 bits). *\/$/;"	m	struct:ofp_action_nw_tos
nw_tos	include/openflow/openflow.hh	/^    uint8_t nw_tos;            \/* IP ToS (actually DSCP field, 6 bits). *\/$/;"	m	struct:ofp_match
nw_tos	lib/flow.hh	/^    uint8_t nw_tos;             \/* IPv4 DSCP. *\/$/;"	m	struct:flow
nx_act_config	include/openflow/nicira-ext.hh	/^struct nx_act_config {$/;"	s
nx_action_header	include/openflow/nicira-ext.hh	/^struct nx_action_header {$/;"	s
nx_action_snat	include/openflow/nicira-ext.hh	/^struct nx_action_snat {$/;"	s
nx_action_subtype	include/openflow/nicira-ext.hh	/^enum nx_action_subtype {$/;"	g
nx_command_reply	include/openflow/nicira-ext.hh	/^struct nx_command_reply {$/;"	s
nx_flow_end	include/openflow/nicira-ext.hh	/^struct nx_flow_end {$/;"	s
nx_flow_end_config	include/openflow/nicira-ext.hh	/^struct nx_flow_end_config {$/;"	s
nx_flow_end_reason	include/openflow/nicira-ext.hh	/^enum nx_flow_end_reason {$/;"	g
nx_snat_command	include/openflow/nicira-ext.hh	/^enum nx_snat_command {$/;"	g
nx_snat_config	include/openflow/nicira-ext.hh	/^struct nx_snat_config {$/;"	s
nxh	include/openflow/nicira-ext.hh	/^    struct nicira_header nxh;$/;"	m	struct:nx_command_reply	typeref:struct:nx_command_reply::nicira_header
of	datapath.hh	/^	Datapath *of;$/;"	m	struct:onc_param
of_actions	lib/dp_act.cc	/^static struct openflow_action of_actions[OFPAT_ENQUEUE+1] = {$/;"	v	typeref:struct:openflow_action	file:
of_ext_recv_msg	lib/of_ext_msg.cc	/^int of_ext_recv_msg(class Datapath *dp, const struct rconn_sender *sender,$/;"	f
ofp_action_dl_addr	include/openflow/openflow.hh	/^struct ofp_action_dl_addr {$/;"	s
ofp_action_enqueue	include/openflow/openflow.hh	/^struct ofp_action_enqueue {$/;"	s
ofp_action_header	include/openflow/openflow.hh	/^struct ofp_action_header {$/;"	s
ofp_action_nw_addr	include/openflow/openflow.hh	/^struct ofp_action_nw_addr {$/;"	s
ofp_action_nw_tos	include/openflow/openflow.hh	/^struct ofp_action_nw_tos {$/;"	s
ofp_action_output	include/openflow/openflow.hh	/^struct ofp_action_output {$/;"	s
ofp_action_tp_port	include/openflow/openflow.hh	/^struct ofp_action_tp_port {$/;"	s
ofp_action_type	include/openflow/openflow.hh	/^enum ofp_action_type {$/;"	g
ofp_action_vendor_header	include/openflow/openflow.hh	/^struct ofp_action_vendor_header {$/;"	s
ofp_action_vlan_pcp	include/openflow/openflow.hh	/^struct ofp_action_vlan_pcp {$/;"	s
ofp_action_vlan_vid	include/openflow/openflow.hh	/^struct ofp_action_vlan_vid {$/;"	s
ofp_aggregate_stats_reply	include/openflow/openflow.hh	/^struct ofp_aggregate_stats_reply {$/;"	s
ofp_aggregate_stats_reply	lib/ofp-print.cc	/^ofp_aggregate_stats_reply(struct ds *string, const void *body_,$/;"	f	file:
ofp_aggregate_stats_request	include/openflow/openflow.hh	/^struct ofp_aggregate_stats_request {$/;"	s
ofp_aggregate_stats_request	lib/ofp-print.cc	/^ofp_aggregate_stats_request(struct ds *string, const void *oh,$/;"	f	file:
ofp_bad_action_code	include/openflow/openflow.hh	/^enum ofp_bad_action_code {$/;"	g
ofp_bad_request_code	include/openflow/openflow.hh	/^enum ofp_bad_request_code {$/;"	g
ofp_capabilities	include/openflow/openflow.hh	/^enum ofp_capabilities {$/;"	g
ofp_config_flags	include/openflow/openflow.hh	/^enum ofp_config_flags {$/;"	g
ofp_desc_stats	include/openflow/openflow.hh	/^struct ofp_desc_stats {$/;"	s
ofp_desc_stats_reply	lib/ofp-print.cc	/^ofp_desc_stats_reply(struct ds *string, const void *body, size_t len UNUSED,$/;"	f	file:
ofp_echo	lib/ofp-print.cc	/^ofp_echo(struct ds *string, const void *oh, size_t len, int verbosity)$/;"	f	file:
ofp_error	lib/util.cc	/^ofp_error(int err_no, const char *format, ...)$/;"	f
ofp_error_msg	include/openflow/openflow.hh	/^struct ofp_error_msg {$/;"	s
ofp_error_type	include/openflow/openflow.hh	/^enum ofp_error_type {$/;"	g
ofp_extension_commands	include/openflow/openflow-ext.hh	/^enum ofp_extension_commands { \/* Queue configuration commands *\/$/;"	g
ofp_extension_header	include/openflow/openflow-ext.hh	/^struct ofp_extension_header {$/;"	s
ofp_fatal	lib/util.cc	/^ofp_fatal(int err_no, const char *format, ...)$/;"	f
ofp_flow_mod	include/openflow/openflow.hh	/^struct ofp_flow_mod {$/;"	s
ofp_flow_mod_command	include/openflow/openflow.hh	/^enum ofp_flow_mod_command {$/;"	g
ofp_flow_mod_failed_code	include/openflow/openflow.hh	/^enum ofp_flow_mod_failed_code {$/;"	g
ofp_flow_mod_flags	include/openflow/openflow.hh	/^enum ofp_flow_mod_flags {$/;"	g
ofp_flow_removed	include/openflow/openflow.hh	/^struct ofp_flow_removed {$/;"	s
ofp_flow_removed_reason	include/openflow/openflow.hh	/^enum ofp_flow_removed_reason {$/;"	g
ofp_flow_stats	include/openflow/openflow.hh	/^struct ofp_flow_stats {$/;"	s
ofp_flow_stats_reply	lib/ofp-print.cc	/^ofp_flow_stats_reply(struct ds *string, const void *body_, size_t len,$/;"	f	file:
ofp_flow_stats_request	include/openflow/openflow.hh	/^struct ofp_flow_stats_request {$/;"	s
ofp_flow_stats_request	lib/ofp-print.cc	/^ofp_flow_stats_request(struct ds *string, const void *oh, size_t len UNUSED,$/;"	f	file:
ofp_flow_wildcards	include/openflow/openflow.hh	/^enum ofp_flow_wildcards {$/;"	g
ofp_hdr	include/openflow/private-ext.hh	/^	struct ofp_header ofp_hdr;	\/* protocol header *\/$/;"	m	struct:private_vxhdr	typeref:struct:private_vxhdr::ofp_header
ofp_header	include/openflow/openflow.hh	/^struct ofp_header {$/;"	s
ofp_hello	include/openflow/openflow.hh	/^struct ofp_hello {$/;"	s
ofp_hello_failed_code	include/openflow/openflow.hh	/^enum ofp_hello_failed_code {$/;"	g
ofp_hex_dump	lib/util.cc	/^ofp_hex_dump(FILE *stream, const void *buf_, size_t size,$/;"	f
ofp_match	include/openflow/openflow.hh	/^struct ofp_match {$/;"	s
ofp_match_to_string	lib/ofp-print.cc	/^ofp_match_to_string(const struct ofp_match *om, int verbosity)$/;"	f
ofp_message_type_to_string	lib/ofp-print.cc	/^ofp_message_type_to_string(uint8_t type)$/;"	f
ofp_packet_in	include/openflow/openflow.hh	/^struct ofp_packet_in {$/;"	s
ofp_packet_in	lib/ofp-print.cc	/^ofp_packet_in(struct ds *string, const void *oh, size_t len, int verbosity)$/;"	f	file:
ofp_packet_in_reason	include/openflow/openflow.hh	/^enum ofp_packet_in_reason {$/;"	g
ofp_packet_out	include/openflow/openflow.hh	/^struct ofp_packet_out {$/;"	s
ofp_packet_out	lib/ofp-print.cc	/^static void ofp_packet_out(struct ds *string, const void *oh, size_t len,$/;"	f	file:
ofp_packet_queue	include/openflow/openflow.hh	/^struct ofp_packet_queue {$/;"	s
ofp_packet_to_string	lib/ofp-print.cc	/^ofp_packet_to_string(const void *data, size_t len, size_t total_len UNUSED)$/;"	f
ofp_phy_port	include/openflow/openflow.hh	/^struct ofp_phy_port {$/;"	s
ofp_port	include/openflow/openflow.hh	/^enum ofp_port {$/;"	g
ofp_port_config	include/openflow/openflow.hh	/^enum ofp_port_config {$/;"	g
ofp_port_features	include/openflow/openflow.hh	/^enum ofp_port_features {$/;"	g
ofp_port_mod	include/openflow/openflow.hh	/^struct ofp_port_mod {$/;"	s
ofp_port_mod_failed_code	include/openflow/openflow.hh	/^enum ofp_port_mod_failed_code {$/;"	g
ofp_port_reason	include/openflow/openflow.hh	/^enum ofp_port_reason {$/;"	g
ofp_port_state	include/openflow/openflow.hh	/^enum ofp_port_state {$/;"	g
ofp_port_stats	include/openflow/openflow.hh	/^struct ofp_port_stats {$/;"	s
ofp_port_stats_reply	lib/ofp-print.cc	/^ofp_port_stats_reply(struct ds *string, const void *body, size_t len,$/;"	f	file:
ofp_port_stats_request	include/openflow/openflow.hh	/^struct ofp_port_stats_request {$/;"	s
ofp_port_status	include/openflow/openflow.hh	/^struct ofp_port_status {$/;"	s
ofp_print	lib/ofp-print.cc	/^ofp_print(FILE *stream, const void *oh, size_t len, int verbosity)$/;"	f
ofp_print_action	lib/ofp-print.cc	/^ofp_print_action(struct ds *string, const struct ofp_action_header *ah, $/;"	f	file:
ofp_print_actions	lib/ofp-print.cc	/^ofp_print_actions(struct ds *string, const struct ofp_action_header *action,$/;"	f	file:
ofp_print_error_msg	lib/ofp-print.cc	/^ofp_print_error_msg(struct ds *string, const void *oh, size_t len, $/;"	f	file:
ofp_print_flow_mod	lib/ofp-print.cc	/^ofp_print_flow_mod(struct ds *string, const void *oh, size_t len, $/;"	f	file:
ofp_print_flow_removed	lib/ofp-print.cc	/^ofp_print_flow_removed(struct ds *string, const void *oh, size_t len UNUSED, $/;"	f	file:
ofp_print_match	lib/ofp-print.cc	/^ofp_print_match(struct ds *f, const struct ofp_match *om, int verbosity)$/;"	f	file:
ofp_print_packet	lib/ofp-print.cc	/^ofp_print_packet(FILE *stream, const void *data, size_t len, size_t total_len)$/;"	f
ofp_print_phy_port	lib/ofp-print.cc	/^ofp_print_phy_port(struct ds *string, const struct ofp_phy_port *port)$/;"	f	file:
ofp_print_port_features	lib/ofp-print.cc	/^static void ofp_print_port_features(struct ds *string, uint32_t features)$/;"	f	file:
ofp_print_port_mod	lib/ofp-print.cc	/^ofp_print_port_mod(struct ds *string, const void *oh, size_t len UNUSED,$/;"	f	file:
ofp_print_port_name	lib/ofp-print.cc	/^static void ofp_print_port_name(struct ds *string, uint16_t port) $/;"	f	file:
ofp_print_port_status	lib/ofp-print.cc	/^ofp_print_port_status(struct ds *string, const void *oh, size_t len UNUSED,$/;"	f	file:
ofp_print_rate_shaping	lib/ofp-print.cc	/^ofp_print_rate_shaping(struct ds *string, const void *oh, size_t len UNUSED, int verbosity UNUSED)$/;"	f	file:
ofp_print_switch_config	lib/ofp-print.cc	/^ofp_print_switch_config(struct ds *string, const void *oh, size_t len UNUSED,$/;"	f	file:
ofp_print_switch_features	lib/ofp-print.cc	/^ofp_print_switch_features(struct ds *string, const void *oh, size_t len,$/;"	f	file:
ofp_queue	lib/queue.hh	/^struct ofp_queue {$/;"	s
ofp_queue_get_config_reply	include/openflow/openflow.hh	/^struct ofp_queue_get_config_reply {$/;"	s
ofp_queue_get_config_request	include/openflow/openflow.hh	/^struct ofp_queue_get_config_request {$/;"	s
ofp_queue_op_failed_code	include/openflow/openflow.hh	/^enum ofp_queue_op_failed_code {$/;"	g
ofp_queue_prop_header	include/openflow/openflow.hh	/^struct ofp_queue_prop_header {$/;"	s
ofp_queue_prop_min_rate	include/openflow/openflow.hh	/^struct ofp_queue_prop_min_rate {$/;"	s
ofp_queue_properties	include/openflow/openflow.hh	/^enum ofp_queue_properties {$/;"	g
ofp_queue_stats	include/openflow/openflow.hh	/^struct ofp_queue_stats {$/;"	s
ofp_queue_stats_reply	lib/ofp-print.cc	/^ofp_queue_stats_reply(struct ds *string, const void *body, size_t len,$/;"	f	file:
ofp_queue_stats_request	include/openflow/openflow.hh	/^struct ofp_queue_stats_request {$/;"	s
ofp_stats_reply	include/openflow/openflow.hh	/^struct ofp_stats_reply {$/;"	s
ofp_stats_reply	lib/ofp-print.cc	/^ofp_stats_reply(struct ds *string, const void *oh, size_t len, int verbosity)$/;"	f	file:
ofp_stats_reply_flags	include/openflow/openflow.hh	/^enum ofp_stats_reply_flags {$/;"	g
ofp_stats_request	include/openflow/openflow.hh	/^struct ofp_stats_request {$/;"	s
ofp_stats_request	lib/ofp-print.cc	/^ofp_stats_request(struct ds *string, const void *oh, size_t len, int verbosity)$/;"	f	file:
ofp_stats_types	include/openflow/openflow.hh	/^enum ofp_stats_types {$/;"	g
ofp_switch_config	include/openflow/openflow.hh	/^struct ofp_switch_config {$/;"	s
ofp_switch_features	include/openflow/openflow.hh	/^struct ofp_switch_features {$/;"	s
ofp_table_stats	include/openflow/openflow.hh	/^struct ofp_table_stats {$/;"	s
ofp_table_stats_reply	lib/ofp-print.cc	/^ofp_table_stats_reply(struct ds *string, const void *body, size_t len,$/;"	f	file:
ofp_to_string	lib/ofp-print.cc	/^ofp_to_string(const void *oh_, size_t len, int verbosity)$/;"	f
ofp_type	include/openflow/openflow.hh	/^enum ofp_type {$/;"	g
ofp_vendor	lib/ofp-print.cc	/^ofp_vendor(struct ds *string UNUSED, const void *oh, size_t len UNUSED, int verbosity UNUSED)$/;"	f	file:
ofp_vendor_header	include/openflow/openflow.hh	/^struct ofp_vendor_header {$/;"	s
ofp_vxid	include/openflow/private-ext.hh	/^	uint32_t ofp_vxid;	\/* vendor extenion ID *\/$/;"	m	struct:private_vxhdr
ofpbuf	lib/ofpbuf.hh	/^struct ofpbuf {$/;"	s
ofpbuf_at	lib/ofpbuf.cc	/^void *ofpbuf_at(const struct ofpbuf *b, size_t offset, size_t size) $/;"	f
ofpbuf_at_assert	lib/ofpbuf.cc	/^void *ofpbuf_at_assert(const struct ofpbuf *b, size_t offset, size_t size) $/;"	f
ofpbuf_clear	lib/ofpbuf.cc	/^void ofpbuf_clear(struct ofpbuf *b) $/;"	f
ofpbuf_clone	lib/ofpbuf.cc	/^struct ofpbuf *ofpbuf_clone(const struct ofpbuf *buffer)$/;"	f
ofpbuf_clone_data	lib/ofpbuf.cc	/^struct ofpbuf * ofpbuf_clone_data(const void *data, size_t size)$/;"	f
ofpbuf_delete	lib/ofpbuf.cc	/^void ofpbuf_delete(struct ofpbuf *b) $/;"	f
ofpbuf_end	lib/ofpbuf.cc	/^void *ofpbuf_end(const struct ofpbuf *b) $/;"	f
ofpbuf_headroom	lib/ofpbuf.cc	/^size_t ofpbuf_headroom(struct ofpbuf *b) $/;"	f
ofpbuf_init	lib/ofpbuf.cc	/^ofpbuf_init(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_new	lib/ofpbuf.cc	/^struct ofpbuf *ofpbuf_new(size_t size)$/;"	f
ofpbuf_prealloc_headroom	lib/ofpbuf.cc	/^void ofpbuf_prealloc_headroom(struct ofpbuf *b, size_t size) $/;"	f
ofpbuf_prealloc_tailroom	lib/ofpbuf.cc	/^void ofpbuf_prealloc_tailroom(struct ofpbuf *b, size_t size) $/;"	f
ofpbuf_pull	lib/ofpbuf.cc	/^void *ofpbuf_pull(struct ofpbuf *b, size_t size) $/;"	f
ofpbuf_push	lib/ofpbuf.cc	/^void *ofpbuf_push(struct ofpbuf *b, const void *p, size_t size) $/;"	f
ofpbuf_push_uninit	lib/ofpbuf.cc	/^void *ofpbuf_push_uninit(struct ofpbuf *b, size_t size) $/;"	f
ofpbuf_put	lib/ofpbuf.cc	/^void *ofpbuf_put(struct ofpbuf *b, const void *p, size_t size) $/;"	f
ofpbuf_put_uninit	lib/ofpbuf.cc	/^void *ofpbuf_put_uninit(struct ofpbuf *b, size_t size) $/;"	f
ofpbuf_put_zeros	lib/ofpbuf.cc	/^void *ofpbuf_put_zeros(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_reinit	lib/ofpbuf.cc	/^void ofpbuf_reinit(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_reserve	lib/ofpbuf.cc	/^void ofpbuf_reserve(struct ofpbuf *b, size_t size) $/;"	f
ofpbuf_tail	lib/ofpbuf.cc	/^void *ofpbuf_tail(const struct ofpbuf *b) $/;"	f
ofpbuf_tailroom	lib/ofpbuf.cc	/^size_t ofpbuf_tailroom(struct ofpbuf *b) $/;"	f
ofpbuf_to_packet	lib/ofpbuf.cc	/^Packet* ofpbuf_to_packet(struct ofpbuf* b)$/;"	f
ofpbuf_try_pull	lib/ofpbuf.cc	/^void *ofpbuf_try_pull(struct ofpbuf *b, size_t size) $/;"	f
ofpbuf_uninit	lib/ofpbuf.cc	/^ofpbuf_uninit(struct ofpbuf *b) $/;"	f
ofpbuf_use	lib/ofpbuf.cc	/^ofpbuf_use(struct ofpbuf *b, void *base, size_t allocated)$/;"	f
ofps_barrier_reply	lib/ofpstat.hh	/^	uint64_t ofps_barrier_reply;$/;"	m	struct:ofpstat
ofps_barrier_request	lib/ofpstat.hh	/^	uint64_t ofps_barrier_request;$/;"	m	struct:ofpstat
ofps_echo_reply	lib/ofpstat.hh	/^	uint64_t ofps_echo_reply;$/;"	m	struct:ofpstat
ofps_echo_request	lib/ofpstat.hh	/^	uint64_t ofps_echo_request;$/;"	m	struct:ofpstat
ofps_error	lib/ofpstat.hh	/^	uint64_t ofps_error;$/;"	m	struct:ofpstat
ofps_error_code	lib/ofpstat.hh	/^	} ofps_error_code;$/;"	m	struct:ofpstat	typeref:struct:ofpstat::__anon5
ofps_error_type	lib/ofpstat.hh	/^	} ofps_error_type;$/;"	m	struct:ofpstat	typeref:struct:ofpstat::__anon4
ofps_feats_reply	lib/ofpstat.hh	/^	uint64_t ofps_feats_reply;$/;"	m	struct:ofpstat
ofps_feats_request	lib/ofpstat.hh	/^	uint64_t ofps_feats_request;$/;"	m	struct:ofpstat
ofps_flow_mod	lib/ofpstat.hh	/^	uint64_t ofps_flow_mod;$/;"	m	struct:ofpstat
ofps_flow_mod_ops	lib/ofpstat.hh	/^	} ofps_flow_mod_ops;$/;"	m	struct:ofpstat	typeref:struct:ofpstat::__anon6
ofps_flow_removed	lib/ofpstat.hh	/^	uint64_t ofps_flow_removed;$/;"	m	struct:ofpstat
ofps_get_config_reply	lib/ofpstat.hh	/^	uint64_t ofps_get_config_reply;$/;"	m	struct:ofpstat
ofps_get_config_request	lib/ofpstat.hh	/^	uint64_t ofps_get_config_request;$/;"	m	struct:ofpstat
ofps_hello	lib/ofpstat.hh	/^	uint64_t ofps_hello;$/;"	m	struct:ofpstat
ofps_packet_in	lib/ofpstat.hh	/^	uint64_t ofps_packet_in;$/;"	m	struct:ofpstat
ofps_packet_out	lib/ofpstat.hh	/^	uint64_t ofps_packet_out;$/;"	m	struct:ofpstat
ofps_port_mod	lib/ofpstat.hh	/^	uint64_t ofps_port_mod;$/;"	m	struct:ofpstat
ofps_port_status	lib/ofpstat.hh	/^	uint64_t ofps_port_status;$/;"	m	struct:ofpstat
ofps_rcvd	lib/rconn.cc	/^    struct ofpstat ofps_rcvd;$/;"	m	struct:rconn	typeref:struct:rconn::ofpstat	file:
ofps_rcvd	lib/vconn-provider.hh	/^    struct ofpstat ofps_rcvd;$/;"	m	struct:vconn	typeref:struct:vconn::ofpstat
ofps_sent	lib/rconn.cc	/^    struct ofpstat ofps_sent;$/;"	m	struct:rconn	typeref:struct:rconn::ofpstat	file:
ofps_sent	lib/vconn-provider.hh	/^    struct ofpstat ofps_sent;$/;"	m	struct:vconn	typeref:struct:vconn::ofpstat
ofps_set_config	lib/ofpstat.hh	/^	uint64_t ofps_set_config;$/;"	m	struct:ofpstat
ofps_stats_reply	lib/ofpstat.hh	/^	uint64_t ofps_stats_reply;$/;"	m	struct:ofpstat
ofps_stats_request	lib/ofpstat.hh	/^	uint64_t ofps_stats_request;$/;"	m	struct:ofpstat
ofps_total	lib/ofpstat.hh	/^	uint64_t ofps_total;$/;"	m	struct:ofpstat
ofps_unknown	lib/ofpstat.hh	/^	uint64_t ofps_unknown;$/;"	m	struct:ofpstat
ofps_vendor	lib/ofpstat.hh	/^	uint64_t ofps_vendor;$/;"	m	struct:ofpstat
ofpstat	lib/ofpstat.hh	/^struct ofpstat {$/;"	s
ofpstat_inc_protocol_stat	lib/ofpstat.cc	/^ofpstat_inc_protocol_stat(struct ofpstat *ifps, struct ofp_header *hdr)$/;"	f
ofq_error_string	include/openflow/openflow-ext.hh	91;"	d
onc	datapath.hh	/^	struct onc_param onc;$/;"	m	class:Datapath	typeref:struct:Datapath::onc_param
onc_param	datapath.hh	/^struct onc_param {$/;"	s
open	lib/vconn-provider.hh	/^    int (*open)(const char *name, char *suffix, struct vconn **vconnp);$/;"	m	struct:vconn_class
openflow_action	lib/dp_act.cc	/^struct openflow_action {$/;"	s	file:
openflow_ext_set_dp_desc	include/openflow/openflow-ext.hh	/^struct openflow_ext_set_dp_desc {$/;"	s
openflow_family	lib/dpif.cc	/^static int openflow_family;$/;"	v	file:
openflow_multicast_policy	lib/dpif.cc	/^static struct nl_policy openflow_multicast_policy[DP_GENL_A_DP_NAME+1];$/;"	v	typeref:struct:nl_policy	file:
openflow_packet	lib/ofp-print.cc	/^struct openflow_packet {$/;"	s	file:
openflow_policy	lib/dpif.cc	/^static struct nl_policy openflow_policy[DP_GENL_A_OPENFLOW+1];$/;"	v	typeref:struct:nl_policy	file:
openflow_queue_command_header	include/openflow/openflow-ext.hh	/^struct openflow_queue_command_header {$/;"	s
openflow_queue_error_code	include/openflow/openflow-ext.hh	/^enum openflow_queue_error_code {$/;"	g
optional	lib/netlink.hh	/^    bool optional;$/;"	m	struct:nl_policy
orig_len	lib/pcap.cc	/^    uint32_t orig_len;       \/* actual length of packet *\/$/;"	m	struct:pcaprec_hdr	file:
out_of_memory	lib/util.cc	/^out_of_memory(void) $/;"	f
out_port	include/openflow/openflow.hh	/^    uint16_t out_port;            \/* For OFPFC_DELETE* commands, require$/;"	m	struct:ofp_flow_mod
out_port	include/openflow/openflow.hh	/^    uint16_t out_port;        \/* Require matching entries to include this$/;"	m	struct:ofp_aggregate_stats_request
out_port	include/openflow/openflow.hh	/^    uint16_t out_port;        \/* Require matching entries to include this$/;"	m	struct:ofp_flow_stats_request
output_all	datapath.cc	/^int Datapath::output_all(struct ofpbuf *buffer, int in_port, int flood)$/;"	f	class:Datapath
output_packet	datapath.cc	/^void Datapath::output_packet(struct ofpbuf *buffer, uint16_t out_port, uint32_t queue_id)$/;"	f	class:Datapath
output_packet	datapath.hh	/^	uint32_t output_packet;$/;"	m	struct:func_stat
packetQueue	RConn.hh	/^	struct SynchronizedPacketQueue packetQueue;	$/;"	m	class:RConn	typeref:struct:RConn::SynchronizedPacketQueue
packet_count	include/openflow/nicira-ext.hh	/^    uint64_t packet_count;$/;"	m	struct:nx_flow_end
packet_count	include/openflow/openflow.hh	/^    uint64_t packet_count;    \/* Number of packets in flow. *\/$/;"	m	struct:ofp_flow_stats
packet_count	include/openflow/openflow.hh	/^    uint64_t packet_count;    \/* Number of packets in flows. *\/$/;"	m	struct:ofp_aggregate_stats_reply
packet_count	include/openflow/openflow.hh	/^    uint64_t packet_count;$/;"	m	struct:ofp_flow_removed
packet_count	lib/switch-flow.hh	/^    uint64_t packet_count;      \/* Number of packets seen. *\/$/;"	m	struct:sw_flow
packet_to_ofpbuf	lib/ofpbuf.cc	/^struct ofpbuf* packet_to_ofpbuf( Packet* p)$/;"	f
packet_to_ofpbuf_with_headroom	lib/ofpbuf.cc	/^struct ofpbuf* packet_to_ofpbuf_with_headroom( Packet* p, int head_room )$/;"	f
packetbuffer	datapath.hh	/^	DatapathPacketBuffer packetbuffer;$/;"	m	class:Datapath
packets	lib/ofp-print.cc	/^static const struct openflow_packet packets[] = {$/;"	v	typeref:struct:openflow_packet	file:
packets_received	lib/rconn.cc	/^    unsigned int packets_received;$/;"	m	struct:rconn	file:
packets_sent	lib/rconn.cc	/^    unsigned int packets_sent;$/;"	m	struct:rconn	file:
pad	include/openflow/nicira-ext.hh	/^    uint8_t pad[2];$/;"	m	struct:nx_act_config
pad	include/openflow/nicira-ext.hh	/^    uint8_t pad[3];$/;"	m	struct:nx_flow_end_config
pad	include/openflow/nicira-ext.hh	/^    uint8_t pad[3];$/;"	m	struct:nx_snat_config
pad	include/openflow/nicira-ext.hh	/^    uint8_t pad[4];$/;"	m	struct:nx_action_snat
pad	include/openflow/nicira-ext.hh	/^    uint8_t pad[6];$/;"	m	struct:nx_action_header
pad	include/openflow/openflow-ext.hh	/^    uint8_t pad[6];             \/* Align to 64-bits *\/$/;"	m	struct:openflow_queue_command_header
pad	include/openflow/openflow.hh	/^    uint8_t pad;              \/* Align to 32 bits. *\/$/;"	m	struct:ofp_aggregate_stats_request
pad	include/openflow/openflow.hh	/^    uint8_t pad;              \/* Align to 32 bits. *\/$/;"	m	struct:ofp_flow_stats_request
pad	include/openflow/openflow.hh	/^    uint8_t pad;$/;"	m	struct:ofp_flow_stats
pad	include/openflow/openflow.hh	/^    uint8_t pad;$/;"	m	struct:ofp_packet_in
pad	include/openflow/openflow.hh	/^    uint8_t pad[1];           \/* Align to 32-bits. *\/$/;"	m	struct:ofp_flow_removed
pad	include/openflow/openflow.hh	/^    uint8_t pad[2];          \/* Align to 32-bits. *\/$/;"	m	struct:ofp_queue_stats
pad	include/openflow/openflow.hh	/^    uint8_t pad[2];          \/* Align to 32-bits. *\/$/;"	m	struct:ofp_queue_stats_request
pad	include/openflow/openflow.hh	/^    uint8_t pad[2];        \/* 32-bit alignment. *\/$/;"	m	struct:ofp_queue_get_config_request
pad	include/openflow/openflow.hh	/^    uint8_t pad[2];        \/* 64-bit alignment. *\/$/;"	m	struct:ofp_packet_queue
pad	include/openflow/openflow.hh	/^    uint8_t pad[2];$/;"	m	struct:ofp_action_tp_port
pad	include/openflow/openflow.hh	/^    uint8_t pad[2];$/;"	m	struct:ofp_action_vlan_vid
pad	include/openflow/openflow.hh	/^    uint8_t pad[3];          \/* Align to 32-bits. *\/$/;"	m	struct:ofp_table_stats
pad	include/openflow/openflow.hh	/^    uint8_t pad[3];         \/* Align to 64-bits. *\/$/;"	m	struct:ofp_switch_features
pad	include/openflow/openflow.hh	/^    uint8_t pad[3];$/;"	m	struct:ofp_action_nw_tos
pad	include/openflow/openflow.hh	/^    uint8_t pad[3];$/;"	m	struct:ofp_action_vlan_pcp
pad	include/openflow/openflow.hh	/^    uint8_t pad[4];           \/* Align to 64 bits. *\/$/;"	m	struct:ofp_aggregate_stats_reply
pad	include/openflow/openflow.hh	/^    uint8_t pad[4];         \/* Pad to 64-bits. *\/$/;"	m	struct:ofp_port_mod
pad	include/openflow/openflow.hh	/^    uint8_t pad[4];       \/* 64-bit alignemnt. *\/$/;"	m	struct:ofp_queue_prop_header
pad	include/openflow/openflow.hh	/^    uint8_t pad[4];$/;"	m	struct:ofp_action_header
pad	include/openflow/openflow.hh	/^    uint8_t pad[6];           \/* Pad for 64-bit alignment. *\/$/;"	m	struct:ofp_action_enqueue
pad	include/openflow/openflow.hh	/^    uint8_t pad[6];          \/* Align to 64-bits. *\/$/;"	m	struct:ofp_port_stats
pad	include/openflow/openflow.hh	/^    uint8_t pad[6];       \/* 64-bit alignment *\/$/;"	m	struct:ofp_queue_prop_min_rate
pad	include/openflow/openflow.hh	/^    uint8_t pad[6];$/;"	m	struct:ofp_action_dl_addr
pad	include/openflow/openflow.hh	/^    uint8_t pad[6];$/;"	m	struct:ofp_port_stats_request
pad	include/openflow/openflow.hh	/^    uint8_t pad[6];$/;"	m	struct:ofp_queue_get_config_reply
pad	include/openflow/openflow.hh	/^    uint8_t pad[7];          \/* Align to 64-bits. *\/$/;"	m	struct:ofp_port_status
pad	lib/flow.hh	/^    uint8_t pad[3];$/;"	m	struct:flow
pad1	include/openflow/openflow.hh	/^    uint8_t pad1[1];           \/* Align to 64-bits *\/$/;"	m	struct:ofp_match
pad2	include/openflow/nicira-ext.hh	/^    uint8_t pad2[2];$/;"	m	struct:nx_snat_config
pad2	include/openflow/openflow.hh	/^    uint8_t pad2[2];           \/* Align to 64-bits *\/$/;"	m	struct:ofp_match
pad2	include/openflow/openflow.hh	/^    uint8_t pad2[2];          \/* Align to 64-bits. *\/$/;"	m	struct:ofp_flow_removed
pad2	include/openflow/openflow.hh	/^    uint8_t pad2[6];          \/* Align to 64-bits. *\/$/;"	m	struct:ofp_flow_stats
parse_control_input	RConn.cc	/^int RConn::parse_control_input(struct rconn_remote *sender, uint32_t xid, const void *msg_in, size_t length)$/;"	f	class:RConn
path	lib/vlog-socket.cc	/^    char *path;$/;"	m	struct:vlog_server	file:
path_cost	lib/stp.cc	/^    int path_cost;                  \/* 8.5.5.3: Cost of tx\/rx on this port. *\/$/;"	m	struct:stp_port	file:
pattern	lib/vlog.cc	/^    char *pattern;              \/* Current pattern. *\/$/;"	m	struct:facility	file:
pcap_hdr	lib/pcap.cc	/^struct pcap_hdr {$/;"	s	file:
pcap_open	lib/pcap.cc	/^pcap_open(const char *file_name, const char *mode)$/;"	f
pcap_read	lib/pcap.cc	/^pcap_read(FILE *file, struct ofpbuf **bufp)$/;"	f
pcap_read_header	lib/pcap.cc	/^pcap_read_header(FILE *file)$/;"	f
pcap_write	lib/pcap.cc	/^pcap_write(FILE *file, struct ofpbuf *buf)$/;"	f
pcap_write_header	lib/pcap.cc	/^pcap_write_header(FILE *file)$/;"	f
pcaprec_hdr	lib/pcap.cc	/^struct pcaprec_hdr {$/;"	s	file:
peer	datapath.hh	/^	uint32_t peer;$/;"	m	struct:click_port
peer	include/openflow/openflow.hh	/^    uint32_t peer;          \/* Features advertised by peer. *\/$/;"	m	struct:ofp_phy_port
pid	lib/netlink.cc	/^    uint32_t pid;$/;"	m	struct:nl_sock	file:
poll_block	lib/poll-loop.cc	/^void poll_block()$/;"	f
poll_cancel	lib/poll-loop.cc	/^poll_cancel(struct poll_waiter *pw)$/;"	f
poll_fd_callback	lib/poll-loop.cc	/^poll_fd_callback(int fd, short int events, poll_fd_func *function, void *aux)$/;"	f
poll_fd_func	lib/poll-loop.hh	/^typedef void poll_fd_func(int fd, short int revents, void *aux);$/;"	t
poll_fd_wait	lib/poll-loop.cc	/^poll_fd_wait(int fd, short int events)$/;"	f
poll_immediate_wake	lib/poll-loop.cc	/^poll_immediate_wake(void)$/;"	f
poll_server	lib/vlog-socket.cc	/^poll_server(int fd UNUSED, short int events UNUSED, void *server_)$/;"	f	file:
poll_timer_wait	lib/poll-loop.cc	/^poll_timer_wait(int msec)$/;"	f
poll_waiter	lib/poll-loop.cc	/^struct poll_waiter {$/;"	s	file:
pollfd	lib/poll-loop.cc	/^    struct pollfd *pollfd;      \/* Pointer to element of the pollfds array$/;"	m	struct:poll_waiter	typeref:struct:poll_waiter::pollfd	file:
pop	SynchronizedPacketQueue.hh	/^inline struct buf_rconn SynchronizedPacketQueue::pop()$/;"	f	class:SynchronizedPacketQueue
port	datapath.cc	/^	uint16_t port;$/;"	m	struct:queue_stats_state	file:
port	datapath.hh	/^	struct click_port *port; \/* reference to the parent port *\/$/;"	m	struct:sw_queue	typeref:struct:sw_queue::click_port
port	include/openflow/nicira-ext.hh	/^    uint16_t port;                  \/* Output port--it must be previously $/;"	m	struct:nx_action_snat
port	include/openflow/nicira-ext.hh	/^    uint16_t port;          \/* Physical switch port. *\/$/;"	m	struct:nx_snat_config
port	include/openflow/openflow-ext.hh	/^    uint16_t port;              \/* Port for operations *\/$/;"	m	struct:openflow_queue_command_header
port	include/openflow/openflow.hh	/^    uint16_t port;                  \/* Output port. *\/$/;"	m	struct:ofp_action_output
port	include/openflow/openflow.hh	/^    uint16_t port;            \/* Port that queue belongs. Should$/;"	m	struct:ofp_action_enqueue
port	include/openflow/openflow.hh	/^    uint16_t port;         \/* Port to be queried. Should refer$/;"	m	struct:ofp_queue_get_config_request
port	include/openflow/openflow.hh	/^    uint16_t port;$/;"	m	struct:ofp_queue_get_config_reply
port_count	RConn.hh	/^	const char *port_count() const		{ return "1\/1"; }$/;"	f	class:RConn
port_count	datapath.hh	/^	const char *port_count() const		{ return "-\/-"; }$/;"	f	class:Datapath
port_description	datapath.cc	/^void Datapath::port_description(struct ofp_phy_port* desc, uint16_t port_no) $/;"	f	class:Datapath
port_id	lib/stp.cc	/^    int port_id;                    \/* 8.5.5.1: Unique port identifier. *\/$/;"	m	struct:stp_port	file:
port_id	lib/stp.cc	/^    uint16_t port_id;              \/* 8.5.1.4: Port transmitting the BPDU. *\/$/;"	m	struct:stp_config_bpdu	file:
port_no	datapath.cc	/^	int port_no;	\/* from ofp_stats_request *\/$/;"	m	struct:port_stats_state	file:
port_no	datapath.hh	/^	uint16_t port_no;$/;"	m	struct:click_port
port_no	include/openflow/openflow.hh	/^	uint16_t port_no;$/;"	m	struct:netopen_rate_shape
port_no	include/openflow/openflow.hh	/^    uint16_t port_no;        \/* All ports if OFPT_ALL. *\/$/;"	m	struct:ofp_queue_stats_request
port_no	include/openflow/openflow.hh	/^    uint16_t port_no;        \/* OFPST_PORT message must request statistics$/;"	m	struct:ofp_port_stats_request
port_no	include/openflow/openflow.hh	/^    uint16_t port_no;$/;"	m	struct:ofp_phy_port
port_no	include/openflow/openflow.hh	/^    uint16_t port_no;$/;"	m	struct:ofp_port_mod
port_no	include/openflow/openflow.hh	/^    uint16_t port_no;$/;"	m	struct:ofp_port_stats
port_no	include/openflow/openflow.hh	/^    uint16_t port_no;$/;"	m	struct:ofp_queue_stats
port_on_use	datapath.hh	/^	uint8_t port_on_use;$/;"	m	struct:click_port
port_stats_done	datapath.cc	/^static void port_stats_done(void *state)$/;"	f	file:
port_stats_dump	datapath.cc	/^static int port_stats_dump(class Datapath *dp, void *state,$/;"	f	file:
port_stats_init	datapath.cc	/^static int port_stats_init(const void *body, int \/*body_len*\/, void **state)$/;"	f	file:
port_stats_state	datapath.cc	/^struct port_stats_state {$/;"	s	file:
ports	include/openflow/openflow.hh	/^    struct ofp_phy_port ports[0];  \/* Port definitions.  The number of ports$/;"	m	struct:ofp_switch_features	typeref:struct:ofp_switch_features::ofp_phy_port
ports	lib/stp.cc	/^    struct stp_port ports[STP_MAX_PORTS];$/;"	m	struct:stp	typeref:struct:stp::stp_port	file:
pos	lib/vconn.hh	/^    const uint8_t *pos, *end;$/;"	m	struct:flow_stats_iterator
position	datapath.cc	/^	struct sw_table_position position;$/;"	m	struct:flow_stats_state	typeref:struct:flow_stats_state::sw_table_position	file:
prev	lib/list.hh	/^    struct list *prev;     \/* Previous list element. *\/$/;"	m	struct:list	typeref:struct:list::list
print_and_free	lib/ofp-print.cc	/^print_and_free(FILE *stream, char *string) $/;"	f	file:
print_flow	lib/switch-flow.cc	/^print_flow(const struct sw_flow_key *key)$/;"	f
print_ip_netmask	lib/ofp-print.cc	/^print_ip_netmask(struct ds *string, const char *leader, uint32_t ip,$/;"	f	file:
print_port_stat	lib/ofp-print.cc	/^static void print_port_stat(struct ds *string, const char *leader, $/;"	f	file:
print_stats	lib/ofp-print.cc	/^print_stats(struct ds *string, int type, const void *body, size_t body_len,$/;"	f	file:
print_wild	lib/ofp-print.cc	/^static void print_wild(struct ds *string, const char *leader, int is_wild,$/;"	f	file:
printer	lib/ofp-print.cc	/^    void (*printer)(struct ds *, const void *, size_t len, int verbosity);$/;"	m	struct:openflow_packet	file:
priority	include/openflow/nicira-ext.hh	/^    uint16_t priority;        \/* Priority level of flow entry. *\/$/;"	m	struct:nx_flow_end
priority	include/openflow/openflow.hh	/^    uint16_t priority;            \/* Priority level of flow entry. *\/$/;"	m	struct:ofp_flow_mod
priority	include/openflow/openflow.hh	/^    uint16_t priority;        \/* Priority level of flow entry. *\/$/;"	m	struct:ofp_flow_removed
priority	include/openflow/openflow.hh	/^    uint16_t priority;        \/* Priority of the entry. Only meaningful$/;"	m	struct:ofp_flow_stats
priority	lib/switch-flow.hh	/^    uint16_t priority;          \/* Only used on entries with wildcards. *\/$/;"	m	struct:sw_flow
private_recv_msg	lib/private-msg.cc	/^private_recv_msg(class Datapath *dp, const struct rconn_sender *sender UNUSED,$/;"	f
private_vxhdr	include/openflow/private-ext.hh	/^struct private_vxhdr {$/;"	s
private_vxopt	include/openflow/private-ext.hh	/^struct private_vxopt {$/;"	s
probably_admitted	lib/rconn.cc	/^    bool probably_admitted;$/;"	m	struct:rconn	file:
probe_interval	lib/rconn.cc	/^    int probe_interval;         \/* Secs of inactivity before sending probe. *\/$/;"	m	struct:rconn	file:
processing	RConn.hh	/^	const char *processing() const		{ return PUSH; }$/;"	f	class:RConn
processing	datapath.hh	/^	const char *processing() const		{ return PUSH; }$/;"	f	class:Datapath
program_name	lib/util.cc	/^const char *program_name;$/;"	v
prop_header	include/openflow/openflow.hh	/^    struct ofp_queue_prop_header prop_header; \/* prop: OFPQT_MIN, len: 16. *\/$/;"	m	struct:ofp_queue_prop_min_rate	typeref:struct:ofp_queue_prop_min_rate::ofp_queue_prop_header
properties	include/openflow/openflow.hh	/^    struct ofp_queue_prop_header properties[0]; \/* List of properties. *\/$/;"	m	struct:ofp_packet_queue	typeref:struct:ofp_packet_queue::ofp_queue_prop_header
property	datapath.hh	/^	uint16_t property; \/* one from OFPQT_ *\/$/;"	m	struct:sw_queue
property	include/openflow/openflow.hh	/^    uint16_t property;    \/* One of OFPQT_. *\/$/;"	m	struct:ofp_queue_prop_header
protection_callback	lib/private-msg.cc	/^protection_callback(struct sw_flow *flow, void *private_)$/;"	f	file:
protocol_id	lib/stp.cc	/^    uint16_t protocol_id;       \/* STP_PROTOCOL_ID. *\/$/;"	m	struct:stp_bpdu_header	file:
protocol_version	lib/stp.cc	/^    uint8_t protocol_version;   \/* STP_PROTOCOL_VERSION. *\/$/;"	m	struct:stp_bpdu_header	file:
pssl_accept	lib/vconn-ssl.cc	/^pssl_accept(struct pvconn *pvconn, struct vconn **new_vconnp)$/;"	f	file:
pssl_close	lib/vconn-ssl.cc	/^pssl_close(struct pvconn *pvconn)$/;"	f	file:
pssl_open	lib/vconn-ssl.cc	/^pssl_open(const char *name, char *suffix, struct pvconn **pvconnp)$/;"	f	file:
pssl_pvconn	lib/vconn-ssl.cc	/^struct pssl_pvconn$/;"	s	file:
pssl_pvconn_cast	lib/vconn-ssl.cc	/^pssl_pvconn_cast(struct pvconn *pvconn)$/;"	f	file:
pssl_pvconn_class	lib/vconn-ssl.cc	/^struct pvconn_class pssl_pvconn_class = {$/;"	v	typeref:struct:pvconn_class
pssl_wait	lib/vconn-ssl.cc	/^pssl_wait(struct pvconn *pvconn)$/;"	f	file:
pstream_accept	lib/vconn-stream.cc	/^pstream_accept(struct pvconn *pvconn, struct vconn **new_vconnp)$/;"	f	file:
pstream_close	lib/vconn-stream.cc	/^pstream_close(struct pvconn *pvconn)$/;"	f	file:
pstream_pvconn	lib/vconn-stream.cc	/^struct pstream_pvconn$/;"	s	file:
pstream_pvconn_cast	lib/vconn-stream.cc	/^pstream_pvconn_cast(struct pvconn *pvconn)$/;"	f	file:
pstream_pvconn_class	lib/vconn-stream.cc	/^static struct pvconn_class pstream_pvconn_class = {$/;"	v	typeref:struct:pvconn_class	file:
pstream_wait	lib/vconn-stream.cc	/^pstream_wait(struct pvconn *pvconn)$/;"	f	file:
ptcp_accept	lib/vconn-tcp.cc	/^ptcp_accept(int fd, const struct sockaddr *sa, size_t sa_len,$/;"	f	file:
ptcp_open	lib/vconn-tcp.cc	/^ptcp_open(const char *name, char *suffix, struct pvconn **pvconnp)$/;"	f	file:
ptcp_pvconn_class	lib/vconn-tcp.cc	/^struct pvconn_class ptcp_pvconn_class = {$/;"	v	typeref:struct:pvconn_class
pull_arp	lib/flow.cc	/^static struct arp_header * pull_arp(struct ofpbuf *packet)$/;"	f	file:
pull_eth	lib/flow.cc	/^static struct eth_header * pull_eth(struct ofpbuf *packet) $/;"	f	file:
pull_icmp	lib/flow.cc	/^static struct icmp_header * pull_icmp(struct ofpbuf *packet) $/;"	f	file:
pull_ip	lib/flow.cc	/^static struct ip_header * pull_ip(struct ofpbuf *packet)$/;"	f	file:
pull_tcp	lib/flow.cc	/^static struct tcp_header * pull_tcp(struct ofpbuf *packet) $/;"	f	file:
pull_udp	lib/flow.cc	/^static struct udp_header * pull_udp(struct ofpbuf *packet) $/;"	f	file:
pull_vlan	lib/flow.cc	/^static struct vlan_header * pull_vlan(struct ofpbuf *packet)$/;"	f	file:
punix_accept	lib/vconn-unix.cc	/^punix_accept(int fd, const struct sockaddr *sa, size_t sa_len,$/;"	f	file:
punix_open	lib/vconn-unix.cc	/^static int punix_open(const char *name UNUSED, char *suffix, struct pvconn **pvconnp)$/;"	f	file:
punix_pvconn_class	lib/vconn-unix.cc	/^struct pvconn_class punix_pvconn_class = {$/;"	v	typeref:struct:pvconn_class
push	RConn.cc	/^void RConn::push(int input UNUSED, Packet *p)$/;"	f	class:RConn
push	SynchronizedPacketQueue.hh	/^inline int SynchronizedPacketQueue::push(struct buf_rconn *p)$/;"	f	class:SynchronizedPacketQueue
push	datapath.cc	/^void Datapath::push(int input, Packet* p)$/;"	f	class:Datapath
put_openflow	lib/vconn.cc	/^put_openflow(size_t openflow_len, uint8_t type, struct ofpbuf *buffer)$/;"	f
put_openflow_xid	lib/vconn.cc	/^put_openflow_xid(size_t openflow_len, uint8_t type, uint32_t xid,$/;"	f
pvconn	lib/vconn-provider.hh	/^struct pvconn {$/;"	s
pvconn	lib/vconn-ssl.cc	/^    struct pvconn pvconn;$/;"	m	struct:pssl_pvconn	typeref:struct:pssl_pvconn::pvconn	file:
pvconn	lib/vconn-stream.cc	/^    struct pvconn pvconn;$/;"	m	struct:pstream_pvconn	typeref:struct:pstream_pvconn::pvconn	file:
pvconn_accept	lib/vconn.cc	/^pvconn_accept(struct pvconn *pvconn, int min_version, struct vconn **new_vconn)$/;"	f
pvconn_assert_class	lib/vconn-provider.hh	/^static inline void pvconn_assert_class(const struct pvconn *pvconn,$/;"	f
pvconn_class	lib/vconn-provider.hh	/^struct pvconn_class {$/;"	s
pvconn_classes	lib/vconn.cc	/^static struct pvconn_class *pvconn_classes[] = {$/;"	v	typeref:struct:pvconn_class	file:
pvconn_close	lib/vconn.cc	/^void pvconn_close(struct pvconn *pvconn)$/;"	f
pvconn_init	lib/vconn.cc	/^pvconn_init(struct pvconn *pvconn, struct pvconn_class *Class,$/;"	f
pvconn_open	lib/vconn.cc	/^int pvconn_open(const char *name, struct pvconn **pvconnp)$/;"	f
pvconn_wait	lib/vconn.cc	/^pvconn_wait(struct pvconn *pvconn)$/;"	f
pvo_len	include/openflow/private-ext.hh	/^	uint16_t pvo_len;	\/* length of value (octet) *\/$/;"	m	struct:private_vxopt
pvo_type	include/openflow/private-ext.hh	/^	uint16_t pvo_type;	\/* type of vendor extension option *\/$/;"	m	struct:private_vxopt
query_datapath	lib/dpif.cc	/^query_datapath(int *dp_idx, int *multicast_group, const char *dp_name)$/;"	f	file:
question_connectivity	lib/rconn.cc	/^question_connectivity(struct rconn *rc) $/;"	f	file:
questionable_connectivity	lib/rconn.cc	/^    bool questionable_connectivity;$/;"	m	struct:rconn	file:
queue_advance_head	lib/queue.cc	/^queue_advance_head(struct ofp_queue *q, struct ofpbuf *next)$/;"	f
queue_clear	lib/queue.cc	/^queue_clear(struct ofp_queue *q)$/;"	f
queue_destroy	lib/queue.cc	/^queue_destroy(struct ofp_queue *q)$/;"	f
queue_id	datapath.cc	/^	uint32_t queue_id;$/;"	m	struct:queue_stats_state	file:
queue_id	datapath.hh	/^	uint32_t queue_id;$/;"	m	struct:sw_queue
queue_id	include/openflow/openflow.hh	/^    uint32_t queue_id;        \/* Where to enqueue the packets. *\/$/;"	m	struct:ofp_action_enqueue
queue_id	include/openflow/openflow.hh	/^    uint32_t queue_id;       \/* All queues if OFPQ_ALL. *\/$/;"	m	struct:ofp_queue_stats_request
queue_id	include/openflow/openflow.hh	/^    uint32_t queue_id;       \/* Queue i.d *\/$/;"	m	struct:ofp_queue_stats
queue_id	include/openflow/openflow.hh	/^    uint32_t queue_id;     \/* id for the specific queue. *\/$/;"	m	struct:ofp_packet_queue
queue_init	lib/queue.cc	/^queue_init(struct ofp_queue *q)$/;"	f
queue_list	datapath.hh	/^	struct list queue_list; \/* list of all queues for this port *\/$/;"	m	struct:click_port	typeref:struct:click_port::list
queue_pop_head	lib/queue.cc	/^queue_pop_head(struct ofp_queue *q)$/;"	f
queue_push_tail	lib/queue.cc	/^queue_push_tail(struct ofp_queue *q, struct ofpbuf *b)$/;"	f
queue_stats_done	datapath.cc	/^static void queue_stats_done(void *state)$/;"	f	file:
queue_stats_dump	datapath.cc	/^static int queue_stats_dump(class Datapath *dp, void *state,$/;"	f	file:
queue_stats_init	datapath.cc	/^static int queue_stats_init(const void *body, int body_len UNUSED, void **state)$/;"	f	file:
queue_stats_state	datapath.cc	/^struct queue_stats_state {$/;"	s	file:
queues	datapath.hh	/^	struct sw_queue queues[NETDEV_MAX_QUEUES];$/;"	m	struct:click_port	typeref:struct:click_port::sw_queue
queues	include/openflow/openflow.hh	/^    struct ofp_packet_queue queues[0]; \/* List of configured queues. *\/$/;"	m	struct:ofp_queue_get_config_reply	typeref:struct:ofp_queue_get_config_reply::ofp_packet_queue
random_bytes	lib/random.cc	/^random_bytes(void *p_, size_t n)$/;"	f
random_init	lib/random.cc	/^random_init(void)$/;"	f
random_range	lib/random.cc	/^random_range(int max) $/;"	f
random_uint16	lib/random.cc	/^random_uint16(void)$/;"	f
random_uint32	lib/random.cc	/^random_uint32(void)$/;"	f
random_uint8	lib/random.cc	/^random_uint8(void)$/;"	f
rate	include/openflow/openflow.hh	/^	uint16_t rate;$/;"	m	struct:netopen_rate_shape
rate	include/openflow/openflow.hh	/^    uint16_t rate;        \/* In 1\/10 of a percent; >1000 -> disabled. *\/$/;"	m	struct:ofp_queue_prop_min_rate
rate	lib/vlog.hh	/^    unsigned int rate;          \/* Tokens per second. *\/$/;"	m	struct:vlog_rate_limit
rconn	RConn.hh	/^        struct rconn *rconn;$/;"	m	struct:rconn_remote	typeref:struct:rconn_remote::rconn
rconn	lib/rconn.cc	/^struct rconn {$/;"	s	file:
rconnElement	RConn.hh	/^        RConn *rconnElement;$/;"	m	struct:rnc_param
rconn_add_monitor	lib/rconn.cc	/^void rconn_add_monitor(struct rconn *rc, struct vconn *vconn)$/;"	f
rconn_connect	lib/rconn.cc	/^rconn_connect(struct rconn *rc, const char *name)$/;"	f
rconn_connect_unreliably	lib/rconn.cc	/^rconn_connect_unreliably(struct rconn *rc,$/;"	f
rconn_create	lib/rconn.cc	/^rconn_create(int probe_interval, int max_backoff)$/;"	f
rconn_destroy	lib/rconn.cc	/^rconn_destroy(struct rconn *rc)$/;"	f
rconn_disconnect	lib/rconn.cc	/^rconn_disconnect(struct rconn *rc)$/;"	f
rconn_failure_duration	lib/rconn.cc	/^rconn_failure_duration(const struct rconn *rconn)$/;"	f
rconn_get_attempted_connections	lib/rconn.cc	/^rconn_get_attempted_connections(const struct rconn *rc)$/;"	f
rconn_get_backoff	lib/rconn.cc	/^rconn_get_backoff(const struct rconn *rc)$/;"	f
rconn_get_connection_seqno	lib/rconn.cc	/^rconn_get_connection_seqno(const struct rconn *rc)$/;"	f
rconn_get_creation_time	lib/rconn.cc	/^rconn_get_creation_time(const struct rconn *rc)$/;"	f
rconn_get_ip	lib/rconn.cc	/^rconn_get_ip(const struct rconn *rconn) $/;"	f
rconn_get_last_connection	lib/rconn.cc	/^rconn_get_last_connection(const struct rconn *rc)$/;"	f
rconn_get_name	lib/rconn.cc	/^rconn_get_name(const struct rconn *rc)$/;"	f
rconn_get_state	lib/rconn.cc	/^rconn_get_state(const struct rconn *rc)$/;"	f
rconn_get_state_elapsed	lib/rconn.cc	/^rconn_get_state_elapsed(const struct rconn *rc)$/;"	f
rconn_get_successful_connections	lib/rconn.cc	/^rconn_get_successful_connections(const struct rconn *rc)$/;"	f
rconn_get_total_time_connected	lib/rconn.cc	/^rconn_get_total_time_connected(const struct rconn *rc)$/;"	f
rconn_is_alive	lib/rconn.cc	/^rconn_is_alive(const struct rconn *rconn)$/;"	f
rconn_is_connected	lib/rconn.cc	/^rconn_is_connected(const struct rconn *rconn)$/;"	f
rconn_is_connectivity_questionable	lib/rconn.cc	/^rconn_is_connectivity_questionable(struct rconn *rconn)$/;"	f
rconn_new	lib/rconn.cc	/^rconn_new(const char *name, int inactivity_probe_interval, int max_backoff)$/;"	f
rconn_new_from_vconn	lib/rconn.cc	/^rconn_new_from_vconn(const char *name, struct vconn *vconn) $/;"	f
rconn_packets_received	lib/rconn.cc	/^rconn_packets_received(const struct rconn *rc)$/;"	f
rconn_packets_sent	lib/rconn.cc	/^rconn_packets_sent(const struct rconn *rc)$/;"	f
rconn_recv	lib/rconn.cc	/^rconn_recv(struct rconn *rc)$/;"	f
rconn_recv_wait	lib/rconn.cc	/^rconn_recv_wait(struct rconn *rc)$/;"	f
rconn_remote	RConn.hh	/^struct rconn_remote {$/;"	s
rconn_run	lib/rconn.cc	/^rconn_run(struct rconn *rc)$/;"	f
rconn_run_wait	lib/rconn.cc	/^rconn_run_wait(struct rconn *rc)$/;"	f
rconn_send	lib/rconn.cc	/^int rconn_send(struct rconn *rc, struct ofpbuf *b, int *n_queued)$/;"	f
rconn_send_error_msg	RConn.cc	/^static void rconn_send_error_msg(class RConn* rconnElement, struct rconn_remote *sender, uint32_t xid,$/;"	f	file:
rconn_send_with_limit	lib/rconn.cc	/^int rconn_send_with_limit(struct rconn *rc, struct ofpbuf *b,$/;"	f
rconn_stat	RConn.hh	/^struct rconn_stat {$/;"	s
rconn_update_protocol_stat	lib/rconn.cc	/^rconn_update_protocol_stat(struct rconn *rconn,$/;"	f
read_cert_file	lib/vconn-ssl.cc	/^read_cert_file(const char *file_name, X509 ***certs, size_t *n_certs)$/;"	f	file:
reason	include/openflow/nicira-ext.hh	/^    uint8_t reason;           \/* One of NXFER_*. *\/$/;"	m	struct:nx_flow_end
reason	include/openflow/openflow.hh	/^    uint8_t reason;           \/* One of OFPRR_*. *\/$/;"	m	struct:ofp_flow_removed
reason	include/openflow/openflow.hh	/^    uint8_t reason;          \/* One of OFPPR_*. *\/$/;"	m	struct:ofp_port_status
reason	include/openflow/openflow.hh	/^    uint8_t reason;         \/* Reason packet is being sent (one of OFPR_*) *\/$/;"	m	struct:ofp_packet_in
reason	lib/switch-flow.hh	/^    uint8_t reason;             \/* Reason flow removed (one of OFPRR_*). *\/$/;"	m	struct:sw_flow
recalc_csum16	lib/csum.cc	/^recalc_csum16(uint16_t old_csum, uint16_t old_u16, uint16_t new_u16)$/;"	f
recalc_csum32	lib/csum.cc	/^recalc_csum32(uint16_t old_csum, uint32_t old_u32, uint32_t new_u32)$/;"	f
reconnect	lib/rconn.cc	/^reconnect(struct rconn *rc)$/;"	f	file:
reconnectable	lib/vconn-provider.hh	/^    bool reconnectable;$/;"	m	struct:vconn
recv	lib/vconn-provider.hh	/^    int (*recv)(struct vconn *vconn, struct ofpbuf **msgp);$/;"	m	struct:vconn_class
recv_barrier_request	RConn.cc	/^static int recv_barrier_request(class RConn *rconnElement, struct rconn_remote *sender, uint32_t xid, const void *ofph)$/;"	f	file:
recv_echo_reply	RConn.cc	/^static int recv_echo_reply(class RConn *rconn UNUSED, struct rconn_remote *sender UNUSED, uint32_t xid UNUSED,$/;"	f	file:
recv_echo_request	RConn.cc	/^static int recv_echo_request(class RConn *rconnElement, struct rconn_remote *sender, uint32_t xid, const void *oh)$/;"	f	file:
recv_features_request	datapath.cc	/^int Datapath::recv_features_request(struct rconn_remote *rconn_sender, uint32_t xid, const void *msg UNUSED)$/;"	f	class:Datapath
recv_flow	datapath.cc	/^int Datapath::recv_flow(struct rconn_remote *rconn_sender, uint32_t xid, const void *msg)$/;"	f	class:Datapath
recv_get_config_request	datapath.cc	/^int Datapath::recv_get_config_request(struct rconn_remote *rconn_sender, uint32_t xid,	const void *msg UNUSED)$/;"	f	class:Datapath
recv_of_exp_queue_delete	lib/of_ext_msg.cc	/^static void recv_of_exp_queue_delete(class Datapath *dp UNUSED,$/;"	f	file:
recv_of_exp_queue_modify	lib/of_ext_msg.cc	/^recv_of_exp_queue_modify(class Datapath *dp UNUSED,$/;"	f	file:
recv_of_set_dp_desc	lib/of_ext_msg.cc	/^recv_of_set_dp_desc(class Datapath *dp,$/;"	f	file:
recv_packet_out	datapath.cc	/^int Datapath::recv_packet_out(struct rconn_remote *rconn_sender, uint32_t xid UNUSED, const void *msg)$/;"	f	class:Datapath
recv_port_mod	datapath.cc	/^int Datapath::recv_port_mod(struct rconn_remote *rconn_sender UNUSED, uint32_t xid UNUSED, const void *msg)$/;"	f	class:Datapath
recv_queue_get_config_request	datapath.cc	/^int Datapath::recv_queue_get_config_request(struct rconn_remote *rconn_sender, uint32_t xid, const void *oh)$/;"	f	class:Datapath
recv_set_config	datapath.cc	/^int Datapath::recv_set_config(struct rconn_remote *rconn_sender UNUSED, uint32_t xid UNUSED, const void *msg)$/;"	f	class:Datapath
recv_stats_request	datapath.cc	/^int Datapath::recv_stats_request(struct rconn_remote *rconn_sender, uint32_t xid, const void *oh)$/;"	f	class:Datapath
recv_vendor	datapath.cc	/^int Datapath::recv_vendor(struct rconn_remote *rconn_sender, uint32_t xid UNUSED, const void *oh)$/;"	f	class:Datapath
recv_with_creds	lib/vlog-socket.cc	/^recv_with_creds(const struct vlog_server *server,$/;"	f	file:
refresh_if_ticked	lib/timeval.cc	/^refresh_if_ticked(void)$/;"	f	file:
reliable	lib/rconn.cc	/^    bool reliable;$/;"	m	struct:rconn	file:
remote_create	RConn.cc	/^static struct rconn_remote * remote_create(class RConn *rconnElement, struct rconn *rconn)$/;"	f	file:
remote_destroy	RConn.cc	/^static void remote_destroy(struct rconn_remote *r)$/;"	f	file:
remote_run	RConn.cc	/^static void remote_run(class RConn *rconnElement, struct rconn_remote *r)$/;"	f	file:
remote_wait	RConn.cc	/^static void remote_wait(struct rconn_remote *r)$/;"	f	file:
remotes	RConn.hh	/^        struct list remotes;        \/* All connections (including controller). *\/$/;"	m	class:RConn	typeref:struct:RConn::list
report_stat	RConn.cc	/^void RConn::report_stat()$/;"	f	class:RConn
report_timer	RConn.hh	/^        Timer report_timer;$/;"	m	class:RConn
reserved	lib/netlink-protocol.hh	/^    uint16_t reserved;$/;"	m	struct:genlmsghdr
retrieve_buffer	datapath.cc	/^struct ofpbuf *DatapathPacketBuffer::retrieve_buffer(uint32_t id)$/;"	f	class:DatapathPacketBuffer
rl	lib/dpif.cc	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 60);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	lib/netlink.cc	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(60, 600);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	lib/vconn-ssl.cc	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(10, 25);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	lib/vconn-stream.cc	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(10, 25);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	lib/vconn.cc	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(600, 600);$/;"	v	typeref:struct:vlog_rate_limit	file:
rnc	RConn.hh	/^        struct		rnc_param rnc;$/;"	m	class:RConn	typeref:struct:RConn::rnc_param
rnc_param	RConn.hh	/^struct rnc_param {$/;"	s
root_id	lib/stp.cc	/^    uint64_t root_id;              \/* 8.5.1.1: Bridge believed to be root. *\/$/;"	m	struct:stp_config_bpdu	file:
root_path_cost	lib/stp.cc	/^    uint32_t root_path_cost;       \/* 8.5.1.2: Cost of path to root. *\/$/;"	m	struct:stp_config_bpdu	file:
root_path_cost	lib/stp.cc	/^    unsigned int root_path_cost;    \/* 8.5.3.2: Cost of path to root. *\/$/;"	m	struct:stp	file:
root_port	lib/stp.cc	/^    struct stp_port *root_port;     \/* 8.5.3.3: Lowest cost port to root. *\/$/;"	m	struct:stp	typeref:struct:stp::stp_port	file:
rot	lib/hash.cc	39;"	d	file:
rq	datapath.cc	/^	struct ofp_aggregate_stats_request rq;$/;"	m	struct:aggregate_stats_state	typeref:struct:aggregate_stats_state::ofp_aggregate_stats_request	file:
rq	datapath.cc	/^	struct ofp_flow_stats_request rq;$/;"	m	struct:flow_stats_state	typeref:struct:flow_stats_state::ofp_flow_stats_request	file:
rq	datapath.cc	/^	struct ofp_stats_request *rq;$/;"	m	struct:stats_dump_cb	typeref:struct:stats_dump_cb::ofp_stats_request	file:
rq_forward_delay	lib/stp.cc	/^    int rq_forward_delay;           \/* User-requested forward delay, in ms. *\/$/;"	m	struct:stp	file:
rq_hello_time	lib/stp.cc	/^    int rq_hello_time;              \/* User-requested hello time, in ms. *\/$/;"	m	struct:stp	file:
rq_max_age	lib/stp.cc	/^    int rq_max_age;                 \/* User-requested max age, in ms. *\/$/;"	m	struct:stp	file:
rstat	RConn.hh	/^	struct rconn_stat rstat;$/;"	m	class:RConn	typeref:struct:RConn::rconn_stat
run_ACTIVE	lib/rconn.cc	/^static void run_ACTIVE(struct rconn *rc)$/;"	f	file:
run_BACKOFF	lib/rconn.cc	/^run_BACKOFF(struct rconn *rc)$/;"	f	file:
run_CONNECTING	lib/rconn.cc	/^run_CONNECTING(struct rconn *rc)$/;"	f	file:
run_IDLE	lib/rconn.cc	/^run_IDLE(struct rconn *rc)$/;"	f	file:
run_VOID	lib/rconn.cc	/^run_VOID(struct rconn *rc UNUSED)$/;"	f	file:
run_at_exit	lib/fatal-signal.cc	/^    bool run_at_exit;$/;"	m	struct:hook	file:
run_flow_through_tables	datapath.cc	/^int Datapath::run_flow_through_tables(struct ofpbuf *buffer, struct click_port *p)$/;"	f	class:Datapath
run_timer	RConn.cc	/^void RConn::run_timer(Timer* t)$/;"	f	class:RConn
run_timer	datapath.cc	/^void Datapath::run_timer(Timer* t)$/;"	f	class:Datapath
running_cb	lib/poll-loop.cc	/^static struct poll_waiter *running_cb;$/;"	v	typeref:struct:poll_waiter	file:
rx_bytes	datapath.hh	/^	unsigned long long int rx_bytes, tx_bytes;$/;"	m	struct:click_port
rx_bytes	include/openflow/openflow.hh	/^    uint64_t rx_bytes;       \/* Number of received bytes. *\/$/;"	m	struct:ofp_port_stats
rx_crc_err	include/openflow/openflow.hh	/^    uint64_t rx_crc_err;     \/* Number of CRC errors. *\/$/;"	m	struct:ofp_port_stats
rx_dropped	include/openflow/openflow.hh	/^    uint64_t rx_dropped;     \/* Number of packets dropped by RX. *\/$/;"	m	struct:ofp_port_stats
rx_errors	include/openflow/openflow.hh	/^    uint64_t rx_errors;      \/* Number of receive errors.  This is a super-set$/;"	m	struct:ofp_port_stats
rx_frame_err	include/openflow/openflow.hh	/^    uint64_t rx_frame_err;   \/* Number of frame alignment errors. *\/$/;"	m	struct:ofp_port_stats
rx_over_err	include/openflow/openflow.hh	/^    uint64_t rx_over_err;    \/* Number of packets with RX overrun. *\/$/;"	m	struct:ofp_port_stats
rx_packets	datapath.hh	/^	unsigned long long int rx_packets, tx_packets;$/;"	m	struct:click_port
rx_packets	include/openflow/openflow.hh	/^    uint64_t rx_packets;     \/* Number of received packets. *\/$/;"	m	struct:ofp_port_stats
rx_want	lib/vconn-ssl.cc	/^    int rx_want, tx_want;$/;"	m	struct:ssl_vconn	file:
rxbuf	lib/vconn-ssl.cc	/^    struct ofpbuf *rxbuf;$/;"	m	struct:ssl_vconn	typeref:struct:ssl_vconn::ofpbuf	file:
rxbuf	lib/vconn-stream.cc	/^    struct ofpbuf *rxbuf;$/;"	m	struct:stream_vconn	typeref:struct:stream_vconn::ofpbuf	file:
s	datapath.cc	/^	const struct stats_type *s;$/;"	m	struct:stats_dump_cb	typeref:struct:stats_dump_cb::stats_type	file:
sat_add	lib/sat-math.hh	/^sat_add(unsigned int x, unsigned int y)$/;"	f
sat_mul	lib/sat-math.hh	/^sat_mul(unsigned int x, unsigned int y)$/;"	f
sat_sub	lib/sat-math.hh	/^sat_sub(unsigned int x, unsigned int y)$/;"	f
save_buffer	datapath.cc	/^uint32_t DatapathPacketBuffer::save_buffer(struct ofpbuf *buffer)$/;"	f	class:DatapathPacketBuffer
saved_signal_mask	lib/fatal-signal.cc	/^static sigset_t saved_signal_mask;$/;"	v	file:
search_name_array	lib/vlog.cc	/^search_name_array(const char *target, const char **names, size_t n_names) $/;"	f	file:
sem_waiters	lib/poll-loop.cc	/^sem_t sem_waiters;$/;"	v
send	lib/vconn-provider.hh	/^    int (*send)(struct vconn *vconn, struct ofpbuf *msg);$/;"	m	struct:vconn_class
send_bpdu	lib/stp.cc	/^    void (*send_bpdu)(struct ofpbuf *bpdu, int port_no, void *aux);$/;"	m	struct:stp	file:
send_control_packets_to_click	RConn.cc	/^void RConn::send_control_packets_to_click()$/;"	f	class:RConn
send_flow_exp	include/openflow/nicira-ext.hh	/^    uint8_t send_flow_exp;    \/* Send flow expiry to controller. *\/$/;"	m	struct:nx_flow_end
send_flow_rem	lib/switch-flow.hh	/^    uint8_t send_flow_rem;      \/* Send a flow removed to the controller *\/$/;"	m	struct:sw_flow
send_mgmt_command	lib/dpif.cc	/^send_mgmt_command(struct dpif *dp, int dp_idx, int command, const char *arg)$/;"	f	file:
send_openflow_buffer	RConn.cc	/^static int send_openflow_buffer(class RConn *rconnElement, struct ofpbuf *buffer, struct rconn_remote *sender, uint32_t xid UNUSED)$/;"	f	file:
send_openflow_buffer	RConn.cc	/^void RConn::send_openflow_buffer(struct ofpbuf *buffer, struct rconn_remote *rconn_sender, uint32_t xid)$/;"	f	class:RConn
send_openflow_buffer	datapath.cc	/^int Datapath::send_openflow_buffer(struct ofpbuf *buffer, struct rconn_remote *rconn_sender, uint32_t xid )$/;"	f	class:Datapath
send_openflow_buffer_to_remote	RConn.cc	/^static int send_openflow_buffer_to_remote(struct ofpbuf *buffer, struct rconn_remote *remote)$/;"	f	file:
send_port_status	datapath.cc	/^void Datapath::send_port_status(struct click_port *p, uint8_t status)$/;"	f	class:Datapath
send_timer	RConn.hh	/^        Timer send_timer;$/;"	m	class:RConn
sender	SynchronizedPacketQueue.hh	/^	struct rconn_remote *sender;$/;"	m	struct:buf_rconn	typeref:struct:buf_rconn::rconn_remote
sender	datapath.cc	/^	struct rconn_remote *sender;$/;"	m	struct:stats_dump_cb	typeref:struct:stats_dump_cb::rconn_remote	file:
seqno	lib/rconn.cc	/^    unsigned int seqno;$/;"	m	struct:rconn	file:
serial	lib/switch-flow.hh	/^    unsigned long int serial;$/;"	m	struct:sw_flow
serial_num	include/openflow/openflow.hh	/^    char serial_num[SERIAL_NUM_LEN];   \/* Serial number. *\/$/;"	m	struct:ofp_desc_stats
session_type	lib/vconn-ssl.cc	/^enum session_type {$/;"	g	file:
set_bridge_id	lib/stp.cc	/^set_bridge_id(struct stp *stp, stp_identifier new_bridge_id)$/;"	f	file:
set_dl_addr	lib/dp_act.cc	/^set_dl_addr(struct ofpbuf *buffer, struct sw_flow_key *key UNUSED, $/;"	f	file:
set_facility_level	lib/vlog.cc	/^set_facility_level(enum vlog_facility facility, enum vlog_module module,$/;"	f	file:
set_nonblocking	lib/socket-util.cc	/^set_nonblocking(int fd)$/;"	f
set_nw_addr	lib/dp_act.cc	/^set_nw_addr(struct ofpbuf *buffer, struct sw_flow_key *key, $/;"	f	file:
set_nw_tos	lib/dp_act.cc	/^set_nw_tos(struct ofpbuf *buffer, struct sw_flow_key *key, $/;"	f	file:
set_program_name	lib/util.cc	/^void set_program_name(const char *argv0)$/;"	f
set_socket_priority	lib/socket-util.cc	/^set_socket_priority(int fd, int priority)$/;"	f
set_tp_port	lib/dp_act.cc	/^set_tp_port(struct ofpbuf *buffer, struct sw_flow_key *key, $/;"	f	file:
set_vlan_pcp	lib/dp_act.cc	/^set_vlan_pcp(struct ofpbuf *buffer, struct sw_flow_key *key, $/;"	f	file:
set_vlan_vid	lib/dp_act.cc	/^set_vlan_vid(struct ofpbuf *buffer, struct sw_flow_key *key, $/;"	f	file:
sf_acts	lib/switch-flow.hh	/^    struct sw_flow_actions *sf_acts;$/;"	m	struct:sw_flow	typeref:struct:sw_flow::sw_flow_actions
show_queue_get_config_reply	lib/ofp-print.cc	/^show_queue_get_config_reply(struct ds *string, const void *oh,$/;"	f	file:
show_queue_props	lib/ofp-print.cc	/^show_queue_props(struct ds *string, const struct ofp_packet_queue *queue_desc)$/;"	f	file:
sigalrm_handler	lib/timeval.cc	/^sigalrm_handler(int sig_nr)$/;"	f	file:
sigfigs	lib/pcap.cc	/^    uint32_t sigfigs;        \/* accuracy of timestamps *\/$/;"	m	struct:pcap_hdr	file:
size	lib/ofpbuf.hh	/^    size_t size;                \/* Number of bytes in use. *\/$/;"	m	struct:ofpbuf
sizeof	include/openflow/nicira-ext.hh	/^OFP_ASSERT(sizeof(struct nicira_header) == sizeof(struct ofp_vendor_header) + 4);$/;"	v
snap	lib/packets.hh	/^    struct snap_header snap;$/;"	m	struct:llc_snap_header	typeref:struct:llc_snap_header::snap_header
snap_header	lib/packets.hh	/^struct snap_header {$/;"	s
snap_org	lib/packets.hh	/^    uint8_t snap_org[3];$/;"	m	struct:snap_header
snap_type	lib/packets.hh	/^    uint16_t snap_type;$/;"	m	struct:snap_header
snaplen	lib/pcap.cc	/^    uint32_t snaplen;        \/* max length of captured packets *\/$/;"	m	struct:pcap_hdr	file:
snat	include/openflow/nicira-ext.hh	/^        struct nx_snat_config snat[0];$/;"	m	union:nx_act_config::__anon1	typeref:struct:nx_act_config::__anon1::nx_snat_config
sock	lib/dpif.hh	/^    struct nl_sock *sock;$/;"	m	struct:dpif	typeref:struct:dpif::nl_sock
sockaddr_nl	lib/netlink-protocol.hh	/^struct sockaddr_nl {$/;"	s
speed	datapath.hh	/^	uint32_t speed;$/;"	m	struct:click_port
ssl	lib/vconn-ssl.cc	/^    SSL *ssl;$/;"	m	struct:ssl_vconn	file:
ssl_clear_txbuf	lib/vconn-ssl.cc	/^ssl_clear_txbuf(struct ssl_vconn *sslv)$/;"	f	file:
ssl_close	lib/vconn-ssl.cc	/^ssl_close(struct vconn *vconn)$/;"	f	file:
ssl_connect	lib/vconn-ssl.cc	/^ssl_connect(struct vconn *vconn)$/;"	f	file:
ssl_do_tx	lib/vconn-ssl.cc	/^ssl_do_tx(struct vconn *vconn)$/;"	f	file:
ssl_init	lib/vconn-ssl.cc	/^ssl_init(void)$/;"	f	file:
ssl_open	lib/vconn-ssl.cc	/^ssl_open(const char *name, char *suffix, struct vconn **vconnp)$/;"	f	file:
ssl_recv	lib/vconn-ssl.cc	/^ssl_recv(struct vconn *vconn, struct ofpbuf **bufferp)$/;"	f	file:
ssl_register_tx_waiter	lib/vconn-ssl.cc	/^ssl_register_tx_waiter(struct vconn *vconn)$/;"	f	file:
ssl_send	lib/vconn-ssl.cc	/^ssl_send(struct vconn *vconn, struct ofpbuf *buffer)$/;"	f	file:
ssl_state	lib/vconn-ssl.cc	/^enum ssl_state {$/;"	g	file:
ssl_tx_poll_callback	lib/vconn-ssl.cc	/^ssl_tx_poll_callback(int fd UNUSED, short int revents UNUSED, void *vconn_)$/;"	f	file:
ssl_vconn	lib/vconn-ssl.cc	/^struct ssl_vconn$/;"	s	file:
ssl_vconn_cast	lib/vconn-ssl.cc	/^ssl_vconn_cast(struct vconn *vconn)$/;"	f	file:
ssl_vconn_class	lib/vconn-ssl.cc	/^struct vconn_class ssl_vconn_class = {$/;"	v	typeref:struct:vconn_class
ssl_wait	lib/vconn-ssl.cc	/^ssl_wait(struct vconn *vconn, enum vconn_wait_type wait)$/;"	f	file:
ssl_wants_io	lib/vconn-ssl.cc	/^ssl_wants_io(int ssl_error)$/;"	f	file:
start_port	datapath.cc	/^	int start_port;	\/* port to start dumping from *\/$/;"	m	struct:port_stats_state	file:
stat_control_in	RConn.hh	/^	uint32_t stat_control_in;$/;"	m	struct:rconn_stat
stat_control_out	RConn.hh	/^	uint32_t stat_control_out;$/;"	m	struct:rconn_stat
stat_ewma_avg_queue_len	RConn.hh	/^	double	stat_ewma_avg_queue_len;$/;"	m	struct:rconn_stat
stat_ewma_dev_queue_len	RConn.hh	/^	double 	stat_ewma_dev_queue_len;$/;"	m	struct:rconn_stat
stat_queue_drop	RConn.hh	/^	uint32_t stat_queue_drop;$/;"	m	struct:rconn_stat
stat_queue_len	RConn.hh	/^	uint32_t stat_queue_len;$/;"	m	struct:rconn_stat
stat_total_control_in	RConn.hh	/^	uint32_t stat_total_control_in;$/;"	m	struct:rconn_stat
stat_total_control_out	RConn.hh	/^	uint32_t stat_total_control_out;$/;"	m	struct:rconn_stat
stat_total_queue_drop	RConn.hh	/^	uint32_t stat_total_queue_drop;$/;"	m	struct:rconn_stat
state	datapath.cc	/^	void *state;$/;"	m	struct:stats_dump_cb	file:
state	datapath.hh	/^	uint32_t state;             \/* Some subset of OFPPS_* flags. *\/$/;"	m	struct:click_port
state	include/openflow/openflow.hh	/^    uint32_t state;         \/* Bitmap of OFPPS_* flags. *\/$/;"	m	struct:ofp_phy_port
state	lib/rconn.cc	/^    enum state state;$/;"	m	struct:rconn	typeref:enum:rconn::state	file:
state	lib/rconn.cc	/^enum state {$/;"	g	file:
state	lib/stp.cc	/^    enum stp_state state;           \/* 8.5.5.2: Current state. *\/$/;"	m	struct:stp_port	typeref:enum:stp_port::stp_state	file:
state	lib/vconn-provider.hh	/^    int state;$/;"	m	struct:vconn
state	lib/vconn-ssl.cc	/^    enum ssl_state state;$/;"	m	struct:ssl_vconn	typeref:enum:ssl_vconn::ssl_state	file:
state_changed	lib/stp.cc	/^    bool state_changed;$/;"	m	struct:stp_port	file:
state_entered	lib/rconn.cc	/^    time_t state_entered;$/;"	m	struct:rconn	file:
state_name	lib/rconn.cc	/^state_name(enum state state)$/;"	f	file:
state_transition	lib/rconn.cc	/^state_transition(struct rconn *rc, enum state state)$/;"	f	file:
stats	datapath.cc	/^static const struct stats_type stats[] = {$/;"	v	typeref:struct:stats_type	file:
stats	lib/table.hh	/^    void (*stats)(struct sw_table *table, struct sw_table_stats *stats);$/;"	m	struct:sw_table
stats_direction	lib/ofp-print.cc	/^enum stats_direction {$/;"	g	file:
stats_done	datapath.cc	/^static void stats_done(void *cb_)$/;"	f	file:
stats_dump	datapath.cc	/^static int stats_dump(class Datapath *dp, void *cb_)$/;"	f	file:
stats_dump_cb	datapath.cc	/^struct stats_dump_cb {$/;"	s	file:
stats_type	datapath.cc	/^struct stats_type {$/;"	s	file:
status	include/openflow/nicira-ext.hh	/^    uint32_t status;            \/* Status bits defined above. *\/$/;"	m	struct:nx_command_reply
stp	lib/stp.cc	/^    struct stp *stp;$/;"	m	struct:stp_port	typeref:struct:stp_port::stp	file:
stp	lib/stp.cc	/^struct stp {$/;"	s	file:
stp_acknowledge_topology_change	lib/stp.cc	/^stp_acknowledge_topology_change(struct stp_port *p)$/;"	f	file:
stp_become_designated_port	lib/stp.cc	/^stp_become_designated_port(struct stp_port *p)$/;"	f	file:
stp_become_root_bridge	lib/stp.cc	/^stp_become_root_bridge(struct stp *stp)$/;"	f	file:
stp_bpdu_header	lib/stp.cc	/^struct stp_bpdu_header {$/;"	s	file:
stp_config_bpdu	lib/stp.cc	/^struct stp_config_bpdu {$/;"	s	file:
stp_config_bpdu_flags	lib/stp.cc	/^enum stp_config_bpdu_flags {$/;"	g	file:
stp_config_bpdu_generation	lib/stp.cc	/^stp_config_bpdu_generation(struct stp *stp)$/;"	f	file:
stp_configuration_update	lib/stp.cc	/^stp_configuration_update(struct stp *stp)$/;"	f	file:
stp_create	lib/stp.cc	/^stp_create(const char *name, stp_identifier bridge_id,$/;"	f
stp_designated_port_selection	lib/stp.cc	/^stp_designated_port_selection(struct stp *stp)$/;"	f	file:
stp_destroy	lib/stp.cc	/^stp_destroy(struct stp *stp)$/;"	f
stp_eth_addr	lib/stp.cc	/^const uint8_t stp_eth_addr[ETH_ADDR_LEN]$/;"	v
stp_forward_delay_timer_expiry	lib/stp.cc	/^stp_forward_delay_timer_expiry(struct stp_port *p)$/;"	f	file:
stp_forward_in_state	lib/stp.cc	/^stp_forward_in_state(enum stp_state state)$/;"	f
stp_get_bridge_id	lib/stp.cc	/^stp_get_bridge_id(const struct stp *stp)$/;"	f
stp_get_changed_port	lib/stp.cc	/^stp_get_changed_port(struct stp *stp, struct stp_port **portp)$/;"	f
stp_get_designated_root	lib/stp.cc	/^stp_get_designated_root(const struct stp *stp)$/;"	f
stp_get_forward_delay	lib/stp.cc	/^stp_get_forward_delay(const struct stp *stp)$/;"	f
stp_get_hello_time	lib/stp.cc	/^stp_get_hello_time(const struct stp *stp)$/;"	f
stp_get_max_age	lib/stp.cc	/^stp_get_max_age(const struct stp *stp)$/;"	f
stp_get_name	lib/stp.cc	/^stp_get_name(const struct stp *stp)$/;"	f
stp_get_port	lib/stp.cc	/^stp_get_port(struct stp *stp, int port_no)$/;"	f
stp_get_root_path_cost	lib/stp.cc	/^stp_get_root_path_cost(const struct stp *stp)$/;"	f
stp_get_root_port	lib/stp.cc	/^stp_get_root_port(struct stp *stp)$/;"	f
stp_hello_timer_expiry	lib/stp.cc	/^stp_hello_timer_expiry(struct stp *stp)$/;"	f	file:
stp_hold_timer_expiry	lib/stp.cc	/^stp_hold_timer_expiry(struct stp_port *p)$/;"	f	file:
stp_identifier	lib/stp.hh	/^typedef uint64_t stp_identifier;$/;"	t
stp_initialize_port	lib/stp.cc	/^stp_initialize_port(struct stp_port *p, enum stp_state state)$/;"	f	file:
stp_is_designated_for_some_port	lib/stp.cc	/^stp_is_designated_for_some_port(const struct stp *stp)$/;"	f	file:
stp_is_designated_port	lib/stp.cc	/^stp_is_designated_port(const struct stp_port *p)$/;"	f	file:
stp_is_root_bridge	lib/stp.cc	/^stp_is_root_bridge(const struct stp *stp)$/;"	f
stp_learn_in_state	lib/stp.cc	/^stp_learn_in_state(enum stp_state state)$/;"	f
stp_make_blocking	lib/stp.cc	/^stp_make_blocking(struct stp_port *p)$/;"	f	file:
stp_make_forwarding	lib/stp.cc	/^stp_make_forwarding(struct stp_port *p)$/;"	f	file:
stp_message_age_timer_expiry	lib/stp.cc	/^stp_message_age_timer_expiry(struct stp_port *p)$/;"	f	file:
stp_next_enabled_port	lib/stp.cc	/^stp_next_enabled_port(const struct stp *stp, const struct stp_port *port)$/;"	f	file:
stp_port	lib/stp.cc	/^struct stp_port {$/;"	s	file:
stp_port_disable	lib/stp.cc	/^stp_port_disable(struct stp_port *p)$/;"	f
stp_port_disable_change_detection	lib/stp.cc	/^stp_port_disable_change_detection(struct stp_port *p)$/;"	f
stp_port_enable	lib/stp.cc	/^stp_port_enable(struct stp_port *p)$/;"	f
stp_port_enable_change_detection	lib/stp.cc	/^stp_port_enable_change_detection(struct stp_port *p)$/;"	f
stp_port_get_state	lib/stp.cc	/^stp_port_get_state(const struct stp_port *p)$/;"	f
stp_port_get_stp	lib/stp.cc	/^stp_port_get_stp(struct stp_port *p)$/;"	f
stp_port_no	lib/stp.cc	/^stp_port_no(const struct stp_port *p)$/;"	f
stp_port_set_path_cost	lib/stp.cc	/^stp_port_set_path_cost(struct stp_port *p, uint16_t path_cost)$/;"	f
stp_port_set_priority	lib/stp.cc	/^stp_port_set_priority(struct stp_port *p, uint8_t new_priority)$/;"	f
stp_port_set_speed	lib/stp.cc	/^stp_port_set_speed(struct stp_port *p, unsigned int speed)$/;"	f
stp_port_state_selection	lib/stp.cc	/^stp_port_state_selection(struct stp *stp)$/;"	f	file:
stp_received_bpdu	lib/stp.cc	/^stp_received_bpdu(struct stp_port *p, const void *bpdu, size_t bpdu_size)$/;"	f
stp_received_config_bpdu	lib/stp.cc	/^stp_received_config_bpdu(struct stp *stp, struct stp_port *p,$/;"	f
stp_received_tcn_bpdu	lib/stp.cc	/^stp_received_tcn_bpdu(struct stp *stp, struct stp_port *p)$/;"	f
stp_record_config_information	lib/stp.cc	/^stp_record_config_information(struct stp_port *p,$/;"	f	file:
stp_record_config_timeout_values	lib/stp.cc	/^stp_record_config_timeout_values(struct stp *stp,$/;"	f	file:
stp_root_selection	lib/stp.cc	/^stp_root_selection(struct stp *stp)$/;"	f	file:
stp_send_bpdu	lib/stp.cc	/^stp_send_bpdu(struct stp_port *p, const void *bpdu, size_t bpdu_size)$/;"	f	file:
stp_set_bridge_id	lib/stp.cc	/^stp_set_bridge_id(struct stp *stp, stp_identifier bridge_id)$/;"	f
stp_set_bridge_priority	lib/stp.cc	/^stp_set_bridge_priority(struct stp *stp, uint16_t new_priority)$/;"	f
stp_set_forward_delay	lib/stp.cc	/^stp_set_forward_delay(struct stp *stp, int ms)$/;"	f
stp_set_hello_time	lib/stp.cc	/^stp_set_hello_time(struct stp *stp, int ms)$/;"	f
stp_set_max_age	lib/stp.cc	/^stp_set_max_age(struct stp *stp, int ms)$/;"	f
stp_set_port_state	lib/stp.cc	/^stp_set_port_state(struct stp_port *p, enum stp_state state)$/;"	f	file:
stp_start_timer	lib/stp.cc	/^stp_start_timer(struct stp_timer *timer, int value)$/;"	f	file:
stp_state	lib/stp.hh	/^enum stp_state {$/;"	g
stp_state_name	lib/stp.cc	/^stp_state_name(enum stp_state state)$/;"	f
stp_stop_timer	lib/stp.cc	/^stp_stop_timer(struct stp_timer *timer)$/;"	f	file:
stp_supersedes_port_info	lib/stp.cc	/^stp_supersedes_port_info(const struct stp_port *p,$/;"	f	file:
stp_supersedes_root	lib/stp.cc	/^stp_supersedes_root(const struct stp_port *root, const struct stp_port *p)$/;"	f	file:
stp_tcn_bpdu	lib/stp.cc	/^struct stp_tcn_bpdu {$/;"	s	file:
stp_tcn_timer_expiry	lib/stp.cc	/^stp_tcn_timer_expiry(struct stp *stp)$/;"	f	file:
stp_tick	lib/stp.cc	/^stp_tick(struct stp *stp, int ms)$/;"	f
stp_timer	lib/stp.cc	/^struct stp_timer {$/;"	s	file:
stp_timer_expired	lib/stp.cc	/^stp_timer_expired(struct stp_timer *timer, int elapsed, int timeout)$/;"	f	file:
stp_topology_change_acknowledged	lib/stp.cc	/^stp_topology_change_acknowledged(struct stp *stp)$/;"	f	file:
stp_topology_change_detection	lib/stp.cc	/^stp_topology_change_detection(struct stp *stp)$/;"	f	file:
stp_topology_change_timer_expiry	lib/stp.cc	/^stp_topology_change_timer_expiry(struct stp *stp)$/;"	f	file:
stp_transmit_config	lib/stp.cc	/^stp_transmit_config(struct stp_port *p)$/;"	f	file:
stp_transmit_tcn	lib/stp.cc	/^stp_transmit_tcn(struct stp *stp)$/;"	f	file:
stp_update_bridge_timers	lib/stp.cc	/^stp_update_bridge_timers(struct stp *stp)$/;"	f	file:
str_to_int	lib/util.cc	/^str_to_int(const char *s, int base, int *i)$/;"	f
str_to_llong	lib/util.cc	/^str_to_llong(const char *s, int base, long long *x)$/;"	f
str_to_long	lib/util.cc	/^str_to_long(const char *s, int base, long *li)$/;"	f
str_to_uint	lib/util.cc	/^str_to_uint(const char *s, int base, unsigned int *u)$/;"	f
str_to_ullong	lib/util.cc	/^str_to_ullong(const char *s, int base, unsigned long long *ull)$/;"	f
str_to_ulong	lib/util.cc	/^str_to_ulong(const char *s, int base, unsigned long *ul)$/;"	f
stream_clear_txbuf	lib/vconn-stream.cc	/^stream_clear_txbuf(struct stream_vconn *s)$/;"	f	file:
stream_close	lib/vconn-stream.cc	/^stream_close(struct vconn *vconn)$/;"	f	file:
stream_connect	lib/vconn-stream.cc	/^stream_connect(struct vconn *vconn)$/;"	f	file:
stream_do_tx	lib/vconn-stream.cc	/^stream_do_tx(int fd UNUSED, short int revents UNUSED, void *vconn_)$/;"	f	file:
stream_recv	lib/vconn-stream.cc	/^stream_recv(struct vconn *vconn, struct ofpbuf **bufferp)$/;"	f	file:
stream_send	lib/vconn-stream.cc	/^static int stream_send(struct vconn *vconn, struct ofpbuf *buffer)$/;"	f	file:
stream_vconn	lib/vconn-stream.cc	/^struct stream_vconn$/;"	s	file:
stream_vconn_cast	lib/vconn-stream.cc	/^stream_vconn_cast(struct vconn *vconn)$/;"	f	file:
stream_vconn_class	lib/vconn-stream.cc	/^static struct vconn_class stream_vconn_class = {$/;"	v	typeref:struct:vconn_class	file:
stream_wait	lib/vconn-stream.cc	/^stream_wait(struct vconn *vconn, enum vconn_wait_type wait)$/;"	f	file:
string	lib/dynamic-string.hh	/^    char *string;       \/* Null-terminated string. *\/$/;"	m	struct:ds
strip_vlan	lib/dp_act.cc	/^strip_vlan(struct ofpbuf *buffer, struct sw_flow_key *key, $/;"	f	file:
strlcpy	lib/util.cc	/^strlcpy(char *dst, const char *src, size_t size)$/;"	f
subtable	lib/table-hash.cc	/^	struct sw_table *subtable[2];$/;"	m	struct:sw_table_hash2	typeref:struct:sw_table_hash2::sw_table	file:
subtype	include/openflow/nicira-ext.hh	/^    uint16_t subtype;               \/* NXAST_*. *\/$/;"	m	struct:nx_action_header
subtype	include/openflow/nicira-ext.hh	/^    uint16_t subtype;               \/* NXAST_SNAT. *\/$/;"	m	struct:nx_action_snat
subtype	include/openflow/nicira-ext.hh	/^    uint32_t subtype;           \/* One of NXT_* above. *\/$/;"	m	struct:nicira_header
subtype	include/openflow/openflow-ext.hh	/^    uint32_t subtype;           \/* One of ofp_extension_commands *\/$/;"	m	struct:ofp_extension_header
supported	datapath.hh	/^	uint32_t supported;$/;"	m	struct:click_port
supported	include/openflow/openflow.hh	/^    uint32_t supported;     \/* Features supported by the port. *\/$/;"	m	struct:ofp_phy_port
svec	lib/svec.hh	/^struct svec {$/;"	s
svec_add	lib/svec.cc	/^svec_add(struct svec *svec, const char *name)$/;"	f
svec_add_nocopy	lib/svec.cc	/^svec_add_nocopy(struct svec *svec, char *name)$/;"	f
svec_append	lib/svec.cc	/^svec_append(struct svec *svec, const struct svec *other)$/;"	f
svec_back	lib/svec.cc	/^svec_back(const struct svec *svec)$/;"	f
svec_clear	lib/svec.cc	/^svec_clear(struct svec *svec) $/;"	f
svec_contains	lib/svec.cc	/^svec_contains(const struct svec *svec, const char *name)$/;"	f
svec_destroy	lib/svec.cc	/^svec_destroy(struct svec *svec)$/;"	f
svec_diff	lib/svec.cc	/^svec_diff(const struct svec *a, const struct svec *b,$/;"	f
svec_equal	lib/svec.cc	/^svec_equal(const struct svec *a, const struct svec *b)$/;"	f
svec_expand	lib/svec.cc	/^svec_expand(struct svec *svec)$/;"	f	file:
svec_find	lib/svec.cc	/^svec_find(const struct svec *svec, const char *name)$/;"	f
svec_get_duplicate	lib/svec.cc	/^svec_get_duplicate(const struct svec *svec)$/;"	f
svec_init	lib/svec.cc	/^svec_init(struct svec *svec)$/;"	f
svec_is_sorted	lib/svec.cc	/^svec_is_sorted(const struct svec *svec)$/;"	f
svec_is_unique	lib/svec.cc	/^svec_is_unique(const struct svec *svec)$/;"	f
svec_join	lib/svec.cc	/^svec_join(const struct svec *svec, const char *delimiter)$/;"	f
svec_parse_words	lib/svec.cc	/^svec_parse_words(struct svec *svec, const char *words)$/;"	f
svec_pop_back	lib/svec.cc	/^svec_pop_back(struct svec *svec)$/;"	f
svec_print	lib/svec.cc	/^svec_print(const struct svec *svec, const char *title)$/;"	f
svec_sort	lib/svec.cc	/^svec_sort(struct svec *svec)$/;"	f
svec_sort_unique	lib/svec.cc	/^svec_sort_unique(struct svec *svec)$/;"	f
svec_swap	lib/svec.cc	/^svec_swap(struct svec *a, struct svec *b)$/;"	f
svec_terminate	lib/svec.cc	/^svec_terminate(struct svec *svec)$/;"	f
svec_unique	lib/svec.cc	/^svec_unique(struct svec *svec)$/;"	f
sw_chain	lib/chain.hh	/^struct sw_chain {$/;"	s
sw_desc	include/openflow/openflow.hh	/^    char sw_desc[DESC_STR_LEN];        \/* Software description. *\/$/;"	m	struct:ofp_desc_stats
sw_flow	lib/switch-flow.hh	/^struct sw_flow {$/;"	s
sw_flow_actions	lib/switch-flow.hh	/^struct sw_flow_actions {$/;"	s
sw_flow_key	lib/switch-flow.hh	/^struct sw_flow_key {$/;"	s
sw_queue	datapath.hh	/^struct sw_queue {$/;"	s
sw_table	lib/table.hh	/^struct sw_table {$/;"	s
sw_table_hash	lib/table-hash.cc	/^struct sw_table_hash {$/;"	s	file:
sw_table_hash2	lib/table-hash.cc	/^struct sw_table_hash2 {$/;"	s	file:
sw_table_linear	lib/table-linear.cc	/^struct sw_table_linear {$/;"	s	file:
sw_table_position	lib/table.hh	/^struct sw_table_position {$/;"	s
sw_table_stats	lib/table.hh	/^struct sw_table_stats {$/;"	s
swt	lib/table-hash.cc	/^	struct sw_table swt;$/;"	m	struct:sw_table_hash	typeref:struct:sw_table_hash::sw_table	file:
swt	lib/table-hash.cc	/^	struct sw_table swt;$/;"	m	struct:sw_table_hash2	typeref:struct:sw_table_hash2::sw_table	file:
swt	lib/table-linear.cc	/^    struct sw_table swt;$/;"	m	struct:sw_table_linear	typeref:struct:sw_table_linear::sw_table	file:
syslog_levels	lib/vlog.cc	/^static int syslog_levels[VLL_N_LEVELS] = {$/;"	v	file:
t_nox_commun	RConn.hh	/^        pthread_t       t_nox_commun;$/;"	m	class:RConn
t_openflow_nox_commun	datapath.hh	/^	pthread_t	t_openflow_nox_commun;$/;"	m	class:Datapath
table	lib/of_crc32.hh	/^    unsigned int table[CRC32_TABLE_SIZE];$/;"	m	struct:crc32
table_hash2_create	lib/table-hash.cc	/^struct sw_table *table_hash2_create(unsigned int poly0, unsigned int buckets0,$/;"	f
table_hash2_delete	lib/table-hash.cc	/^static int table_hash2_delete(class Datapath *dp, struct sw_table *swt,$/;"	f	file:
table_hash2_destroy	lib/table-hash.cc	/^static void table_hash2_destroy(struct sw_table *swt)$/;"	f	file:
table_hash2_has_conflict	lib/table-hash.cc	/^static int table_hash2_has_conflict(struct sw_table *swt, $/;"	f	file:
table_hash2_insert	lib/table-hash.cc	/^static int table_hash2_insert(struct sw_table *swt, struct sw_flow *flow)$/;"	f	file:
table_hash2_iterate	lib/table-hash.cc	/^static int table_hash2_iterate(struct sw_table *swt,$/;"	f	file:
table_hash2_lookup	lib/table-hash.cc	/^static struct sw_flow *table_hash2_lookup(struct sw_table *swt,$/;"	f	file:
table_hash2_modify	lib/table-hash.cc	/^static int table_hash2_modify(struct sw_table *swt, $/;"	f	file:
table_hash2_stats	lib/table-hash.cc	/^static void table_hash2_stats(struct sw_table *swt,$/;"	f	file:
table_hash2_timeout	lib/table-hash.cc	/^static void table_hash2_timeout(struct sw_table *swt, struct list *deleted)$/;"	f	file:
table_hash_create	lib/table-hash.cc	/^struct sw_table *table_hash_create(unsigned int polynomial,$/;"	f
table_hash_delete	lib/table-hash.cc	/^static int table_hash_delete(class Datapath *dp, struct sw_table *swt,$/;"	f	file:
table_hash_destroy	lib/table-hash.cc	/^static void table_hash_destroy(struct sw_table *swt)$/;"	f	file:
table_hash_has_conflict	lib/table-hash.cc	/^static int table_hash_has_conflict(struct sw_table *swt,$/;"	f	file:
table_hash_insert	lib/table-hash.cc	/^static int table_hash_insert(struct sw_table *swt, struct sw_flow *flow)$/;"	f	file:
table_hash_iterate	lib/table-hash.cc	/^static int table_hash_iterate(struct sw_table *swt,$/;"	f	file:
table_hash_lookup	lib/table-hash.cc	/^static struct sw_flow *table_hash_lookup(struct sw_table *swt,$/;"	f	file:
table_hash_modify	lib/table-hash.cc	/^static int table_hash_modify(struct sw_table *swt, $/;"	f	file:
table_hash_stats	lib/table-hash.cc	/^static void table_hash_stats(struct sw_table *swt,$/;"	f	file:
table_hash_timeout	lib/table-hash.cc	/^static void table_hash_timeout(struct sw_table *swt, struct list *deleted)$/;"	f	file:
table_id	include/openflow/openflow.hh	/^    uint8_t table_id;         \/* ID of table flow came from. *\/$/;"	m	struct:ofp_flow_stats
table_id	include/openflow/openflow.hh	/^    uint8_t table_id;         \/* ID of table to read (from ofp_table_stats)$/;"	m	struct:ofp_aggregate_stats_request
table_id	include/openflow/openflow.hh	/^    uint8_t table_id;         \/* ID of table to read (from ofp_table_stats),$/;"	m	struct:ofp_flow_stats_request
table_id	include/openflow/openflow.hh	/^    uint8_t table_id;        \/* Identifier of table.  Lower numbered tables$/;"	m	struct:ofp_table_stats
table_idx	datapath.cc	/^	int table_idx;$/;"	m	struct:flow_stats_state	file:
table_linear_create	lib/table-linear.cc	/^struct sw_table *table_linear_create(unsigned int max_flows)$/;"	f
table_linear_delete	lib/table-linear.cc	/^static int table_linear_delete(class Datapath *dp, struct sw_table *swt,$/;"	f	file:
table_linear_destroy	lib/table-linear.cc	/^static void table_linear_destroy(struct sw_table *swt)$/;"	f	file:
table_linear_has_conflict	lib/table-linear.cc	/^static int table_linear_has_conflict(struct sw_table *swt,$/;"	f	file:
table_linear_insert	lib/table-linear.cc	/^static int table_linear_insert(struct sw_table *swt, struct sw_flow *flow)$/;"	f	file:
table_linear_iterate	lib/table-linear.cc	/^static int table_linear_iterate(struct sw_table *swt,$/;"	f	file:
table_linear_lookup	lib/table-linear.cc	/^static struct sw_flow *table_linear_lookup(struct sw_table *swt,$/;"	f	file:
table_linear_modify	lib/table-linear.cc	/^static int table_linear_modify(struct sw_table *swt,$/;"	f	file:
table_linear_stats	lib/table-linear.cc	/^static void table_linear_stats(struct sw_table *swt,$/;"	f	file:
table_linear_timeout	lib/table-linear.cc	/^static void table_linear_timeout(struct sw_table *swt, struct list *deleted)$/;"	f	file:
table_stats_dump	datapath.cc	/^static int table_stats_dump(class Datapath *dp, void *state UNUSED,$/;"	f	file:
tables	lib/chain.hh	/^    struct sw_table *tables[CHAIN_MAX_TABLES];$/;"	m	struct:sw_chain	typeref:struct:sw_chain::sw_table
tail	lib/queue.hh	/^    struct ofpbuf *tail;        \/* Last queued packet, null if n == 0. *\/$/;"	m	struct:ofp_queue	typeref:struct:ofp_queue::ofpbuf
tcn_timer	lib/stp.cc	/^    struct stp_timer tcn_timer;     \/* 8.5.4.2: Topology change timer. *\/$/;"	m	struct:stp	typeref:struct:stp::stp_timer	file:
tcp_ack	lib/packets.hh	/^    uint32_t tcp_ack;$/;"	m	struct:tcp_header
tcp_csum	lib/packets.hh	/^    uint16_t tcp_csum;$/;"	m	struct:tcp_header
tcp_ctl	lib/packets.hh	/^    uint16_t tcp_ctl;$/;"	m	struct:tcp_header
tcp_dst	lib/packets.hh	/^    uint16_t tcp_dst;$/;"	m	struct:tcp_header
tcp_end	include/openflow/nicira-ext.hh	/^    uint16_t tcp_end;$/;"	m	struct:nx_snat_config
tcp_flags	include/openflow/nicira-ext.hh	/^    uint8_t tcp_flags;        \/* Union of seen TCP flags. *\/$/;"	m	struct:nx_flow_end
tcp_header	lib/packets.hh	/^struct tcp_header {$/;"	s
tcp_open	lib/vconn-tcp.cc	/^tcp_open(const char *name, char *suffix, struct vconn **vconnp)$/;"	f	file:
tcp_seq	lib/packets.hh	/^    uint32_t tcp_seq;$/;"	m	struct:tcp_header
tcp_src	lib/packets.hh	/^    uint16_t tcp_src;$/;"	m	struct:tcp_header
tcp_start	include/openflow/nicira-ext.hh	/^    uint16_t tcp_start;$/;"	m	struct:nx_snat_config
tcp_urg	lib/packets.hh	/^    uint16_t tcp_urg;$/;"	m	struct:tcp_header
tcp_vconn_class	lib/vconn-tcp.cc	/^struct vconn_class tcp_vconn_class = {$/;"	v	typeref:struct:vconn_class
tcp_winsz	lib/packets.hh	/^    uint16_t tcp_winsz;$/;"	m	struct:tcp_header
thiszone	lib/pcap.cc	/^    int32_t thiszone;        \/* GMT to local correction *\/$/;"	m	struct:pcap_hdr	file:
thread_nox_commun	RConn.cc	/^void* thread_nox_commun(void* param)$/;"	f
tick	lib/timeval.cc	/^static volatile sig_atomic_t tick;$/;"	v	file:
time_add	lib/timeval.cc	/^time_add(time_t a, time_t b)$/;"	f	file:
time_alarm	lib/timeval.cc	/^time_alarm(unsigned int secs)$/;"	f
time_init	lib/timeval.cc	/^time_init(void)$/;"	f
time_msec	lib/timeval.cc	/^time_msec(void)$/;"	f
time_now	lib/timeval.cc	/^time_now(void)$/;"	f
time_poll	lib/timeval.cc	/^time_poll(struct pollfd *pollfds, int n_pollfds, int timeout)$/;"	f
time_refresh	lib/timeval.cc	/^time_refresh(void)$/;"	f
timed_out	lib/rconn.cc	/^timed_out(const struct rconn *rc)$/;"	f	file:
timeout	datapath.hh	/^	time_t timeout;$/;"	m	struct:dp_packet_buffer
timeout	lib/poll-loop.cc	/^static int timeout = -1;$/;"	v	file:
timeout	lib/rconn.cc	/^timeout(const struct rconn *rc)$/;"	f	file:
timeout	lib/table.hh	/^    void (*timeout)(struct sw_table *table, struct list *deleted);$/;"	m	struct:sw_table
timeout_ACTIVE	lib/rconn.cc	/^timeout_ACTIVE(const struct rconn *rc)$/;"	f	file:
timeout_BACKOFF	lib/rconn.cc	/^timeout_BACKOFF(const struct rconn *rc)$/;"	f	file:
timeout_CONNECTING	lib/rconn.cc	/^timeout_CONNECTING(const struct rconn *rc)$/;"	f	file:
timeout_IDLE	lib/rconn.cc	/^timeout_IDLE(const struct rconn *rc)$/;"	f	file:
timeout_VOID	lib/rconn.cc	/^timeout_VOID(const struct rconn *rc UNUSED)$/;"	f	file:
timer_to_ms	lib/stp.cc	/^timer_to_ms(int timer)$/;"	f	file:
tmp_dh_callback	lib/vconn-ssl.cc	/^tmp_dh_callback(SSL *ssl UNUSED, int is_export UNUSED, int keylength)$/;"	f	file:
tokens	lib/vlog.hh	/^    unsigned int tokens;        \/* Current number of tokens. *\/$/;"	m	struct:vlog_rate_limit
topology_change	lib/stp.cc	/^    bool topology_change;           \/* 8.5.3.12: Received topology change? *\/$/;"	m	struct:stp	file:
topology_change_ack	lib/stp.cc	/^    bool topology_change_ack;       \/* 8.5.5.8: Flag for next config BPDU. *\/$/;"	m	struct:stp_port	file:
topology_change_detected	lib/stp.cc	/^    bool topology_change_detected;  \/* 8.5.3.11: Detected a topology change? *\/$/;"	m	struct:stp	file:
topology_change_timer	lib/stp.cc	/^    struct stp_timer topology_change_timer; \/* 8.5.4.3. *\/$/;"	m	struct:stp	typeref:struct:stp::stp_timer	file:
total_len	include/openflow/openflow.hh	/^    uint16_t total_len;     \/* Full length of frame. *\/$/;"	m	struct:ofp_packet_in
total_time_connected	lib/rconn.cc	/^    unsigned long int total_time_connected;$/;"	m	struct:rconn	file:
tp_dst	include/openflow/openflow.hh	/^    uint16_t tp_dst;           \/* TCP\/UDP destination port. *\/$/;"	m	struct:ofp_match
tp_dst	lib/flow.hh	/^    uint16_t tp_dst;            \/* TCP\/UDP destination port. *\/$/;"	m	struct:flow
tp_port	include/openflow/openflow.hh	/^    uint16_t tp_port;               \/* TCP\/UDP port. *\/$/;"	m	struct:ofp_action_tp_port
tp_src	include/openflow/openflow.hh	/^    uint16_t tp_src;           \/* TCP\/UDP source port. *\/$/;"	m	struct:ofp_match
tp_src	lib/flow.hh	/^    uint16_t tp_src;            \/* TCP\/UDP source port. *\/$/;"	m	struct:flow
try_send	lib/rconn.cc	/^static int try_send(struct rconn *rc)$/;"	f	file:
ts_sec	lib/pcap.cc	/^    uint32_t ts_sec;         \/* timestamp seconds *\/$/;"	m	struct:pcaprec_hdr	file:
ts_usec	lib/pcap.cc	/^    uint32_t ts_usec;        \/* timestamp microseconds *\/$/;"	m	struct:pcaprec_hdr	file:
tx_bytes	datapath.hh	/^	unsigned long long int rx_bytes, tx_bytes;$/;"	m	struct:click_port
tx_bytes	datapath.hh	/^	unsigned long long int tx_bytes;$/;"	m	struct:sw_queue
tx_bytes	include/openflow/openflow.hh	/^    uint64_t tx_bytes;       \/* Number of transmitted bytes. *\/$/;"	m	struct:ofp_port_stats
tx_bytes	include/openflow/openflow.hh	/^    uint64_t tx_bytes;       \/* Number of transmitted bytes. *\/$/;"	m	struct:ofp_queue_stats
tx_dropped	datapath.hh	/^	unsigned long long int tx_dropped;$/;"	m	struct:click_port
tx_dropped	include/openflow/openflow.hh	/^    uint64_t tx_dropped;     \/* Number of packets dropped by TX. *\/$/;"	m	struct:ofp_port_stats
tx_errors	datapath.hh	/^	unsigned long long int tx_errors;$/;"	m	struct:sw_queue
tx_errors	include/openflow/openflow.hh	/^    uint64_t tx_errors;      \/* Number of packets dropped due to overrun. *\/$/;"	m	struct:ofp_queue_stats
tx_errors	include/openflow/openflow.hh	/^    uint64_t tx_errors;      \/* Number of transmit errors.  This is a super-set$/;"	m	struct:ofp_port_stats
tx_packets	datapath.hh	/^	unsigned long long int rx_packets, tx_packets;$/;"	m	struct:click_port
tx_packets	datapath.hh	/^	unsigned long long int tx_packets;$/;"	m	struct:sw_queue
tx_packets	include/openflow/openflow.hh	/^    uint64_t tx_packets;     \/* Number of transmitted packets. *\/$/;"	m	struct:ofp_port_stats
tx_packets	include/openflow/openflow.hh	/^    uint64_t tx_packets;     \/* Number of transmitted packets. *\/$/;"	m	struct:ofp_queue_stats
tx_waiter	lib/vconn-ssl.cc	/^    struct poll_waiter *tx_waiter;$/;"	m	struct:ssl_vconn	typeref:struct:ssl_vconn::poll_waiter	file:
tx_waiter	lib/vconn-stream.cc	/^    struct poll_waiter *tx_waiter;$/;"	m	struct:stream_vconn	typeref:struct:stream_vconn::poll_waiter	file:
tx_want	lib/vconn-ssl.cc	/^    int rx_want, tx_want;$/;"	m	struct:ssl_vconn	file:
txbuf	lib/vconn-ssl.cc	/^    struct ofpbuf *txbuf;$/;"	m	struct:ssl_vconn	typeref:struct:ssl_vconn::ofpbuf	file:
txbuf	lib/vconn-stream.cc	/^    struct ofpbuf *txbuf;$/;"	m	struct:stream_vconn	typeref:struct:stream_vconn::ofpbuf	file:
txq	lib/rconn.cc	/^    struct ofp_queue txq;$/;"	m	struct:rconn	typeref:struct:rconn::ofp_queue	file:
type	datapath.cc	/^	int type;$/;"	m	struct:stats_type	file:
type	include/openflow/nicira-ext.hh	/^    uint16_t type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_header
type	include/openflow/nicira-ext.hh	/^    uint16_t type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_snat
type	include/openflow/nicira-ext.hh	/^    uint16_t type;          \/* One of OFPAT_* *\/$/;"	m	struct:nx_act_config
type	include/openflow/openflow.hh	/^    uint16_t type;                  \/* OFPAT_OUTPUT. *\/$/;"	m	struct:ofp_action_output
type	include/openflow/openflow.hh	/^    uint16_t type;                  \/* OFPAT_SET_DL_SRC\/DST. *\/$/;"	m	struct:ofp_action_dl_addr
type	include/openflow/openflow.hh	/^    uint16_t type;                  \/* OFPAT_SET_TP_SRC\/DST. *\/$/;"	m	struct:ofp_action_tp_port
type	include/openflow/openflow.hh	/^    uint16_t type;                  \/* OFPAT_SET_TW_SRC\/DST. *\/$/;"	m	struct:ofp_action_nw_addr
type	include/openflow/openflow.hh	/^    uint16_t type;                  \/* OFPAT_SET_TW_SRC\/DST. *\/$/;"	m	struct:ofp_action_nw_tos
type	include/openflow/openflow.hh	/^    uint16_t type;                  \/* OFPAT_SET_VLAN_PCP. *\/$/;"	m	struct:ofp_action_vlan_pcp
type	include/openflow/openflow.hh	/^    uint16_t type;                  \/* OFPAT_SET_VLAN_VID. *\/$/;"	m	struct:ofp_action_vlan_vid
type	include/openflow/openflow.hh	/^    uint16_t type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:ofp_action_vendor_header
type	include/openflow/openflow.hh	/^    uint16_t type;                  \/* One of OFPAT_*. *\/$/;"	m	struct:ofp_action_header
type	include/openflow/openflow.hh	/^    uint16_t type;              \/* One of the OFPST_* constants. *\/$/;"	m	struct:ofp_stats_reply
type	include/openflow/openflow.hh	/^    uint16_t type;              \/* One of the OFPST_* constants. *\/$/;"	m	struct:ofp_stats_request
type	include/openflow/openflow.hh	/^    uint16_t type;            \/* OFPAT_ENQUEUE. *\/$/;"	m	struct:ofp_action_enqueue
type	include/openflow/openflow.hh	/^    uint16_t type;$/;"	m	struct:ofp_error_msg
type	include/openflow/openflow.hh	/^    uint8_t type;       \/* One of the OFPT_ constants. *\/$/;"	m	struct:ofp_header
type	lib/netlink.hh	/^    enum nl_attr_type type;$/;"	m	struct:nl_policy	typeref:enum:nl_policy::nl_attr_type
type	lib/ofp-print.cc	/^    int type;$/;"	m	struct:error_type	file:
type	lib/ofp-print.cc	/^    uint8_t type;$/;"	m	struct:openflow_packet	file:
type	lib/vconn-ssl.cc	/^    enum session_type type;$/;"	m	struct:ssl_vconn	typeref:enum:ssl_vconn::session_type	file:
udp_csum	lib/packets.hh	/^    uint16_t udp_csum;$/;"	m	struct:udp_header
udp_dst	lib/packets.hh	/^    uint16_t udp_dst;$/;"	m	struct:udp_header
udp_end	include/openflow/nicira-ext.hh	/^    uint16_t udp_end;$/;"	m	struct:nx_snat_config
udp_header	lib/packets.hh	/^struct udp_header {$/;"	s
udp_len	lib/packets.hh	/^    uint16_t udp_len;$/;"	m	struct:udp_header
udp_src	lib/packets.hh	/^    uint16_t udp_src;$/;"	m	struct:udp_header
udp_start	include/openflow/nicira-ext.hh	/^    uint16_t udp_start;$/;"	m	struct:nx_snat_config
unblock_sigalrm	lib/timeval.cc	/^unblock_sigalrm(const sigset_t *oldsigs)$/;"	f	file:
unix_open	lib/vconn-unix.cc	/^unix_open(const char *name, char *suffix, struct vconn **vconnp)$/;"	f	file:
unix_vconn_class	lib/vconn-unix.cc	/^struct vconn_class unix_vconn_class = {$/;"	v	typeref:struct:vconn_class
unknown	lib/ofpstat.hh	/^		uint64_t unknown;$/;"	m	struct:ofpstat::__anon4
unknown	lib/ofpstat.hh	/^		uint64_t unknown;$/;"	m	struct:ofpstat::__anon5
unknown	lib/ofpstat.hh	/^		uint64_t unknown;$/;"	m	struct:ofpstat::__anon6
unlink_files	lib/fatal-signal.cc	/^unlink_files(void *aux UNUSED)$/;"	f	file:
update_min_level	lib/vlog.cc	/^update_min_level(enum vlog_module module)$/;"	f	file:
update_openflow_length	lib/vconn.cc	/^update_openflow_length(struct ofpbuf *buffer) $/;"	f
update_port_flags	datapath.cc	/^void Datapath::update_port_flags(const struct ofp_port_mod *opm)$/;"	f	class:Datapath
update_queue_len	RConn.cc	/^void rconn_stat::update_queue_len(uint32_t qlen)$/;"	f	class:rconn_stat
used	lib/switch-flow.hh	/^    uint64_t used;              \/* Last used time. *\/$/;"	m	struct:sw_flow
used_time	include/openflow/nicira-ext.hh	/^    uint64_t used_time;       \/* Time entry was last used in milliseconds. *\/$/;"	m	struct:nx_flow_end
va_copy	lib/util.hh	49;"	d
validate	lib/dp_act.cc	/^    uint16_t (*validate)(class Datapath *dp, $/;"	m	struct:openflow_action	file:
validate_actions	lib/dp_act.cc	/^validate_actions(class Datapath *dp, const struct sw_flow_key *key,$/;"	f
validate_ofpat	lib/dp_act.cc	/^validate_ofpat(class Datapath *dp, const struct sw_flow_key *key, $/;"	f	file:
validate_output	lib/dp_act.cc	/^validate_output(class Datapath *dp UNUSED, const struct sw_flow_key *key, $/;"	f	file:
validate_queue	lib/dp_act.cc	/^validate_queue(class Datapath *dp UNUSED, const struct sw_flow_key *key UNUSED,$/;"	f	file:
validate_vendor	lib/dp_act.cc	/^validate_vendor(class Datapath *dp UNUSED, const struct sw_flow_key *key UNUSED, $/;"	f	file:
value	lib/stp.cc	/^    int value;                   \/* Current value of timer, counting up. *\/$/;"	m	struct:stp_timer	file:
vconn	lib/rconn.cc	/^    struct vconn *vconn;$/;"	m	struct:rconn	typeref:struct:rconn::vconn	file:
vconn	lib/vconn-netlink.cc	/^    struct vconn vconn;$/;"	m	struct:netlink_vconn	typeref:struct:netlink_vconn::vconn	file:
vconn	lib/vconn-provider.hh	/^struct vconn {$/;"	s
vconn	lib/vconn-ssl.cc	/^    struct vconn vconn;$/;"	m	struct:ssl_vconn	typeref:struct:ssl_vconn::vconn	file:
vconn	lib/vconn-stream.cc	/^    struct vconn vconn;$/;"	m	struct:stream_vconn	typeref:struct:stream_vconn::vconn	file:
vconn_assert_class	lib/vconn-provider.hh	/^static inline void vconn_assert_class(const struct vconn *vconn,$/;"	f
vconn_class	lib/vconn-provider.hh	/^struct vconn_class {$/;"	s
vconn_classes	lib/vconn.cc	/^static struct vconn_class *vconn_classes[] = {$/;"	v	typeref:struct:vconn_class	file:
vconn_close	lib/vconn.cc	/^vconn_close(struct vconn *vconn)$/;"	f
vconn_connect	lib/vconn.cc	/^vconn_connect(struct vconn *vconn)$/;"	f
vconn_connect_wait	lib/vconn.cc	/^vconn_connect_wait(struct vconn *vconn)$/;"	f
vconn_get_ip	lib/vconn.cc	/^vconn_get_ip(const struct vconn *vconn) $/;"	f
vconn_get_name	lib/vconn.cc	/^vconn_get_name(const struct vconn *vconn)$/;"	f
vconn_init	lib/vconn.cc	/^vconn_init(struct vconn *vconn, struct vconn_class *Class, int connect_status,$/;"	f
vconn_is_reconnectable	lib/vconn.cc	/^vconn_is_reconnectable(const struct vconn *vconn)$/;"	f
vconn_open	lib/vconn.cc	/^vconn_open(const char *name, int min_version, struct vconn **vconnp)$/;"	f
vconn_open_block	lib/vconn.cc	/^vconn_open_block(const char *name, int min_version, struct vconn **vconnp)$/;"	f
vconn_recv	lib/vconn.cc	/^vconn_recv(struct vconn *vconn, struct ofpbuf **msgp)$/;"	f
vconn_recv_block	lib/vconn.cc	/^vconn_recv_block(struct vconn *vconn, struct ofpbuf **msgp)$/;"	f
vconn_recv_wait	lib/vconn.cc	/^vconn_recv_wait(struct vconn *vconn)$/;"	f
vconn_recv_xid	lib/vconn.cc	/^vconn_recv_xid(struct vconn *vconn, uint32_t xid, struct ofpbuf **replyp)$/;"	f
vconn_send	lib/vconn.cc	/^int vconn_send(struct vconn *vconn, struct ofpbuf *msg)$/;"	f
vconn_send_block	lib/vconn.cc	/^int vconn_send_block(struct vconn *vconn, struct ofpbuf *msg)$/;"	f
vconn_send_wait	lib/vconn.cc	/^vconn_send_wait(struct vconn *vconn)$/;"	f
vconn_ssl_is_configured	lib/vconn-ssl.cc	/^vconn_ssl_is_configured(void) $/;"	f
vconn_ssl_set_ca_cert_file	lib/vconn-ssl.cc	/^vconn_ssl_set_ca_cert_file(const char *file_name, bool bootstrap)$/;"	f
vconn_ssl_set_certificate_file	lib/vconn-ssl.cc	/^vconn_ssl_set_certificate_file(const char *file_name)$/;"	f
vconn_ssl_set_peer_ca_cert_file	lib/vconn-ssl.cc	/^vconn_ssl_set_peer_ca_cert_file(const char *file_name)$/;"	f
vconn_ssl_set_private_key_file	lib/vconn-ssl.cc	/^vconn_ssl_set_private_key_file(const char *file_name)$/;"	f
vconn_state	lib/vconn.cc	/^enum vconn_state {$/;"	g	file:
vconn_transact	lib/vconn.cc	/^vconn_transact(struct vconn *vconn, struct ofpbuf *request,$/;"	f
vconn_usage	lib/vconn.cc	/^vconn_usage(bool active, bool passive, bool bootstrap UNUSED)$/;"	f
vconn_wait	lib/vconn.cc	/^vconn_wait(struct vconn *vconn, enum vconn_wait_type wait)$/;"	f
vconn_wait_type	lib/vconn.hh	/^enum vconn_wait_type {$/;"	g
vcs_connecting	lib/vconn.cc	/^vcs_connecting(struct vconn *vconn) $/;"	f	file:
vcs_recv_hello	lib/vconn.cc	/^vcs_recv_hello(struct vconn *vconn)$/;"	f	file:
vcs_send_error	lib/vconn.cc	/^vcs_send_error(struct vconn *vconn)$/;"	f	file:
vcs_send_hello	lib/vconn.cc	/^vcs_send_hello(struct vconn *vconn)$/;"	f	file:
vendor	include/openflow/nicira-ext.hh	/^    uint32_t vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_header
vendor	include/openflow/nicira-ext.hh	/^    uint32_t vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_snat
vendor	include/openflow/nicira-ext.hh	/^    uint32_t vendor;            \/* NX_VENDOR_ID. *\/$/;"	m	struct:nicira_header
vendor	include/openflow/openflow-ext.hh	/^    uint32_t vendor;            \/* OPENFLOW_VENDOR_ID. *\/$/;"	m	struct:ofp_extension_header
vendor	include/openflow/openflow.hh	/^    uint32_t vendor;                \/* Vendor ID, which takes the same form$/;"	m	struct:ofp_action_vendor_header
vendor	include/openflow/openflow.hh	/^    uint32_t vendor;            \/* Vendor ID:$/;"	m	struct:ofp_vendor_header
vendor_stat	lib/ofp-print.cc	/^vendor_stat(struct ds *string, const void *body, size_t len,$/;"	f	file:
vendor_stats_done	datapath.cc	/^static void vendor_stats_done(void *state)$/;"	f	file:
vendor_stats_dump	datapath.cc	/^static int vendor_stats_dump(class Datapath *dp UNUSED, void *state,$/;"	f	file:
vendor_stats_init	datapath.cc	/^static int vendor_stats_init(const void *body, int body_len UNUSED,$/;"	f	file:
version	include/openflow/openflow.hh	/^    uint8_t version;    \/* OFP_VERSION. *\/$/;"	m	struct:ofp_header
version	lib/netlink-protocol.hh	/^    uint8_t version;$/;"	m	struct:genlmsghdr
version	lib/vconn-provider.hh	/^    int version;$/;"	m	struct:vconn
version_major	lib/pcap.cc	/^    uint16_t version_major;  \/* major version number *\/$/;"	m	struct:pcap_hdr	file:
version_minor	lib/pcap.cc	/^    uint16_t version_minor;  \/* minor version number *\/$/;"	m	struct:pcap_hdr	file:
veth_dst	lib/packets.hh	/^    uint8_t veth_dst[ETH_ADDR_LEN];$/;"	m	struct:vlan_eth_header
veth_next_type	lib/packets.hh	/^    uint16_t veth_next_type;$/;"	m	struct:vlan_eth_header
veth_src	lib/packets.hh	/^    uint8_t veth_src[ETH_ADDR_LEN];$/;"	m	struct:vlan_eth_header
veth_tci	lib/packets.hh	/^    uint16_t veth_tci;          \/* Lowest 12 bits are VLAN ID. *\/$/;"	m	struct:vlan_eth_header
veth_type	lib/packets.hh	/^    uint16_t veth_type;         \/* Always htons(ETH_TYPE_VLAN). *\/$/;"	m	struct:vlan_eth_header
vlan_eth_header	lib/packets.hh	/^struct vlan_eth_header {$/;"	s
vlan_header	lib/packets.hh	/^struct vlan_header {$/;"	s
vlan_next_type	lib/packets.hh	/^    uint16_t vlan_next_type;$/;"	m	struct:vlan_header
vlan_pcp	include/openflow/openflow.hh	/^    uint8_t vlan_pcp;               \/* VLAN priority. *\/$/;"	m	struct:ofp_action_vlan_pcp
vlan_pull_tag	lib/dp_act.cc	/^vlan_pull_tag(struct ofpbuf *buffer)$/;"	f	file:
vlan_tci	lib/packets.hh	/^    uint16_t vlan_tci;          \/* Lowest 12 bits are VLAN ID. *\/$/;"	m	struct:vlan_header
vlan_vid	include/openflow/openflow.hh	/^    uint16_t vlan_vid;              \/* VLAN id. *\/$/;"	m	struct:ofp_action_vlan_vid
vlog	lib/vlog.cc	/^vlog(enum vlog_module module, enum vlog_level level, const char *message, ...)$/;"	f
vlog_client	lib/vlog-socket.cc	/^struct vlog_client {$/;"	s	file:
vlog_client_close	lib/vlog-socket.cc	/^vlog_client_close(struct vlog_client *client)$/;"	f
vlog_client_connect	lib/vlog-socket.cc	/^vlog_client_connect(const char *path, struct vlog_client **clientp)$/;"	f
vlog_client_recv	lib/vlog-socket.cc	/^vlog_client_recv(struct vlog_client *client, char **reply)$/;"	f
vlog_client_send	lib/vlog-socket.cc	/^vlog_client_send(struct vlog_client *client, const char *request)$/;"	f
vlog_client_target	lib/vlog-socket.cc	/^vlog_client_target(const struct vlog_client *client)$/;"	f
vlog_client_transact	lib/vlog-socket.cc	/^vlog_client_transact(struct vlog_client *client,$/;"	f
vlog_exit	lib/vlog.cc	/^vlog_exit(void) $/;"	f
vlog_facility	lib/vlog.hh	/^enum vlog_facility {$/;"	g
vlog_get_facility_name	lib/vlog.cc	/^vlog_get_facility_name(enum vlog_facility facility) $/;"	f
vlog_get_facility_val	lib/vlog.cc	/^vlog_get_facility_val(const char *name) $/;"	f
vlog_get_level	lib/vlog.cc	/^vlog_get_level(enum vlog_module module, enum vlog_facility facility) $/;"	f
vlog_get_level_name	lib/vlog.cc	/^vlog_get_level_name(enum vlog_level level)$/;"	f
vlog_get_level_val	lib/vlog.cc	/^vlog_get_level_val(const char *name) $/;"	f
vlog_get_levels	lib/vlog.cc	/^vlog_get_levels(void)$/;"	f
vlog_get_log_file	lib/vlog.cc	/^vlog_get_log_file(void)$/;"	f
vlog_get_module_name	lib/vlog.cc	/^const char *vlog_get_module_name(enum vlog_module module) $/;"	f
vlog_get_module_val	lib/vlog.cc	/^vlog_get_module_val(const char *name) $/;"	f
vlog_init	lib/vlog.cc	/^vlog_init(void) $/;"	f
vlog_is_enabled	lib/vlog.cc	/^vlog_is_enabled(enum vlog_module module, enum vlog_level level)$/;"	f
vlog_level	lib/vlog.hh	/^enum vlog_level {$/;"	g
vlog_module	lib/vlog.hh	/^enum vlog_module {$/;"	g
vlog_rate_limit	lib/vlog.cc	/^vlog_rate_limit(enum vlog_module module, enum vlog_level level,$/;"	f
vlog_rate_limit	lib/vlog.hh	/^struct vlog_rate_limit {$/;"	s
vlog_reopen_log_file	lib/vlog.cc	/^vlog_reopen_log_file(void)$/;"	f
vlog_server	lib/vlog-socket.cc	/^struct vlog_server {$/;"	s	file:
vlog_server_close	lib/vlog-socket.cc	/^vlog_server_close(struct vlog_server *server)$/;"	f
vlog_server_listen	lib/vlog-socket.cc	/^vlog_server_listen(const char *path, struct vlog_server **serverp)$/;"	f
vlog_set_levels	lib/vlog.cc	/^vlog_set_levels(enum vlog_module module, enum vlog_facility facility,$/;"	f
vlog_set_levels_from_string	lib/vlog.cc	/^vlog_set_levels_from_string(const char *s_)$/;"	f
vlog_set_log_file	lib/vlog.cc	/^vlog_set_log_file(const char *file_name)$/;"	f
vlog_set_pattern	lib/vlog.cc	/^vlog_set_pattern(enum vlog_facility facility, const char *pattern)$/;"	f
vlog_set_verbosity	lib/vlog.cc	/^vlog_set_verbosity(const char *arg)$/;"	f
vlog_usage	lib/vlog.cc	/^vlog_usage(void) $/;"	f
vlog_valist	lib/vlog.cc	/^vlog_valist(enum vlog_module module, enum vlog_level level,$/;"	f
wait	lib/vconn-provider.hh	/^    void (*wait)(struct pvconn *pvconn);$/;"	m	struct:pvconn_class
wait	lib/vconn-provider.hh	/^    void (*wait)(struct vconn *vconn, enum vconn_wait_type type);$/;"	m	struct:vconn_class
waiter	lib/vlog-socket.cc	/^    struct poll_waiter *waiter;$/;"	m	struct:vlog_server	typeref:struct:vlog_server::poll_waiter	file:
waiters	lib/poll-loop.cc	/^static struct list waiters = LIST_INITIALIZER(&waiters);$/;"	v	typeref:struct:list	file:
want_to_poll_events	lib/vconn-ssl.cc	/^want_to_poll_events(int want)$/;"	f	file:
wildcards	include/openflow/openflow.hh	/^    uint32_t wildcards;        \/* Wildcard fields. *\/$/;"	m	struct:ofp_match
wildcards	include/openflow/openflow.hh	/^    uint32_t wildcards;      \/* Bitmap of OFPFW_* wildcards that are$/;"	m	struct:ofp_table_stats
wildcards	lib/switch-flow.hh	/^    uint32_t wildcards;         \/* Wildcard fields (in host byte order). *\/$/;"	m	struct:sw_flow_key
wildcards	lib/table.hh	/^    uint32_t wildcards;          \/* Bitmap of OFPFW_* wildcards that are$/;"	m	struct:sw_table_stats
x2nrealloc	lib/util.cc	/^x2nrealloc(void *p, size_t *n, size_t s)$/;"	f
xasprintf	lib/util.cc	/^xasprintf(const char *format, ...)$/;"	f
xcalloc	lib/util.cc	/^xcalloc(size_t count, size_t size) $/;"	f
xid	SynchronizedPacketQueue.hh	/^	int32_t xid;$/;"	m	struct:buf_rconn
xid	datapath.cc	/^	uint32_t xid;$/;"	m	struct:stats_dump_cb	file:
xid	include/openflow/openflow.hh	/^    uint32_t xid;       \/* Transaction id associated with this packet.$/;"	m	struct:ofp_header
xmalloc	lib/util.cc	/^xmalloc(size_t size) $/;"	f
xmemdup	lib/util.cc	/^xmemdup(const void *p_, size_t size)$/;"	f
xmemdup0	lib/util.cc	/^xmemdup0(const char *p_, size_t length)$/;"	f
xrealloc	lib/util.cc	/^xrealloc(void *p, size_t size) $/;"	f
xstrdup	lib/util.cc	/^xstrdup(const char *s) $/;"	f
xvasprintf	lib/util.cc	/^xvasprintf(const char *format, va_list args)$/;"	f
~Datapath	datapath.cc	/^Datapath::~Datapath()$/;"	f	class:Datapath
~DatapathPacketBuffer	datapath.cc	/^DatapathPacketBuffer::~DatapathPacketBuffer()$/;"	f	class:DatapathPacketBuffer
~RConn	RConn.cc	/^RConn::~RConn()$/;"	f	class:RConn
